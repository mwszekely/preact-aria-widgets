(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t,
        o$2,
        r$2,
        f$1 = {},
        e$1 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$2(n, l) {
      if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$2(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b(n) {
      (!n.__d && (n.__d = !0) && t.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t.length;) n = t.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$1(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$1,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$2(i, h + 1)), N$1(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$2(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x$2(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x$2(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$2(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$1(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$2(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$2(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$1(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$2(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N$1(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$2(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null, n.__c = void 0;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N$1(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
    }

    function B$2(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$1.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
    }, d$1.prototype.render = p$1, t = [], g$2.__r = 0, r$2 = 0;

    var _$1 = 0;

    function o$1(o, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: o,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --_$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof o && (l = o.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var r$1,
        u,
        i,
        o,
        f = 0,
        c = [],
        e = [],
        a = l$1.__b,
        v = l$1.__r,
        l = l$1.diffed,
        m = l$1.__c,
        d = l$1.unmount;

    function p(t, r) {
      l$1.__h && l$1.__h(u, t, f || r), f = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: e
      }), i.__[t];
    }

    function y(n) {
      return f = 1, h(C$1, n);
    }

    function h(n, t, i) {
      var o = p(r$1++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(t) : C$1(void 0, t), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = u, !u.u)) {
        u.u = !0;
        var f = u.shouldComponentUpdate;

        u.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !f || f.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !!i && (!f || f.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function s(t, i) {
      var o = p(r$1++, 3);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__H.__h.push(o));
    }

    function _(t, i) {
      var o = p(r$1++, 4);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__h.push(o));
    }

    function A(n) {
      return f = 5, T$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function T$1(n, t) {
      var u = p(r$1++, 7);
      return B$1(u.__H, t) ? (u.__V = n(), u.i = t, u.__h = n, u.__V) : u.__;
    }

    function q$1(n, t) {
      return f = 8, T$1(function () {
        return n;
      }, t);
    }

    function x$1(n) {
      var t = u.context[n.__c],
          i = p(r$1++, 9);
      return i.c = n, t ? (null == i.__ && (i.__ = !0, t.sub(u)), t.props.value) : n.__;
    }

    function g$1() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(w), t.__H.__h.forEach(z$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      "function" != typeof n.type || n.o || n.type === p$1 ? n.o || (n.o = n.__ && n.__.o ? n.__.o : "") : n.o = (n.__ && n.__.o ? n.__.o : "") + (n.__ && n.__.__k ? n.__.__k.indexOf(n) : 0), u = null, a && a(n);
    }, l$1.__r = function (n) {
      v && v(n), r$1 = 0;
      var t = (u = n.__c).__H;
      t && (i === u ? (t.__h = [], u.__h = [], t.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = e, n.__N = n.i = void 0;
      })) : (t.__h.forEach(w), t.__h.forEach(z$1), t.__h = [])), i = u;
    }, l$1.diffed = function (t) {
      l && l(t);
      var r = t.__c;
      r && r.__H && (r.__H.__h.length && (1 !== c.push(r) && o === l$1.requestAnimationFrame || ((o = l$1.requestAnimationFrame) || k)(g$1)), r.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== e && (n.__ = n.__V), n.i = void 0, n.__V = e;
      })), i = u = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(w), t.__h = t.__h.filter(function (n) {
            return !n.__ || z$1(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), m && m(t, r);
    }, l$1.unmount = function (t) {
      d && d(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          w(n);
        } catch (n) {
          r = n;
        }
      }), u.__H = void 0, r && l$1.__e(r, u.__v));
    };
    var j$1 = "function" == typeof requestAnimationFrame;

    function k(n) {
      var t,
          r = function () {
        clearTimeout(u), j$1 && cancelAnimationFrame(t), setTimeout(n);
      },
          u = setTimeout(r, 100);

      j$1 && (t = requestAnimationFrame(r));
    }

    function w(n) {
      var t = u,
          r = n.__c;
      "function" == typeof r && (n.__c = void 0, r()), u = t;
    }

    function z$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function B$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function C$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }
    const alreadyWarned = new Set();
    function warnOnOverwrite(componentName, propName, propValue, newValue) {
      const key = `${componentName};${propName}`;

      if (propValue != null) {
        if (!alreadyWarned.has(key)) {
          alreadyWarned.add(key);
          console.warn(`The ${propName} attribute on ${componentName} was given a value of ${propValue} but is being overwritten to ${newValue} for conformance. Consider removing it before passing those props to ${componentName}.`);
        }
      }

      return newValue;
    }
    function debugLog(who) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
    }

    const HeadingLevelContext = B$2(0);
    function Heading(_ref) {
      let {
        children,
        heading,
        ...props
      } = _ref;
      const headingLevelBeforeUs = x$1(HeadingLevelContext);
      const newHeadingLevel = headingLevelBeforeUs + 1;
      let tag;

      if (newHeadingLevel <= 6) {
        tag = `h${newHeadingLevel}`;
      } else {
        tag = 'div';
        props["aria-level"] = warnOnOverwrite("Heading", "aria-level", props["aria-level"], `${newHeadingLevel}`);
      }

      return o$1(p$1, {
        children: o$1(HeadingReset, {
          newLevel: headingLevelBeforeUs + 1,
          children: [h$1(tag, props, heading), children]
        })
      });
    }
    function HeadingReset(_ref2) {
      let {
        newLevel,
        children
      } = _ref2;
      return o$1(HeadingLevelContext.Provider, {
        value: newLevel,
        children: children
      });
    }

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = A(value);
        const shownError = A(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    function debounceRendering(f) {
      var _options$debounceRend;

      ((_options$debounceRend = l$1.debounceRendering) !== null && _options$debounceRend !== void 0 ? _options$debounceRend : setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */

    function usePassiveState(onChange, getInitialValue) {
      const valueRef = A(Unset$1);
      const warningRef = A(false);
      const cleanupCallbackRef = A(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = q$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = q$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = q$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      _(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const r = A({
        microtaskQueued: false,
        arg: undefined,
        prevDep: undefined
      });
      const setValue = q$1(arg => {
        r.current.prevDep = valueRef.current === Unset$1 ? undefined : getValue();
        r.current.arg = arg;

        if (!r.current.microtaskQueued) {
          r.current.microtaskQueued = true;
          debounceRendering(() => {
            r.current.microtaskQueued = false; //r.current.handle = null;

            const prevDep = r.current.prevDep;
            const arg = r.current.arg;
            const dep = arg instanceof Function ? arg(prevDep) : arg;

            if (dep !== valueRef.current) {
              // Indicate to the user that they shouldn't call getValue during onChange
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(dep, prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = dep;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            }
          });
        }
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }
    function returnZero() {
      return 0;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = q$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = q$1((e, prevValue) => {
        const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull);
      const useRefElementProps = q$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Set(); // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      if (!microtasks.has(map)) {
        microtasks.add(map);
        debounceRendering(() => {
          microtasks.delete(map);
          const updaters = map.get(window);

          if (updaters) {
            for (const updater of updaters) {
              updater === null || updater === void 0 ? void 0 : updater(value);
            }
          }
        });
      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        onMount,
        onUnmount,
        onMountChange
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMountChange, onMount, onUnmount);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onMount,
        onUnmount,
        onElementChange: q$1((element, prevValue) => {
          onMountChange === null || onMountChange === void 0 ? void 0 : onMountChange(element, prevValue);

          if (element) {
            var _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

            const document = element.ownerDocument;
            const window = document === null || document === void 0 ? void 0 : document.defaultView;

            if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
              document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
                passive: true
              });
              document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
                passive: true
              });
              window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
                passive: true
              });
              window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
                passive: true
              });
            } // Add them even if they're undefined to more easily
            // manage the ">0 means don't add handlers" logic.


            const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
            const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
            const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
            localActiveElementUpdaters.add(setActiveElement);
            localLastActiveElementUpdaters.add(setLastActiveElement);
            localWindowFocusedUpdaters.add(setWindowFocused);
            activeElementUpdaters.set(window, localActiveElementUpdaters);
            lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
            windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
            return () => {
              activeElementUpdaters.get(window).delete(setActiveElement);
              lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
              windowFocusedUpdaters.get(window).delete(setWindowFocused);

              if (activeElementUpdaters.size === 0) {
                document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
                document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
                window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
                window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
              }
            };
          }
        }, [])
      });
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getElement,
        useActiveElementProps: useRefElementProps,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = y(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      s(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = A(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return q$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return q$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B$2(null);

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */

    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString$1 = objectProto$5.toString;
    /** Built-in value references. */

    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */

    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString = objectProto$4.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */

    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    /** Built-in value references. */

    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = y(initialState);
      const ref = A(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = q$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
     * passing one of them as this argument. By default, it's `useEffect`.
     */

    function useEffect(effect, inputs) {
      let impl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : s;
      const prevInputs = A(undefined);

      const effect2 = () => {
        const changes = [];

        if (inputs && prevInputs.current) {
          for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
            if (prevInputs.current[i] != inputs[i]) changes[i] = {
              from: prevInputs.current[i],
              to: inputs[i]
            };
          }
        }

        const ret = effect(prevInputs.current, changes);
        prevInputs.current = inputs;
        return ret;
      };

      impl(effect2, inputs);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      return useEffect(effect, inputs, _);
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(parentParameters) {
      const {
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = q$1(() => {
        return managedChildrenArray.current.highestIndex;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = A({
        arr: [],
        rec: {},
        highestIndex: 0,
        lowestIndex: 0
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which need to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = q$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = q$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = A(null);
      const remoteULEChildChangedCausers = A(new Set());
      const remoteULEChildChanged = q$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = q$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (mounted) {
          managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
        } else {
          if (typeof index == "number") {
            delete managedChildrenArray.current.arr[index];
            let shave = 0;

            while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) ++shave;

            managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - 1 - shave, shave);
          } else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = q$1(_ref => {
        let {
          managedChild: info
        } = _ref;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        useLayoutEffect(() => {
          var _info$flags, _info$flags2;

          // Insert this information in-place
          if (typeof info.index == "number") managedChildrenArray.current.arr[info.index] = {
            index: info.index,
            flags: (_info$flags = info.flags) !== null && _info$flags !== void 0 ? _info$flags : {},
            subInfo: info.subInfo
          };else managedChildrenArray.current.rec[info.index] = {
            index: info.index,
            flags: (_info$flags2 = info.flags) !== null && _info$flags2 !== void 0 ? _info$flags2 : {},
            subInfo: info.subInfo
          };
          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
        // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        useLayoutEffect(() => {
          remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
          return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, false);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = A({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        arraySlice: () => {
          return managedChildrenArray.current.arr.slice();
        }
      });
      return {
        useManagedChild,
        managedChildren: {
          children: managedChildren.current
        }
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref2) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key
      } = _ref2;
      useEnsureStability("useChildrenFlag", onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, [])); //    const getFitNullToZero = useStableGetter(fitNullToZero);
      // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = q$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          var _child$flags, _child$flags$key;

          if ((_child$flags = child.flags) !== null && _child$flags !== void 0 && (_child$flags$key = _child$flags[key]) !== null && _child$flags$key !== void 0 && _child$flags$key.isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const reevaluateClosestFit = useStableCallback(() => {
        var _currentChild$flags, _currentChild$flags$k;

        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !((_currentChild$flags = currentChild.flags) !== null && _currentChild$flags !== void 0 && (_currentChild$flags$k = _currentChild$flags[key]) !== null && _currentChild$flags$k !== void 0 && _currentChild$flags$k.isValid()))) {
          var _currentChild$flags2;

          currentChild === null || currentChild === void 0 ? void 0 : (_currentChild$flags2 = currentChild.flags) === null || _currentChild$flags2 === void 0 ? void 0 : _currentChild$flags2[key].set(false);
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex);

          if (closestFitIndex != null) {
            var _closestFitChild$flag;

            const closestFitChild = children.getAt(closestFitIndex);
            console.assert(closestFitChild != null, "Internal logic???");
            (_closestFitChild$flag = closestFitChild.flags) === null || _closestFitChild$flag === void 0 ? void 0 : _closestFitChild$flag[key].set(true);
          }
        }
      });
      const changeIndex = q$1(arg => {
        const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg; //if (requestedIndex == null && getFitNullToZero())
        //    requestedIndex = 0;

        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          var _oldMatchingChild$fla;

          // Easy case
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla = oldMatchingChild.flags) === null || _oldMatchingChild$fla === void 0 ? void 0 : _oldMatchingChild$fla[key].set(false);
          return null;
        } else {
          var _newMatchingChild$fla;

          if (newMatchingChild && (_newMatchingChild$fla = newMatchingChild.flags) !== null && _newMatchingChild$fla !== void 0 && _newMatchingChild$fla[key].isValid()) {
            var _oldMatchingChild$fla2, _newMatchingChild$fla2;

            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla2 = oldMatchingChild.flags) === null || _oldMatchingChild$fla2 === void 0 ? void 0 : _oldMatchingChild$fla2[key].set(false);
            (_newMatchingChild$fla2 = newMatchingChild.flags) === null || _newMatchingChild$fla2 === void 0 ? void 0 : _newMatchingChild$fla2[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              var _oldMatchingChild$fla3, _newMatchingChild$fla3;

              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla3 = oldMatchingChild.flags) === null || _oldMatchingChild$fla3 === void 0 ? void 0 : _oldMatchingChild$fla3[key].set(false);
              (_newMatchingChild$fla3 = newMatchingChild.flags) === null || _newMatchingChild$fla3 === void 0 ? void 0 : _newMatchingChild$fla3[key].set(true);
              return closestFitIndex;
            } else {
              var _oldMatchingChild$fla4;

              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla4 = oldMatchingChild.flags) === null || _oldMatchingChild$fla4 === void 0 ? void 0 : _oldMatchingChild$fla4[key].set(false);
              return null;
            }
          }
        }
      }, []);
      useLayoutEffect(() => {
        var _children$getAt, _children$getAt$flags, _children$getAt$flags2;

        if (initialIndex != null) (_children$getAt = children.getAt(initialIndex)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$flags = _children$getAt.flags) === null || _children$getAt$flags === void 0 ? void 0 : (_children$getAt$flags2 = _children$getAt$flags[key]) === null || _children$getAt$flags2 === void 0 ? void 0 : _children$getAt$flags2.set(true);
      }, []);
      return {
        changeIndex,
        reevaluateClosestFit,
        getCurrentIndex
      };
    }
    /*export type Spread<A extends {}, B extends {}> = Omit<A, keyof B> & B;
    export function spread<A extends {}, B extends {}>(a: A, b: B): Spread<A, B> {
        return {
            ...a,
            ...b
        }
    }*/

    /*
    function test() {
        type C = { foo: "bar" };
        type K = "flag2";

        const { children, useManagedChild } = useManagedChildren<number, C, K>({ managedChildren: { onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => onChildrenMountChange(mounted, unmounted)) } });
        useManagedChild({ managedChild: { index: 0, info: { foo: "bar" }, flags: {  } } });
        const { changeIndex, getCurrentIndex, onChildrenMountChange } = useChildrenFlag<C, K>({ children, initialIndex: 0, key: "flag2" })
    }*/

    function getDocument(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useElementSize(_ref) {
      let {
        getObserveBox,
        onSizeChange
      } = _ref;
      useEnsureStability("useElementSize", getObserveBox, onSizeChange);
      const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
      const currentObserveBox = A(undefined);
      const needANewObserver = q$1((element, observeBox) => {
        if (element) {
          const document = getDocument(element);
          const window = document.defaultView;

          const handleUpdate = () => {
            if (element.isConnected) {
              const {
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              } = element;
              setSize({
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              });
            }
          };

          if (window && "ResizeObserver" in window) {
            const observer = new ResizeObserver(_entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          } else {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          }
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(e => needANewObserver(e, getObserveBox === null || getObserveBox === void 0 ? void 0 : getObserveBox()), [])
      });
      s(() => {
        if (getObserveBox) {
          if (currentObserveBox.current !== getObserveBox()) needANewObserver(getElement(), getObserveBox());
        }
      });
      return {
        getElement,
        getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      s(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */

    function useForceUpdate() {
      const [, set] = y(0);
      return A(() => set(i => ++i)).current;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused,
        useActiveElementProps,
        getElement
      } = useActiveElement({
        onActiveElementChange: q$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = q$1(props => {
        return useActiveElementProps(props);
      }, []);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substring(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(_ref) {
      let {
        onLogicalDirectionChange
      } = _ref;
      useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
      const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(element => {
          if (element) {
            setComputedStyles(window.getComputedStyle(element));
          }
        }, [])
      }); // TODO: There's no way to refresh which writing mode we have once mounted.
      //   A. There's no way to watch for CSS style changes
      //   B. Calling getComputedStyle after every render for every element gets expensive fast and
      //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
      //      (Those that do will need to mount and unmount the component that uses it)
      //
      // As a solution, here's a cheap workaround that checks when the element's size has changed,
      // and if so, tests if the writing mode has changed too.
      //
      // This will work for at least some number of cases, but a better solution is still needed.

      const {
        useElementSizeProps
      } = useElementSize({
        onSizeChange: q$1(_ => onLogicalDirectionChange === null || onLogicalDirectionChange === void 0 ? void 0 : onLogicalDirectionChange(getLogicalDirectionInfo()), [])
      });
      const getLogicalDirectionInfo = q$1(() => {
        const computedStyles = getComputedStyles();

        if (computedStyles) {
          const w = computedStyles.writingMode;
          let d = computedStyles.direction;
          const t = computedStyles.textOrientation;
          if (t == "upright") d = "ltr";
          return { ...WritingModes[w || "horizontal-tb"][d || "ltr"]
          };
        }

        return null;
      }, []); //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);

      const convertToLogicalOrientation = q$1((elementOrientation, direction) => {
        var _direction, _direction2;

        (_direction = direction) !== null && _direction !== void 0 ? _direction : direction = getLogicalDirectionInfo();
        if (((_direction2 = direction) === null || _direction2 === void 0 ? void 0 : _direction2.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, []);
      const convertToPhysicalSide = q$1((side, direction) => {
        var _direction3, _direction$blockDirec, _direction4, _direction$blockDirec2, _direction5, _direction$inlineDire, _direction6, _direction$inlineDire2, _direction7;

        (_direction3 = direction) !== null && _direction3 !== void 0 ? _direction3 : direction = getLogicalDirectionInfo();

        switch (side) {
          case "block-start":
            return M$1[((_direction$blockDirec = (_direction4 = direction) === null || _direction4 === void 0 ? void 0 : _direction4.blockDirection) !== null && _direction$blockDirec !== void 0 ? _direction$blockDirec : "ttb")[0]];

          case "block-end":
            return M$1[((_direction$blockDirec2 = (_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.blockDirection) !== null && _direction$blockDirec2 !== void 0 ? _direction$blockDirec2 : "ttb")[2]];

          case "inline-start":
            return M$1[((_direction$inlineDire = (_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.inlineDirection) !== null && _direction$inlineDire !== void 0 ? _direction$inlineDire : "ltr")[0]];

          case "inline-end":
            return M$1[((_direction$inlineDire2 = (_direction7 = direction) === null || _direction7 === void 0 ? void 0 : _direction7.inlineDirection) !== null && _direction$inlineDire2 !== void 0 ? _direction$inlineDire2 : "ltr")[2]];
        }
      }, []);
      const convertToLogicalSide = q$1((side, direction) => {
        var _direction8, _direction9, _direction10;

        (_direction8 = direction) !== null && _direction8 !== void 0 ? _direction8 : direction = getLogicalDirectionInfo();

        if (((_direction9 = direction) === null || _direction9 === void 0 ? void 0 : _direction9.inlineOrientation) === "vertical") {
          switch (side) {
            case "top":
              return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";

            case "bottom":
              return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";

            case "left":
              return direction.blockDirection === "ltr" ? "block-start" : "block-end";

            case "right":
              return direction.blockDirection === "rtl" ? "block-start" : "block-end";
          }
        } else if (((_direction10 = direction) === null || _direction10 === void 0 ? void 0 : _direction10.inlineOrientation) === "horizontal") {
          switch (side) {
            case "top":
              return direction.blockDirection === "ttb" ? "block-start" : "block-end";

            case "bottom":
              return direction.blockDirection === "btt" ? "block-start" : "block-end";

            case "left":
              return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";

            case "right":
              return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
          }
        }
        /* eslint-disable no-debugger */


        debugger;
        console.assert(false);
        return "inline-start";
      }, []);
      const convertToPhysicalOrientation = q$1((elementOrientation, direction) => {
        var _direction11;

        (_direction11 = direction) !== null && _direction11 !== void 0 ? _direction11 : direction = getLogicalDirectionInfo();

        if (elementOrientation == "inline") {
          var _direction12;

          if (((_direction12 = direction) === null || _direction12 === void 0 ? void 0 : _direction12.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction13;

          if (((_direction13 = direction) === null || _direction13 === void 0 ? void 0 : _direction13.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, []);
      const convertElementSize = q$1((elementSize, direction) => {
        var _direction14;

        (_direction14 = direction) !== null && _direction14 !== void 0 ? _direction14 : direction = getLogicalDirectionInfo();

        if (direction) {
          const {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
          const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
          const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
          const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
          const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
          const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
          const f1 = getPhysicalLeftTop(inlineDirection);
          const f2 = getPhysicalRightBottom(inlineDirection);
          const f3 = getPhysicalLeftTop(blockDirection);
          const f4 = getPhysicalRightBottom(blockDirection);
          const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
          const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
          const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]);
          const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
          const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
          const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, []);
      return {
        useLogicalDirectionProps: q$1(props => useRefElementProps(useElementSizeProps(props)), []),
        getElement,
        getLogicalDirectionInfo,
        convertToLogicalSize: convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation,
        convertToLogicalSide,
        convertToPhysicalSide
      };
    } // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)

    function getPhysicalLeftTop(dir) {
      if (dir === "ltr" || dir == "rtl") return "left";
      return "top";
    }

    function getPhysicalRightBottom(dir) {
      if (dir === "rtl") return "width";
      if (dir === "btt") return "height";
      return null;
    } // Helper for extracting info from "ltr", "ttb", etc.


    const M$1 = {
      t: "top",
      b: "bottom",
      l: "left",
      r: "right"
    };
    const HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = { ...HorizontalTbLtr,
      inlineDirection: "rtl"
    };
    const VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };
    const VerticalRlRtl = { ...VerticalRlLtr,
      inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr
    };
    const SidewaysRlRtl = { ...VerticalRlRtl
    };
    const VerticalLrLtr = { ...VerticalRlLtr,
      blockDirection: "ltr"
    };
    const VerticalLrRtl = { ...VerticalRlRtl,
      blockDirection: "ltr"
    };
    const SidewaysLtLtr = { ...VerticalLrLtr,
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = { ...SidewaysLtLtr,
      inlineDirection: "ttb"
    };
    const HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    const VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    const VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    const SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    const WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = A(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      s(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = q$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = q$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        linearNavigation: {
          navigateToFirst: ntf,
          navigateToLast: ntl,
          navigateToNext: ntn,
          navigateToPrev: ntp,
          navigationDirection: nd,
          disableArrowKeys: dak,
          disableHomeEndKeys: dhek
        }
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either";
      const {
        getLogicalDirectionInfo,
        useLogicalDirectionProps
      } = useLogicalDirection({});
      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        linearNavigation: {},
        useLinearNavigationProps: q$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            const info = getLogicalDirectionInfo();
            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            const allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useLogicalDirectionProps(useMergedProps({
            onKeyDown
          }, props));
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        typeaheadNavigation: {
          collator,
          getIndex,
          typeaheadTimeout,
          setIndex,
          noTypeahead
        }
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = A([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = q$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      s(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
               In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
               It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
               Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
               TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = q$1(_ref4 => {
        let {
          index,
          text
        } = _ref4;
        s(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(parentParameters) {
      var _initialIndex;

      let {
        rovingTabIndex: {
          initialIndex,
          onTabbedInTo,
          onTabbedOutOf,
          onTabbableRender,
          onTabbableIndexChange
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      const [_getAnyFocused, setAnyFocused] = usePassiveState(useStableCallback((newCount, oldCount) => {
        if (oldCount == 0 && newCount > 0) {
          onTabbedInTo === null || onTabbedInTo === void 0 ? void 0 : onTabbedInTo();
        }

        if (newCount == 0 && (oldCount !== null && oldCount !== void 0 ? oldCount : 0) > 0) {
          onTabbedOutOf === null || onTabbedOutOf === void 0 ? void 0 : onTabbedOutOf();
        }
      }), returnZero); // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => {
        var _initialIndex2;

        return (_initialIndex2 = initialIndex) !== null && _initialIndex2 !== void 0 ? _initialIndex2 : 0;
      }, []));
      const setTabbableIndex = q$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
            const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
            if (prevChild != null) prevChild.subInfo.blurSelf();
            if (nextChild != null && fromUserInteraction) nextChild.subInfo.focusSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const parentReturnType = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: useStableCallback((mounted, unmounted) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(mounted, unmounted);
            reevaluateClosestFit();
          })
        }
      });
      const {
        useManagedChild
      } = parentReturnType;
      const {
        changeIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        initialIndex,
        children: parentReturnType.managedChildren.children,
        closestFit: true,
        key: "tabbable"
      });
      const useRovingTabIndexChild = q$1(childParameters => {
        const {
          subInfo,
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            hidden,
            blurSelf: blurSelfOverride,
            focusSelf: focusSelfOverride
          }
        } = childParameters;
        s(() => {
          reevaluateClosestFit();
        }, [!!hidden]);
        const bsOverride = useStableGetter(blurSelfOverride);
        const fsOverride = useStableGetter(focusSelfOverride);
        const focusSelf = q$1(() => {
          const fs = fsOverride();

          if (fs) {
            fs();
          } else {
            var _element$focus;

            const element = getElement();
            if (element) (_element$focus = element.focus) === null || _element$focus === void 0 ? void 0 : _element$focus.call(element);
          }
        }, []);
        const blurSelf = q$1(() => {
          const bs = bsOverride();

          if (bs) {
            bs();
          } else {
            var _element$blur;

            const element = getElement();
            if (element) (_element$blur = element.blur) === null || _element$blur === void 0 ? void 0 : _element$blur.call(element);
          }
        }, []);
        const onFocusedInnerChanged = useStableCallback(focused => {
          setAnyFocused(prev => focused ? (prev !== null && prev !== void 0 ? prev : 0) + 1 : (prev !== null && prev !== void 0 ? prev : 0) - 1);

          if (focused) {
            setTabbableIndex(index, true);
          }
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = A({
          get: getTabbable,
          set: setTabbable,
          isValid: useStableCallback(() => !hidden)
        });

        useManagedChild({
          managedChild: {
            index,
            flags: { ...flags,
              tabbable: tabbableFlags.current
            },
            subInfo: {
              blurSelf,
              focusSelf,
              getElement,
              hidden: !!hidden,
              subInfo
            }
          }
        });

        s(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            getElement,
            tabbable,
            getTabbable
          }
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = q$1(() => {
        var _parentReturnType$man, _parentReturnType$man2, _parentReturnType$man3;

        console.log(`useRovingTabIndex.focusSelf`);
        const index = getTabbableIndex();
        if (index != null) (_parentReturnType$man = parentReturnType.managedChildren.children.getAt(index)) === null || _parentReturnType$man === void 0 ? void 0 : (_parentReturnType$man2 = (_parentReturnType$man3 = _parentReturnType$man.subInfo).focusSelf) === null || _parentReturnType$man2 === void 0 ? void 0 : _parentReturnType$man2.call(_parentReturnType$man3);else setTabbableIndex(null, true);
      }, []);
      return {
        useRovingTabIndexChild,
        managedChildren: {
          children: parentReturnType.managedChildren.children
        },
        rovingTabIndex: {
          setTabbableIndex,
          getTabbableIndex,
          focusSelf
        }
      };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */

    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */

    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;
      size = size === undefined ? length : size;

      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];
        array[rand] = array[index];
        array[index] = value;
      }

      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    /** `Object#toString` result references. */

    var argsTag$1 = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */

    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Built-in value references. */

    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */

    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */

    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Built-in value references. */

    var Buffer = moduleExports$1 ? root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */

    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */

    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    /* Node.js helper references. */

    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */

    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */

    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    /** `Object#toString` result references. */

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */

    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */

    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useRearrangeableChildren(_ref) {
      let {
        rearrangeableChildren: {
          getIndex
        }
      } = _ref;
      // These are used to keep track of a mapping between unsorted index <---> sorted index.
      // These are needed for navigation with the arrow keys.
      const mangleMap = A(new Map());
      const demangleMap = A(new Map());
      const indexMangler = q$1(n => {
        var _mangleMap$current$ge;

        return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
      }, []);
      const indexDemangler = q$1(n => {
        var _demangleMap$current$;

        return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
      }, []); // The sort function needs to be able to update whoever has all the sortable children.
      // Because that might not be the consumer of *this* hook directly (e.g. a table uses
      // this hook, but it's tbody that actually needs updating), we need to remotely
      // get and set a forceUpdate function.
      //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);

      const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
      const rearrange = q$1(sortedRows => {
        var _getForceUpdate;

        // Update our sorted <--> unsorted indices map 
        // and rerender the whole table, basically
        for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
          const indexAsUnsorted = sortedRows[indexAsSorted].index;
          mangleMap.current.set(indexAsUnsorted, indexAsSorted);
          demangleMap.current.set(indexAsSorted, indexAsUnsorted);
        }

        (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
      }, []);
      const useRearrangeableProps = q$1(_ref2 => {
        let {
          children,
          ...props
        } = _ref2;
        const forceUpdate = useForceUpdate();
        _(() => {
          setForceUpdate(_prev => forceUpdate);
        }, [forceUpdate]);
        return useMergedProps({
          children: children.slice().map(child => ({
            child,
            mangledIndex: indexMangler(getIndex(child.props)),
            demangledIndex: getIndex(child.props)
          })).sort((lhs, rhs) => {
            return lhs.mangledIndex - rhs.mangledIndex;
          }).map(_ref3 => {
            let {
              child,
              mangledIndex,
              demangledIndex
            } = _ref3;
            return h$1(child.type, { ...child.props,
              key: demangledIndex,
              "data-mangled-index": mangledIndex,
              "data-unmangled-index": demangledIndex
            });
          })
        }, props);
      }, []);
      return {
        useRearrangeableProps,
        rearrangeableChildren: {
          indexMangler,
          indexDemangler,
          mangleMap,
          demangleMap,
          rearrange
        }
      };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useSortableChildren(_ref4) {
      let {
        rearrangeableChildren: {
          getIndex
        },
        sortableChildren: {
          compare: userCompare,
          getValue
        }
      } = _ref4;
      const compare = userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare;
      const {
        useRearrangeableProps: useSortableProps,
        ...rearrangeableChildrenReturnType
      } = useRearrangeableChildren({
        rearrangeableChildren: {
          getIndex
        }
      });
      const {
        rearrangeableChildren: {
          rearrange
        }
      } = rearrangeableChildrenReturnType; // The actual sort function.

      const sort = q$1(function (managedRows, direction) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
          const lhsValue = getValue(lhsRow, ...args);
          const rhsValue = getValue(rhsRow, ...args);
          const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);

          if (direction[0] == "d") return -result;
          return result;
        });
        return rearrange(sortedRows);
      }, [
        /* Must remain stable */
      ]);
      const shuffle$1 = q$1(managedRows => {
        const shuffledRows = shuffle(managedRows.arraySlice());
        return rearrange(shuffledRows);
      }, [
        /* Must remain stable */
      ]);
      return {
        useSortableProps,
        sortableChildren: {
          sort,
          shuffle: shuffle$1
        },
        rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
      };
    }

    function defaultCompare(lhs, rhs) {
      return compare1(lhs, rhs);

      function compare3(lhs, rhs) {
        // Coerce strings to numbers if they seem to stay the same when serialized
        if (`${+lhs}` === lhs) lhs = +lhs;
        if (`${+rhs}` === rhs) rhs = +rhs; // At this point, if either argument is a string, turn the other one into one too

        if (typeof lhs === "string") rhs = `${rhs}`;
        if (typeof rhs === "string") lhs = `${lhs}`;
        console.assert(typeof lhs === typeof rhs);
        if (typeof lhs === "string") return lhs.localeCompare(rhs);
        if (typeof lhs === "number") return +lhs - +rhs;
        return 0;
      }

      function compare2(lhs, rhs) {
        if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
        if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
        return compare3(lhs, rhs);
      }

      function compare1(lhs, rhs) {
        if (lhs == null && rhs == null) {
          // They're both null
          return 0;
        } else if (lhs == null || rhs == null) {
          // One of the two is null -- easy case
          return lhs != null ? 1 : -1;
        }

        return compare2(lhs, rhs);
      }
    }

    function identity(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler;

      let {
        managedChildren: mc,
        rovingTabIndex,
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const parentReturnType = useRovingTabIndex({
        managedChildren: mc,
        rovingTabIndex
      });
      const {
        useRovingTabIndexChild,
        managedChildren: {
          children
        },
        rovingTabIndex: {
          getTabbableIndex,
          setTabbableIndex
        }
      } = parentReturnType;
      const navigateToIndex = q$1((i, fromUserInteraction) => {
        if (i != null) {
          var _indexMangler2, _indexDemangler2;

          const nextIndex = tryNavigateToIndex({
            children: children,
            default: 0,
            target: i,
            searchDirection: 1,
            indexMangler: (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity,
            indexDemangler: (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity
          });
          setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
        } else {
          setTabbableIndex(null, fromUserInteraction);
        }
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      } = useTypeaheadNavigation({
        typeaheadNavigation: {
          getIndex: getTabbableIndex,
          setIndex: q$1(index => {
            setTabbableIndex(index, true);
          }, []),
          ...typeaheadNavigation
        }
      });
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        linearNavigation: {
          navigateToPrev: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler3, _indexDemangler3;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) - 1),
                searchDirection: -1,
                indexMangler: (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity,
                indexDemangler: (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity
              });
            }, true);
          }, []),
          navigateToNext: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler4, _indexDemangler4;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) + 1),
                searchDirection: 1,
                indexMangler: (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity,
                indexDemangler: (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity
              });
            }, true);
          }, []),
          navigateToFirst: q$1(() => {
            navigateToIndex(indexDemangler(0), true);
          }, []),
          navigateToLast: q$1(() => {
            navigateToIndex(indexDemangler(children.getHighestIndex()), true);
          }, []),
          ...linearNavigation
        }
      });
      const useListNavigationProps = q$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = q$1(_ref2 => {
        let {
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          listNavigation: {
            text
          },
          subInfo
        } = _ref2;

        useTypeaheadNavigationChild({
          text,
          index
        });

        const getIndex = useStableGetter(index);
        useEffect(() => {
          return () => {
            if (getTabbableIndex() == getIndex()) {
              navigateToIndex(index, false);
            }
          };
        }, []);
        const {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        } = useRovingTabIndexChild({
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden: !!hidden
          },
          subInfo: {
            text,
            subInfo
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        listNavigation: {
          navigateToIndex
        },
        managedChildren: parentReturnType.managedChildren,
        rovingTabIndex: parentReturnType.rovingTabIndex,
        linearNavigation: {},
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
        /*listNavigation: { navigateToIndex },
        rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
        linearNavigation: {},
        typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/

      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      var _ref5;

      let {
        singleSelection: {
          selectedIndex
        },
        listNavigation,
        managedChildren: {
          /*onChildrenMountChange: ocmc,*/
          ...mc
        },
        rovingTabIndex: {
          initialIndex,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref4;
      const parentReturnType = useListNavigation({
        listNavigation,
        managedChildren: { ...mc
          /*onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => {
              reevaluateClosestFit();
              ocmc?.(mounted, unmounted);
          })*/

        },
        rovingTabIndex: {
          initialIndex: (_ref5 = initialIndex !== null && initialIndex !== void 0 ? initialIndex : selectedIndex) !== null && _ref5 !== void 0 ? _ref5 : undefined,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = parentReturnType;
      const {
        managedChildren: {
          children
        }
      } = listRest;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex //reevaluateClosestFit

      } = useChildrenFlag({
        children: children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      _(() => {
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        useListNavigationSingleSelectionChild: q$1(_ref6 => {
          let {
            managedChild: {
              index,
              flags
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          } = _ref6;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
          const selectedRef = A({
            get: getIsSelected,
            set: setIsSelected,
            isValid: useStableCallback(() => !rti.hidden)
          });
          const {
            rovingTabIndex: rti_ret,
            useListNavigationChildProps
          } = useListNavigationChild({
            managedChild: {
              index,
              flags: {
                selected: selectedRef.current,
                ...flags
              }
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          });
          return {
            useListNavigationSingleSelectionChildProps: useListNavigationChildProps,
            rovingTabIndex: rti_ret,
            singleSelection: {
              selected: isSelected,
              getSelected: getIsSelected
            }
          };
        }, []),
        useListNavigationSingleSelectionProps: q$1(function () {
          return useListNavigationProps(...arguments);
        }, []),
        ...listRest,
        singleSelection: {}
      };
    }
    function tryNavigateToIndex(_ref9) {
      let {
        children,
        searchDirection,
        indexDemangler,
        indexMangler,
        target
      } = _ref9;
      const upper = children.getHighestIndex();
      const lower = 0;

      if (searchDirection === -1) {
        while (target >= lower && children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.subInfo.hidden)) {
          var _children$getAt;

          target = indexDemangler(indexMangler(target) - 1);
        }

        return target < lower ? indexDemangler(lower) : target;
      } else if (searchDirection === 1) {
        while (target <= upper && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.subInfo.hidden)) {
          var _children$getAt2;

          target = indexDemangler(indexMangler(target) + 1);
        }

        return target > upper ? indexDemangler(upper) : target;
      } else {
        return lower;
      }
    }

    function useGridNavigation(_ref) {
      var _rti$initialIndex;

      let {
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: ln,
        typeaheadNavigation: tn
      } = _ref;
      const [currentColumn, setCurrentColumn, getCurrentColumn] = useState((_rti$initialIndex = rti.initialIndex) !== null && _rti$initialIndex !== void 0 ? _rti$initialIndex : 0);
      const {
        useListNavigationChild: useListNavigationChildAsGridRow,
        useListNavigationProps: useListNavigationPropsAsGridParent,
        ...parentLsReturnType
      } = useListNavigation({
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: {
          navigationDirection: "block",
          ...ln
        },
        typeaheadNavigation: tn
      });
      const useGridNavigationRow = q$1(_ref2 => {
        let {
          asChildRowOfSection: asChild,
          asParentRowOfCells: asParent
        } = _ref2;
        // Override the focusSelf that rovingTabIndex does.
        // Instead of focusing the entire row, we ask the cell that corresponds
        // to our current column to focus itself.
        const focusSelf = useStableCallback(() => {
          const c2 = getCurrentColumn();

          if (asChild.rovingTabIndex.focusSelf) {
            asChild.rovingTabIndex.focusSelf();
          } else {
            navigateToIndex(c2 !== null && c2 !== void 0 ? c2 : 0, true);
          }
        });
        const rowLsChildReturnType = useListNavigationChildAsGridRow({
          managedChild: asChild.managedChild,
          listNavigation: { ...asChild.listNavigation
          },
          rovingTabIndex: { ...asChild.rovingTabIndex,
            focusSelf
          },
          subInfo: asChild.subInfo
        });
        const {
          rovingTabIndex: {
            tabbable
          },
          useListNavigationChildProps
        } = rowLsChildReturnType;
        s(() => {
          if (!tabbable) {
            navigateToIndex(null, false);
          }
        }, [tabbable]);
        const rowLsReturnType = useListNavigation({
          managedChildren: { ...asParent.managedChildren
          },
          rovingTabIndex: { ...asParent.rovingTabIndex
          },
          linearNavigation: { ...asParent.linearNavigation,
            navigationDirection: "inline"
          },
          typeaheadNavigation: { ...asParent.typeaheadNavigation,
            noTypeahead: true
          },
          listNavigation: { ...asParent.listNavigation
          }
        });
        const {
          rovingTabIndex: {
            setTabbableIndex
          },
          useListNavigationChild: useGridNavigationColumn2,
          useListNavigationProps: useGridNavigationColumnProps,
          listNavigation: {
            navigateToIndex
          }
        } = rowLsReturnType; //const rowHidden = !!asChild.rovingTabIndex.hidden;

        const useGridNavigationCell = q$1(_ref3 => {
          let {
            subInfo,
            managedChild,
            listNavigation: ls,
            rovingTabIndex: {
              blurSelf: bs,
              focusSelf: fs,
              ...rti
            }
          } = _ref3;
          //rti.hidden || rowHidden;
          const focusSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem, _rti_cell_ret$getElem2;

            setCurrentColumn(managedChild.index);
            setTabbableIndex(managedChild.index, false);
            if (fs) fs();else (_rti_cell_ret$getElem = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem === void 0 ? void 0 : (_rti_cell_ret$getElem2 = _rti_cell_ret$getElem.focus) === null || _rti_cell_ret$getElem2 === void 0 ? void 0 : _rti_cell_ret$getElem2.call(_rti_cell_ret$getElem);
          });
          const blurSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem3, _rti_cell_ret$getElem4;

            if (bs) bs();else (_rti_cell_ret$getElem3 = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem3 === void 0 ? void 0 : (_rti_cell_ret$getElem4 = _rti_cell_ret$getElem3.blur) === null || _rti_cell_ret$getElem4 === void 0 ? void 0 : _rti_cell_ret$getElem4.call(_rti_cell_ret$getElem3);
          });
          const {
            useListNavigationChildProps,
            rovingTabIndex: rti_cell_ret
          } = useGridNavigationColumn2({
            managedChild: managedChild,
            listNavigation: { ...ls
            },
            rovingTabIndex: {
              blurSelf,
              focusSelf,
              ...rti
            },
            subInfo
          });
          const {
            useHasFocusProps
          } = useHasFocus({
            onLastFocusedInnerChanged: useStableCallback(focused => {
              if (focused) {
                setCurrentColumn(managedChild.index);
                setTabbableIndex(managedChild.index, false);
              }
            })
          });
          const ret = {
            gridNavigation: {
              getCurrentColumn
            },
            rovingTabIndex: rti_cell_ret,
            useGridNavigationCellProps: function (props) {
              return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props)));
            }
          };
          return ret;
        }, []);
        const ret = {
          asParentOfCells: {
            linearNavigation: rowLsReturnType.linearNavigation,
            listNavigation: rowLsReturnType.listNavigation,
            managedChildren: rowLsReturnType.managedChildren,
            rovingTabIndex: rowLsReturnType.rovingTabIndex,
            typeaheadNavigation: rowLsReturnType.typeaheadNavigation
          },
          asChildRow: rowLsChildReturnType,
          useGridNavigationCell,
          useGridNavigationRowProps: function (props) {
            const ret = useListNavigationChildProps(props);
            ret.tabIndex = -1;
            return ret;
          }
        };
        return ret;
      }, []);
      return {
        gridNavigation: {
          getCurrentColumn,
          currentColumn
        },
        linearNavigation: parentLsReturnType.linearNavigation,
        listNavigation: parentLsReturnType.listNavigation,
        rovingTabIndex: parentLsReturnType.rovingTabIndex,
        typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
        managedChildren: parentLsReturnType.managedChildren,
        useGridNavigationRow,
        useGridNavigationProps: useListNavigationPropsAsGridParent
      };
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        randomId: {
          prefix
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = A(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        ...managedChildrenReturnType
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const {
        managedChildren: {
          children
        }
      } = managedChildrenReturnType;
      const useRandomIdSourceElement = q$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        s(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").subInfo.setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          managedChild: {
            index: "source",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdSourceElementProps = q$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = q$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          managedChild: {
            index: "referencer",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdReferencerElementProps = q$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        randomId: {
          usedId,
          getUsedId
        },
        ...managedChildrenReturnType,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    let pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */


    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }
    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * buttons and anything else that's "click/tap/press/touch"-able.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */


    function usePressEventHandlers(onClickSync, exclude) {
      const {
        useRefElementProps,
        getElement
      } = useRefElement({}); // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element loses focus,
      // this is reset back to 0.

      const [active, setActive, getActive] = useState(0); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      useEffect(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
        const charactersSelected = nodeSelectedTextLength(getElement()); // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          pulse(); // Actually call our handler.

          onClickSync(e);
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };

      const onBlur = _ => {
        setActive(0);
      };

      const onMouseLeave = excludes("click", exclude) ? undefined : onBlur;
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return useRefElementProps({
        onKeyDown,
        onKeyUp,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseLeave,
        onClick,
        style: textSelectedDuringActivationStartTime != null ? {
          cursor: "text"
        } : undefined,
        ...{
          "data-pseudo-active": active && textSelectedDuringActivationStartTime == null ? "true" : undefined
        }
      });
    }
    function useAriaButton(_ref) {
      let {
        tag,
        pressed,
        onPress,
        disabled
      } = _ref;
      debugLog("useAriaButton");

      function useAriaButtonProps(_ref2) {
        let {
          "aria-pressed": ariaPressed,
          tabIndex,
          role,
          ...p
        } = _ref2;
        const props = useMergedProps(usePressEventHandlers(e => {
          var _ref3;

          return (_ref3 = disabled ? null : onPress) === null || _ref3 === void 0 ? void 0 : _ref3(enhanceEvent(e, {
            pressed: pressed == null ? null : !pressed
          }));
        }, undefined), p);
        const baseProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };
        const buttonProps = { ...baseProps,
          disabled: disabled && disabled != "soft" ? true : false,
          "aria-disabled": disabled === 'soft' ? 'true' : undefined
        };
        const divProps = { ...baseProps,
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled === "hard" ? -1 : 0,
          role: role !== null && role !== void 0 ? role : "button",
          "aria-disabled": disabled ? "true" : undefined
        };

        switch (tag) {
          case "button":
            return useMergedProps(buttonProps, props);

          default:
            return useMergedProps(divProps, props);
        }
      }

      return {
        useAriaButtonProps
      };
    }

    //export interface UseAriaAccordionSectionHeaderReturnType<E extends Element> { useAriaAccordionSectionHeaderProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }
    //export type UseAriaAccordionSectionBody<E extends Element> = () => UseAriaAccordionSectionBodyReturnType<E>;
    //export interface UseAriaAccordionSectionBodyReturnType<E extends Element> { useAriaAccordionSectionBodyProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }

    function useAriaAccordion(_ref) {
      let {
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      debugLog("useAriaAccordian");
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const mcReturnType = useManagedChildren({
        managedChildren: {
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc2();
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }),
          onAfterChildLayoutEffect
        }
      });
      const {
        useManagedChild,
        managedChildren: {
          children
        }
      } = mcReturnType;
      const navigateToFirst = q$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = q$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const linearReturnType = useLinearNavigation({
        linearNavigation: {
          navigateToFirst,
          navigateToLast,
          navigateToNext,
          navigateToPrev,
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection: navigationDirection !== null && navigationDirection !== void 0 ? navigationDirection : "block"
        }
      });
      const {
        useLinearNavigationProps
      } = linearReturnType;
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: _getCurrentExpandedIndex
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: _getTabbedIndex,
        reevaluateClosestFit: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: true,
        onIndexChange: q$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focus();
          }
        }, [])
      });
      const useAriaAccordionSection = q$1(_ref2 => {
        var _ref3;

        let {
          button: {
            tag,
            disabled
          },
          accordionSection: {
            open: openFromUser
          },
          managedChildren: {
            index
          }
        } = _ref2;
        debugLog("useAriaAccordianSection");
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId,
          randomId: {
            usedId: bodyId,
            getUsedId: getBodyId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-body-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId,
          randomId: {
            usedId: headerId,
            getUsedId: getHeaderId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-header-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index);
        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = q$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = A({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              setCurrentFocusedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = A({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChild({
          managedChild: {
            index: index,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            },
            subInfo: {
              focus,
              getOpenFromParent,
              setOpenFromParent
            } // info: { index, setOpenFromParent, getOpenFromParent, focus, flags: { open: openRef.current, tabbed: tabbedRef.current } }

          }
        });

        function useAriaAccordionSectionHeaderProps(_ref4) {
          var _ref5;

          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          //const onFocus = () => { changeTabbedIndex(index); }
          const onPress = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
          };

          props.tabIndex = 0;
          const {
            useAriaButtonProps
          } = useAriaButton({
            tag,
            disabled,
            onPress
          });
          const retB = useAriaButtonProps(props); //const retB = useMergedProps<HeaderElement>(usePressEventHandlers<HeaderElement>(onClick, undefined), props);

          const {
            useHasFocusProps
          } = useHasFocus({
            onFocusedInnerChanged: useStableCallback(focused => {
              if (focused) changeTabbedIndex(index);
            })
          }); //const ret3: h.JSX.HTMLAttributes<HeaderElement>
          //    = useMergedProps<HeaderElement>(retD, { onFocus });

          return useHasFocusProps(useLinearNavigationProps(useHeaderAsSourceIdProps(useHeaderAsReferencerIdProps({
            "aria-expanded": ((_ref5 = ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open) !== null && _ref5 !== void 0 ? _ref5 : false).toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          }))));
        }

        function useAriaAccordionSectionBodyProps(_ref6) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref6;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          accordionSection: {
            expanded: open,
            focused: getCurrentFocusedIndex() == index,
            bodyId,
            headerId,
            getBodyId,
            getHeaderId
          },
          useAriaAccordionSectionHeaderProps,
          useAriaAccordionSectionBodyProps
        };
      }, []);
      return {
        managedChildren: mcReturnType.managedChildren,
        accordion: {
          changeExpandedIndex
        },
        useAriaAccordionSection
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel(_ref) {
      let {
        label: {
          prefixInput,
          prefixLabel,
          tagInput,
          tagLabel
        }
      } = _ref;
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        randomId: {
          usedId: labelId,
          getUsedId: getLabelId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixLabel
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        randomId: {
          usedId: inputId,
          getUsedId: getInputId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixInput
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      const isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = q$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            const propsWithoutFor = useLabelAsSourceIdProps(props);
            const propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = q$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref2 => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref2;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel && !props["aria-label"]) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, [isSyntheticLabel]);
      return {
        useLabelInput,
        useLabelLabel,
        label: {
          labelId,
          inputId,
          getLabelId,
          getInputId
        }
      };
    }

    const handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     *
     * If it's a toggleable click-thing with a label (that can also be clicked), then it's a checkbox-like.
     * @param param0
     * @returns
     */


    function useCheckboxLike(_ref3) {
      let {
        checkboxLike: {
          checked,
          disabled,
          labelPosition,
          role,
          onInput
        },
        label: {
          tagInput,
          tagLabel
        }
      } = _ref3;
      const stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onInput === null || onInput === void 0 ? void 0 : onInput(e);
      });
      const {
        useLabelInput: useILInput,
        useLabelLabel: useILLabel,
        label
      } = useLabel({
        label: {
          prefixLabel: "aria-checkbox-label-",
          prefixInput: "aria-checkbox-input-",
          tagInput: tagInput,
          tagLabel: tagLabel
        }
      });
      const {
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      const {
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      const useCheckboxLikeInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useLabelInputProps: useILInputProps
        } = useILInput();
        const {
          useRefElementProps,
          getElement
        } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        s(() => {
          const element = getElement();

          if (element && tag == "input") {
            element.indeterminate = checked === "mixed";
            element.checked = checked === true;
          }
        }, [tag, checked]);
        return {
          getInputElement: getElement,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref4) {
          let { ...p0
          } = _ref4;
          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          let props = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined);
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;
            props.role = "presentation";
            props["aria-hidden"] = "true";

            props.onFocus = _ => {
              var _getLabelElement;

              return (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : _getLabelElement.focus();
            };
          } else {
            if (tag === "input") {
              props.checked = checked === true;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked === "mixed" ? "mixed" : checked === true ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useInputRefElementProps(useMergedProps(p0, props));
        }
      }, [useILInput, role, labelPosition, disabled, checked, tagInput]);
      const useCheckboxLikeLabelElement = q$1(function useCheckboxLabelElement() {
        const tag = tagLabel;
        const {
          useLabelLabelProps: useILLabelProps
        } = useILLabel();

        function useCheckboxLikeLabelElementProps(_ref5) {
          let { ...p0
          } = _ref5;
          const newProps = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined);

          if (labelPosition == "wrapping") {
            if (p0.tabIndex == null) newProps.tabIndex = 0;
            if (p0.role == null) newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useLabelRefElementProps(useMergedProps(newProps, useILLabelProps(p0)));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition, tagLabel]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        checkboxLike: {
          getLabelElement,
          getInputElement
        },
        label
      };
    }

    function useAriaCheckbox(_ref) {
      let {
        checkboxLike,
        label,
        checkbox
      } = _ref;
      debugLog("useAriaCheckbox");
      const {
        disabled,
        labelPosition,
        checked
      } = checkboxLike;
      const {
        tagInput,
        tagLabel
      } = label;
      const {
        onInput
      } = checkbox;

      const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      const {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        ...checkboxLikeRest
      } = useCheckboxLike({
        checkboxLike: {
          role: "checkbox",
          checked,
          onInput: onInputEnhanced,
          disabled,
          labelPosition
        },
        label
      });
      const useCheckboxInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement();
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref2) {
          var _props$checked;

          let { ...p0
          } = _ref2;
          const props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [useCheckboxLikeInputElement, checked, labelPosition, disabled, tagInput]);
      const useCheckboxLabelElement = q$1(function useCheckboxLabelElement() {
        const {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement();

        function useCheckboxLabelElementProps(_ref3) {
          let { ...props
          } = _ref3;
          return useCheckboxLikeLabelElementProps(props);
        }

        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition, tagLabel]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxLikeRest
      };
    }

    /**
     *
     *
     * @param param0
     * @returns
     */

    function useCheckboxGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useAriaCheckboxGroup"); //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));

      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listReturnType
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType; //const [uncheckedCount, setUnheckedCount] = useState(0);
      // Keep track of all child IDs, and any time any of them change, 
      // generate a new string with all of them concatenated together
      // (but only once per render);

      const allIds = A(new Set());
      const [ariaControls, setAriaControls] = useState("");
      const [updateIndex, setIdUpdateIndex] = useState(0);
      const [checkedCount, setCheckedCount] = useState(0);
      const checkedIndices = A(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

      const getSelfIsCheckedUnstable = q$1(() => {
        const percentage = checkedCount / (children.getHighestIndex() + 1);
        return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
      }, [checkedCount]);
      const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable);
      const [setParentCheckboxChecked, setSetParentCheckboxChecked] = useState(null);
      useEffect(() => {
        setParentCheckboxChecked === null || setParentCheckboxChecked === void 0 ? void 0 : setParentCheckboxChecked(checkedCount == 0 ? false : checkedCount == children.getHighestIndex() + 1 ? true : "mixed");
      }, [setParentCheckboxChecked, checkedCount]); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
      // Otherwise, it's null when the last input was from a child checkbox. 
      //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);

      const useCheckboxGroupParentInput = q$1(_ref2 => {
        let {
          checkbox,
          checkboxLike,
          label
        } = _ref2;
        debugLog("useAriaCheckboxGroupParent");
        const {
          disabled,
          labelPosition
        } = checkboxLike;
        const {
          tagInput,
          tagLabel
        } = label;
        const [checked, setChecked] = useState(false);
        useEffect(() => {
          setSetParentCheckboxChecked(() => setChecked);
        }, []);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement
        } = useAriaCheckbox({
          checkboxLike: {
            labelPosition,
            checked,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          checkbox: {
            onInput: onCheckboxGroupParentInput2
          }
        });
        const {
          useCheckboxInputElementProps
        } = useCheckboxInputElement();
        const {
          useCheckboxLabelElementProps
        } = useCheckboxLabelElement();
        return {
          useCheckboxGroupParentInputProps: function useCheckboxGroupParentInputProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls,
              onInput: tagInput == "input" ? e => e.preventDefault() : undefined
            }), props);
            return useCheckboxInputElementProps(labelPosition == "separate" ? ret : props);
          },
          useCheckboxGroupParentLabelProps: function useCheckboxGroupParentLabelProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls
            }), props);
            return useCheckboxLabelElementProps(labelPosition == "wrapping" ? ret : props);
          }
        };
      }, [ariaControls]);
      const onCheckboxGroupParentInput2 = q$1(e => {
        e.preventDefault();
        const selfIsChecked = getSelfIsCheckedStable();
        const nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        let willChangeAny = false;
        children.forEach(child => willChangeAny || (willChangeAny = child.subInfo.subInfo.subInfo.checked != child.subInfo.subInfo.subInfo.getLastUserChecked()));
        children.forEach(child => {
          var _child$subInfo$subInf, _child$subInfo$subInf2;

          let checked;

          if (nextChecked == "mixed") {
            if (willChangeAny) checked = child.subInfo.subInfo.subInfo.getLastUserChecked();else checked = true;
          } else {
            checked = nextChecked;
          }

          (_child$subInfo$subInf = (_child$subInfo$subInf2 = child.subInfo.subInfo.subInfo).onInput) === null || _child$subInfo$subInf === void 0 ? void 0 : _child$subInfo$subInf.call(_child$subInfo$subInf2, enhanceEvent(e, {
            checked
          }));
        });
        /*if (selfIsChecked === true || (selfIsChecked === false && savedCheckedValues.current == null)) {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: false }));
        }
        else if (selfIsChecked === "mixed") {
             savedCheckedValues.current = new Map();
            children.forEach(child => {
                savedCheckedValues.current!.set(child.index, child.getLastUserChecked());
            })
             return onUpdateChildren(enhanceEvent(e, { childrenChecked: true }));
        }
        else {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: savedCheckedValues.current ?? true }));
        }*/
      }, []);
      const notifyChecked = q$1((index, checked) => {
        if (checked === true) {
          if (!checkedIndices.current.has(index)) {
            setCheckedCount(c => c + 1);
            checkedIndices.current.add(index);
          }
        } else {
          if (checkedIndices.current.has(index)) {
            setCheckedCount(c => c - 1);
            checkedIndices.current.delete(index);
          }
        }
      }, []);
      /*useEffect(() => {
          let percentage = checkedCount / managedChildren.length;
          setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
      }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

      /*const useCheckboxGroupParentProps = useCallback((props: h.JSX.HTMLAttributes<InputElement>) => {
          return
      }, [ariaControls]);*/

      useEffect(() => {
        setAriaControls(Array.from(allIds.current).join(" "));
      }, [updateIndex]);
      const useCheckboxGroupChild = q$1(function (_ref3) {
        let {
          asCheckbox,
          asCheckboxGroupChild
        } = _ref3;
        debugLog("useAriaCheckboxGroupChild", asCheckboxGroupChild.managedChild.index, asCheckbox.checkboxLike.checked);
        const {
          checkbox: {
            onInput
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          }
        } = asCheckbox;
        const {
          managedChild: {
            index
          }
        } = asCheckboxGroupChild; //labelPosition ??= "separate";

        const [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse$1);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement,
          ...checkboxReturnType
        } = useAriaCheckbox({
          checkbox: {
            onInput: useStableCallback(e => {
              setLastUserChecked(e[EventDetail].checked);
              onInput === null || onInput === void 0 ? void 0 : onInput(e);
            })
          },
          checkboxLike: {
            checked,
            labelPosition,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          }
        });
        const {
          label: {
            inputId,
            labelId
          }
        } = checkboxReturnType; //const getChecked = useStableGetter(checked);

        const controlsId = labelPosition == "separate" ? inputId : labelId;
        useEffect(() => {
          allIds.current.add(controlsId);
          setIdUpdateIndex(i => ++i);
          return () => {
            allIds.current.delete(controlsId);
            setIdUpdateIndex(i => ++i);
          };
        }, [controlsId]);
        useEffect(() => {
          notifyChecked(index, checked);
        }, [index, checked]);
        const {
          useListNavigationChildProps,
          ...listNavigationReturnType
        } = useListNavigationChild({
          subInfo: {
            getLastUserChecked,
            onInput,
            checked
          },
          listNavigation: { ...asCheckboxGroupChild.listNavigation
          },
          managedChild: asCheckboxGroupChild.managedChild,
          rovingTabIndex: asCheckboxGroupChild.rovingTabIndex
        });
        return {
          checkboxLike: checkboxReturnType.checkboxLike,
          label: checkboxReturnType.label,
          rovingTabIndex: listNavigationReturnType.rovingTabIndex,
          useCheckboxGroupChildInputProps: props => {
            const {
              useCheckboxInputElementProps
            } = useCheckboxInputElement();
            const ret = useCheckboxInputElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "separate" ? ret2 : ret;
          },
          useCheckboxGroupChildLabelProps: props => {
            const {
              useCheckboxLabelElementProps
            } = useCheckboxLabelElement();
            const ret = useCheckboxLabelElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "wrapping" ? ret2 : ret;
          }
        };
      }, []);
      return {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable(),
          parentPercentChecked: checkedCount / (children.getHighestIndex() + 1)
        }
      };
    }

    function useAriaListboxSingle(_ref) {
      let {
        listboxSingle: {
          selectionMode,
          tagLabel,
          tagList,
          onSelect,
          ..._lbs
        },
        singleSelection: {
          selectedIndex,
          ...ss
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      debugLog("useAriaListboxSingle", selectedIndex);
      const {
        useLabelInput,
        useLabelLabel,
        ...labelReturnType
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagInput: tagList,
          tagLabel: tagLabel
        }
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listReturnType
      } = useListNavigationSingleSelection({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);

            if (selectionMode == "focus") {
              var _children$getAt;

              const target = (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.getElement();
              if (target) onSelect === null || onSelect === void 0 ? void 0 : onSelect({
                target,
                currentTarget: target,
                [EventDetail]: {
                  selectedIndex: i
                }
              });
            }
          })
        },
        singleSelection: { ...ss,
          selectedIndex
        },
        typeaheadNavigation: tn
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = q$1(_ref2 => {
        let {
          listboxSingleItem: {
            disabled
          },
          listNavigation,
          managedChild,
          rovingTabIndex
        } = _ref2;
        debugLog("useAriaListboxSingleItem", managedChild.index);
        const {
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret,
          useListNavigationSingleSelectionChildProps
        } = useListNavigationSingleSelectionChild({
          managedChild,
          listNavigation,
          rovingTabIndex,
          subInfo: {}
        });
        const index = managedChild.index;
        s(() => {
          const element = rti_ret.getElement();

          if (element && rti_ret.tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [rti_ret.tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret
        };

        function useListboxSingleItemProps(props) {
          var _ss_ret$selected;

          const newProps = usePressEventHandlers(disabled ? null : e => {
            const element = rti_ret.getElement();
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined);
          props.role = "option"; //props["aria-setsize"] = (children.getHighestIndex() + 1).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_ss_ret$selected = ss_ret.selected) !== null && _ss_ret$selected !== void 0 ? _ss_ret$selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationSingleSelectionChildProps(useMergedProps(newProps, props));
        }
      }, [useListNavigationSingleSelectionChild, selectionMode]);
      const useListboxSingleLabel = q$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        ...listReturnType,
        ...labelReturnType
        /*label: labelReturnType.label,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation*/

      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }

    /*export interface UseListboxMultiReturnType<LabelElement extends Element, ListElement extends Element, ListItemElement extends Element> extends Omit<UseListNavigationReturnType<ListElement, ListItemElement, {}, never>, "useListNavigationChild" | "useListNavigationProps"> {
        useListboxMultiItem: UseListboxMultiItem<ListItemElement>;
        useListboxMultiProps: (props: h.JSX.HTMLAttributes<ListElement>) => h.JSX.HTMLAttributes<ListElement>;
        useListboxMultiLabel: () => { useListboxMultiLabelProps: (props: h.JSX.HTMLAttributes<LabelElement>) => h.JSX.HTMLAttributes<LabelElement>; }
    }*/

    function useAriaListboxMulti(_ref) {
      let {
        listboxMulti: {
          tagLabel,
          tagList
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      debugLog("useAriaListboxMulti"); //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagLabel: tagLabel,
          tagInput: tagList
        }
      });
      const listReturnType = useListNavigation({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);
            /*if (selectionMode == "focus") {
                const target = (children.getAt(i!)?.subInfo.getElement());
                if (target)
                    onSelect?.({ target, currentTarget: target, [EventDetail]: { selectedIndex: i! } });
            }*/
          })
        },
        typeaheadNavigation: tn
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const [getShiftHeld, setShiftHeld] = usePassiveState(null, returnFalse$1);
      const useListboxMultiItem = q$1(_ref2 => {
        let {
          listboxMultiItem: {
            selected,
            disabled,
            onSelect
          },
          managedChild,
          listNavigation: ls,
          rovingTabIndex: rti
        } = _ref2;
        debugLog("useAriaListboxMultiItem", managedChild.index, selected);
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
        const {
          useListNavigationChildProps,
          rovingTabIndex: rti2_ret
        } = useListNavigationChild({
          listNavigation: ls,
          managedChild,
          rovingTabIndex: rti,
          subInfo: {
            selected,
            onSelect
          }
        });
        useLayoutEffect(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [rti2_ret.tabbable]);
        return {
          useListboxMultiItemProps,
          listboxMultiItem: {
            getSelected,
            tabbable: rti2_ret.tabbable
          },
          rovingTabIndex: rti2_ret
        };

        function useListboxMultiItemProps(props) {
          var _rti2_ret$tabbable;

          const newProps = usePressEventHandlers(disabled ? null : e => {
            console.log(`Multi ${managedChild.index} is ${getSelected().toString()} and changing to ${(!getSelected()).toString()}`);
            setTabbableIndex(managedChild.index, false);
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
              [EventDetail]: {
                selected: !getSelected()
              }
            });
            e.preventDefault();
          }, {});
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_rti2_ret$tabbable = rti2_ret.tabbable) !== null && _rti2_ret$tabbable !== void 0 ? _rti2_ret$tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(useMergedProps(newProps, props)));
        }
      }, [useListNavigationChild]);
      const useListboxMultiLabel = q$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        managedChildren: listReturnType.managedChildren
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    function returnFalse() {
      return false;
    }

    function useAriaTooltip(_ref) {
      var _mouseoverDelay, _mouseoutDelay, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutDelay,
        focusDelay
      } = _ref;
      debugLog("useAriaTooltip");
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutDelay = mouseoutDelay) !== null && _mouseoutDelay !== void 0 ? _mouseoutDelay : mouseoutDelay = 40;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setTriggerHoverDelayCorrected(false);
          setTooltipHoverDelayCorrected(false);
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        randomId: {
          prefix: "aria-tooltip-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTriggerHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
      const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
      s(() => {
        setOpen(triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected);
      }, [triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected]);
      const useTooltipTrigger = q$1(function useTooltipTrigger() {
        debugLog("useAriaTooltipTrigger");
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: setTriggerFocused
        });

        function useTooltipTriggerProps(_ref2) {
          var _props$tabIndex;

          let { ...props
          } = _ref2;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltip = q$1(function useTooltip() {
        debugLog("useAriaTooltipTooltip");
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: setTooltipFocused
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipProps(_ref3) {
          let { ...props
          } = _ref3;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipProps
        };
      }, []);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function useAriaTable(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useAriaTable");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null);
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useTableRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          tableRow: {
            location
          }
        } = _ref2;
        debugLog("useAriaTableRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              location
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useTableCell = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo
          } = _ref3;
          debugLog("useAriaTableCell", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo
          });
          const sort = useStableCallback(() => {
            var _getCurrentSortColumn;

            const sortInfo = (_getCurrentSortColumn = getCurrentSortColumn()) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : {
              index: -1,
              direction: 'ascending'
            };
            const cellIndex = managedChild.index;

            if (sortInfo.index != cellIndex) {
              if (sortInfo.direction[0] == 'a') sortInfo.direction = 'descending';else sortInfo.direction = 'ascending';
            }

            sortInfo.index = managedChild.index;
            setCurrentSortColumn(sortInfo);
            bodySort.current();
          });

          const useTableCellProps = props => props;

          return {
            tableHeaderCell: {
              sort
            },
            useTableCellProps,
            ...gridNavRet3
          };
        }, []);

        const useTableRowProps = props => props;

        return {
          useTableCell,
          useTableRowProps,
          ...gridNavRet2
        };
      }, []);
      const useTableBody = q$1(() => {
        debugLog("useAriaTableBody");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn2, _getCurrentSortColumn3, _cell$subInfo$subInfo, _cell$subInfo$subInfo2;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn2 = (_getCurrentSortColumn3 = getCurrentSortColumn()) === null || _getCurrentSortColumn3 === void 0 ? void 0 : _getCurrentSortColumn3.index) !== null && _getCurrentSortColumn2 !== void 0 ? _getCurrentSortColumn2 : 0);
          return {
            location: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.location) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : "head",
            value: (_cell$subInfo$subInfo2 = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.value) !== null && _cell$subInfo$subInfo2 !== void 0 ? _cell$subInfo$subInfo2 : -1
          }; //return cells.getAt(getCurrentSortColumn()?.index ?? 0)?.subInfo.subInfo.subInfo.value ?? null;
        }, []);

        const compare = (lhs, rhs) => {
          var _lhs$value, _rhs$value;

          if (lhs.location === rhs.location) return +((_lhs$value = lhs.value) !== null && _lhs$value !== void 0 ? _lhs$value : -Infinity) - +((_rhs$value = rhs.value) !== null && _rhs$value !== void 0 ? _rhs$value : -Infinity);
          if (lhs.location == 'head') return -1;
          if (lhs.location == 'body') return rhs.location == 'head' ? -1 : 1;
          return 1;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          }
        } = sortableRet;
        useLayoutEffect(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn4, _getCurrentSortColumn5;

            sort(rows, (_getCurrentSortColumn4 = (_getCurrentSortColumn5 = getCurrentSortColumn()) === null || _getCurrentSortColumn5 === void 0 ? void 0 : _getCurrentSortColumn5.direction) !== null && _getCurrentSortColumn4 !== void 0 ? _getCurrentSortColumn4 : 'ascending');
          };
        }, [sort]);

        const useTableBodyProps = props => {
          console.assert(props.children != null);
          return useSortableProps(props);
        };

        return {
          useTableBodyProps,
          ...sortableRet
        };
      }, []);
      const useTableProps = useGridNavigationProps;
      return {
        useTableProps,
        useTableBody,
        useTableRow,
        ...gridNavRet1
      };
    }

    function g(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function C(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    (E.prototype = new d$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var R = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
    };

    var x = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function N(n) {
      function t(t) {
        var e = g({}, t);
        return delete e.ref, n(e, t.ref || null);
      }

      return t.$$typeof = x, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var O = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      O(n, t, e, r);
    };

    var T = l$1.unmount;

    function I(n, t, e) {
      return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
        "function" == typeof n.__c && n.__c();
      }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
        return I(n, t, e);
      })), n;
    }

    function L(n, t, e) {
      return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
        return L(n, t, e);
      }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
    }

    function U() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function D(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), T && T(n);
    }, (U.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = D(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = L(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, U.prototype.componentWillUnmount = function () {
      this.t = [];
    }, U.prototype.render = function (n, e) {
      if (this.__b) {
        if (this.__v.__k) {
          var r = document.createElement("div"),
              o = this.__v.__k[0].__c;
          this.__v.__k[0] = I(this.__b, r, o.__O = o.__P);
        }

        this.__b = null;
      }

      var i = e.__a && h$1(p$1, null, n.fallback);
      return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
    };

    var V = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    (M.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = D(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), V(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x$2(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        V(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        B = "undefined" != typeof document,
        H = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
      Object.defineProperty(d$1.prototype, t, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + t];
        },
        set: function (n) {
          Object.defineProperty(this, t, {
            configurable: !0,
            writable: !0,
            value: n
          });
        }
      });
    });
    var q = l$1.event;

    function G() {}

    function J() {
      return this.cancelBubble;
    }

    function K() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return q && (n = q(n)), n.persist = G, n.isPropagationStopped = J, n.isDefaultPrevented = K, n.nativeEvent = n;
    };

    var X = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        nn = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          u = e;

      if ("string" == typeof t) {
        var o = -1 === t.indexOf("-");

        for (var i in u = {}, e) {
          var l = e[i];
          B && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !H(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && z.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
        }

        "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$2(e.children).forEach(function (n) {
          n.props.selected = -1 != u.value.indexOf(n.props.value);
        })), "select" == t && null != u.defaultValue && (u.value = x$2(e.children).forEach(function (n) {
          n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
        })), n.props = u, e.class != e.className && (X.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", X));
      }

      n.$$typeof = j, nn && nn(n);
    };

    var tn = l$1.__r;

    l$1.__r = function (n) {
      tn && tn(n), n.__c;
    };

    const AccordionSectionContext = B$2(null);
    function AriaAccordion(_ref) {
      let {
        disableArrowKeys,
        disableHomeEndKeys,
        expandedIndex,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render,
        children
      } = _ref;
      const {
        useAriaAccordionSection,
        ...provider
      } = useAriaAccordion({
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      useEffect(() => {
        provider.accordion.changeExpandedIndex(expandedIndex !== null && expandedIndex !== void 0 ? expandedIndex : null);
      }, [expandedIndex]);
      return o$1(AccordionSectionContext.Provider, {
        value: useAriaAccordionSection,
        children: (render !== null && render !== void 0 ? render : defaultRenderAccordion)(provider, children)
      });
    }

    function defaultRenderAccordion(info, children) {
      return o$1(p$1, {
        children: children
      });
    }

    function defaultRenderSection(info, headingProps, bodyProps) {
      return o$1(p$1, {
        children: o$1(Heading, {
          heading: o$1("div", { ...headingProps
          }),
          children: o$1("div", { ...bodyProps
          })
        })
      });
    }

    function AriaAccordionSectionU(_ref2, ref) {
      let {
        open,
        index,
        tag,
        disabled,
        render,
        ...unknownProps
      } = _ref2;
      const useAriaAccordionSection = x$1(AccordionSectionContext);
      const {
        useAriaAccordionSectionBodyProps,
        useAriaAccordionSectionHeaderProps,
        ...sectionInfo
      } = useAriaAccordionSection({
        button: {
          tag,
          disabled
        },
        accordionSection: {
          open
        },
        managedChildren: {
          index
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderSection)(sectionInfo, useAriaAccordionSectionHeaderProps({ ...unknownProps,
        ref
      }), useAriaAccordionSectionBodyProps({}));
    }

    const AriaAccordionSection = N(AriaAccordionSectionU);

    function defaultRender$1(tag) {
      return function (buttonProps) {
        return h$1(tag, buttonProps);
      };
    }

    function AriaButtonU(_ref, ref) {
      let {
        tag,
        onPress,
        pressed,
        children,
        render,
        disabled,
        ...unknownProps
      } = _ref;
      const {
        useAriaButtonProps
      } = useAriaButton({
        tag,
        onPress,
        pressed,
        disabled
      }); //const button = createElement(tag, useAriaButtonProps(propsButton()) as any);

      return (render !== null && render !== void 0 ? render : defaultRender$1(tag))(useAriaButtonProps({
        ref,
        children,
        ...unknownProps
      }));
    }
    const AriaButton = N(AriaButtonU);

    function defaultRenderSeparate(inputTag, inputLabel) {
      return function (info, inputProps, labelProps) {
        const input = h$1(inputTag, inputProps);
        const label = h$1(inputLabel, labelProps);
        return o$1(p$1, {
          children: [input, label]
        });
      };
    }
    function defaultRenderWrapping(inputTag, inputLabel) {
      return function (info, inputProps, _ref) {
        let {
          children,
          ...labelProps
        } = _ref;
        const input = h$1(inputTag, inputProps);
        const label = h$1(inputLabel, { ...labelProps,
          children: o$1(p$1, {
            children: [input, children]
          })
        });
        return o$1(p$1, {
          children: label
        });
      };
    }
    function AriaCheckbox(_ref2) {
      let {
        checked,
        disabled,
        tagLabel,
        labelPosition,
        tagInput,
        onInput,
        render,
        children
      } = _ref2;
      const {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxInfo
      } = useAriaCheckbox({
        checkbox: {
          onInput
        },
        checkboxLike: {
          checked,
          disabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        }
      });
      const {
        useCheckboxInputElementProps
      } = useCheckboxInputElement();
      const {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement();
      const input = useCheckboxInputElementProps({});
      const label = useCheckboxLabelElementProps({
        children
      });

      if (labelPosition == "separate") {
        return (render !== null && render !== void 0 ? render : defaultRenderSeparate(tagInput, tagLabel))(checkboxInfo, input, label);
      } else {
        return (render !== null && render !== void 0 ? render : defaultRenderWrapping(tagInput, tagLabel))(checkboxInfo, input, label);
      }
    }

    function defaultRenderChildSeparate(inputTag, inputLabel) {
      return function (info, input, label) {
        return defaultRenderSeparate(inputTag, inputLabel)(info, input, label);
      };
    }

    function defaultRenderChildWrapping(inputTag, inputLabel) {
      return function (info, input, label) {
        return defaultRenderWrapping(inputTag, inputLabel)(info, input, label);
      };
    }

    function defaultRenderGroupSeparate(inputTag, inputLabel) {
      return function (info, input, label, children) {
        return o$1(p$1, {
          children: [defaultRenderSeparate(inputTag, inputLabel)(info, input, label), children]
        });
      };
    }

    function defaultRenderGroupWrapping(inputTag, inputLabel) {
      return function (info, input, label, children) {
        return o$1(p$1, {
          children: [defaultRenderWrapping(inputTag, inputLabel)(info, input, label), children]
        });
      };
    }

    const UseCheckboxGroupChildContext = B$2(null);
    function CheckboxGroup(_ref) {
      let {
        children,
        disabled: parentDisabled,
        tagInput,
        tagLabel,
        render,
        labelPosition,
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        labelChildren
      } = _ref;
      const {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        ...checkboxGroupParentInfo
      } = useCheckboxGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useCheckboxGroupParentInputProps,
        useCheckboxGroupParentLabelProps
      } = useCheckboxGroupParentInput({
        checkbox: {},
        checkboxLike: {
          disabled: parentDisabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        }
      });
      const inputProps = useCheckboxGroupParentInputProps({});
      const labelProps = useCheckboxGroupParentLabelProps({
        children: labelChildren
      });
      let wrapping;

      if (labelPosition == "separate") {
        wrapping = (render !== null && render !== void 0 ? render : defaultRenderGroupSeparate(tagInput, tagLabel))(checkboxGroupParentInfo, inputProps, labelProps, children);
      } else {
        wrapping = (render !== null && render !== void 0 ? render : defaultRenderGroupWrapping(tagInput, tagLabel))(checkboxGroupParentInfo, inputProps, labelProps, children);
      }

      return o$1(UseCheckboxGroupChildContext.Provider, {
        value: useCheckboxGroupChild,
        children: wrapping
      });
    }
    function CheckboxGroupCheckbox(_ref2) {
      let {
        checked,
        disabled,
        index,
        labelPosition,
        tagInput,
        tagLabel,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        onInput,
        children,
        render
      } = _ref2;
      const {
        useCheckboxGroupChildInputProps,
        useCheckboxGroupChildLabelProps,
        ...checkboxGroupChildInfo
      } = x$1(UseCheckboxGroupChildContext)({
        asCheckbox: {
          checkbox: {
            onInput
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          }
        },
        asCheckboxGroupChild: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          }
        }
      });
      const inputProps = useCheckboxGroupChildInputProps({});
      const labelProps = useCheckboxGroupChildLabelProps({
        children
      });

      if (labelPosition == "separate") {
        return (render !== null && render !== void 0 ? render : defaultRenderChildSeparate(tagInput, tagLabel))(checkboxGroupChildInfo, inputProps, labelProps);
      } else {
        return (render !== null && render !== void 0 ? render : defaultRenderChildWrapping(tagInput, tagLabel))(checkboxGroupChildInfo, inputProps, labelProps);
      }
    }

    const ListboxMultiContext = B$2(null);

    function ListboxMultiU(_ref, ref) {
      let {
        render,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        tagList,
        children: vnodeChildren
      } = _ref;
      const {
        useListboxMultiItem,
        useListboxMultiLabel,
        useListboxMultiProps,
        ...listboxReturnType
      } = useAriaListboxMulti({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxMulti: {
          tagLabel,
          tagList
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxMultiLabelProps
      } = useListboxMultiLabel();
      const p1 = useListboxMultiLabelProps({});
      const p2 = useListboxMultiProps({
        children: vnodeChildren,
        ref
      });
      return o$1(ListboxMultiContext.Provider, {
        value: useListboxMultiItem,
        children: (render !== null && render !== void 0 ? render : defaultListRender$1)(listboxReturnType, p1, p2)
      });
    }

    function defaultListRender$1(info, labelProps, listProps) {
      const label = o$1("div", { ...labelProps
      });

      const list = o$1("ul", { ...listProps
      });

      return o$1(p$1, {
        children: [label, list]
      });
    }

    function defaultListItemRender$1(info, listItemProps) {
      const listItem = o$1("li", { ...listItemProps
      });

      return o$1(p$1, {
        children: listItem
      });
    }

    function ListboxMultiItemU(_ref2, ref) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        selected,
        onSelect,
        children
      } = _ref2;
      const {
        useListboxMultiItemProps,
        ...itemReturn
      } = x$1(ListboxMultiContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxMultiItem: {
          disabled,
          selected,
          onSelect
        }
      }); //const listItem = createElement(tagListItem, useListboxMultiItemProps({ ref }) as any);

      return o$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultListItemRender$1)(itemReturn, useListboxMultiItemProps({
          ref,
          children
        }))
      });
    }

    const ListboxMulti = N(ListboxMultiU);
    const ListboxMultiItem = N(ListboxMultiItemU);

    const ListboxSingleContext = B$2(null);

    function ListboxSingleU(_ref, ref) {
      let {
        render,
        selectedIndex,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        selectionMode,
        tagList,
        onSelect,
        children: vnodeChildren
      } = _ref;
      const {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps,
        ...listboxReturnType
      } = useAriaListboxSingle({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxSingle: {
          selectionMode,
          tagLabel,
          tagList,
          onSelect
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        singleSelection: {
          selectedIndex
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxSingleLabelProps
      } = useListboxSingleLabel(); //const label = createElement(tagLabel, useListboxSingleLabelProps({}) as any);
      //const list = createElement(tagList, useListboxSingleProps({ children: vnodeChildren, ref }) as any);

      return o$1(ListboxSingleContext.Provider, {
        value: useListboxSingleItem,
        children: (render !== null && render !== void 0 ? render : defaultListRender)({ ...listboxReturnType
        }, useListboxSingleLabelProps({}), useListboxSingleProps({
          children: vnodeChildren,
          ref
        }))
      });
    }

    function defaultListRender(info, labelProps, listProps) {
      return o$1(p$1, {
        children: [o$1("label", { ...labelProps
        }), o$1("ul", { ...listProps
        })]
      });
    }

    function defaultListItemRender(info, listItemProps) {
      return o$1("li", { ...listItemProps
      });
    }

    function ListboxSingleItemU(_ref2, ref) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        children
      } = _ref2;
      const {
        useListboxSingleItemProps,
        rovingTabIndex,
        singleSelection
      } = x$1(ListboxSingleContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxSingleItem: {
          disabled
        }
      });
      return o$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultListItemRender)({
          rovingTabIndex,
          singleSelection
        }, useListboxSingleItemProps({
          children,
          ref
        }))
      });
    }

    N(ListboxSingleU);
    N(ListboxSingleItemU);

    B$2(null);

    B$2(null);

    const SliderThumbContext = B$2(null);

    function SliderThumbU(_ref2, ref) {
      let {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        index,
        flags,
        render,
        valueText
      } = _ref2;
      const {
        useAriaSliderThumbProps,
        ...sliderInfo
      } = x$1(SliderThumbContext)({
        managedChild: {
          index,
          flags
        },
        sliderThumb: {
          label,
          tag,
          value,
          max,
          min,
          onValueChange,
          valueText
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderThumb)(sliderInfo, useAriaSliderThumbProps({
        ref
      }));
    }

    function defaultRenderThumb(info, thumbProps) {
      return o$1("input", { ...thumbProps
      });
    }

    N(SliderThumbU);

    const LocationContext = B$2(null);
    const TableBodyContext = B$2(null);
    const TableRowContext = B$2(null);
    const TableCellContext = B$2(null);

    function defaultRenderTable(info, tableProps) {
      return o$1("table", { ...tableProps
      });
    }

    function defaultRenderTableBody(info, bodyProps) {
      return o$1("tbody", { ...bodyProps
      });
    }

    function defaultRenderTableHead(headProps) {
      return o$1("thead", { ...headProps
      });
    }

    function defaultRenderTableFoot(footProps) {
      return o$1("tfoot", { ...footProps
      });
    }

    function defaultRenderTableRow(info, rowProps) {
      return o$1("tr", { ...rowProps
      });
    }

    function defaultRenderTableCell(info, cellProps) {
      return o$1("td", { ...cellProps
      });
    }

    function TableU(_ref, ref) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        render
      } = _ref;
      const {
        useTableBody,
        useTableProps,
        useTableRow,
        ...tableInfo
      } = useAriaTable({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(TableBodyContext.Provider, {
        value: useTableBody,
        children: o$1(TableRowContext.Provider, {
          value: useTableRow,
          children: (render !== null && render !== void 0 ? render : defaultRenderTable)(tableInfo, useTableProps({
            ref
          }))
        })
      });
    }

    function TableBodyU(_ref2, ref) {
      let {
        render
      } = _ref2;
      const {
        useTableBodyProps,
        ...sectionInfo
      } = x$1(TableBodyContext)({});
      return o$1(LocationContext.Provider, {
        value: "body",
        children: (render !== null && render !== void 0 ? render : defaultRenderTableBody)(sectionInfo, useTableBodyProps({
          ref
        }))
      });
    }

    function TableHeadU(_ref3, ref) {
      let {
        render
      } = _ref3;
      return o$1(LocationContext.Provider, {
        value: "head",
        children: (render !== null && render !== void 0 ? render : defaultRenderTableHead)({
          ref
        })
      });
    }

    function TableFootU(_ref4, ref) {
      let {
        render
      } = _ref4;
      return o$1(LocationContext.Provider, {
        value: "foot",
        children: (render !== null && render !== void 0 ? render : defaultRenderTableFoot)({
          ref
        })
      });
    }

    function TableRowU(_ref5, ref) {
      let {
        index,
        text,
        blurSelf,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        render
      } = _ref5;
      const {
        useTableCell,
        useTableRowProps,
        ...rowInfo
      } = x$1(TableRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender,
            onTabbedInTo,
            onTabbedOutOf
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        tableRow: {
          location: x$1(LocationContext)
        }
      });
      return o$1(TableCellContext.Provider, {
        value: useTableCell,
        children: (render !== null && render !== void 0 ? render : defaultRenderTableRow)(rowInfo, useTableRowProps({
          ref
        }))
      });
    }

    function TableCellU(_ref6, ref) {
      let {
        index,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        value,
        render
      } = _ref6;
      const {
        useTableCellProps,
        ...cellInfo
      } = x$1(TableCellContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        subInfo: {
          location: x$1(LocationContext),
          value
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderTableCell)(cellInfo, useTableCellProps({
        ref
      }));
    }

    N(TableU);
    N(TableBodyU);
    N(TableHeadU);
    N(TableFootU);
    N(TableRowU);
    N(TableCellU);

    B$2(null);
    B$2(null);

    B$2(null);

    function defaultRender(info, triggerProps, tooltipProps) {
      return o$1(p$1, {
        children: [o$1("div", { ...triggerProps
        }), o$1("div", { ...tooltipProps
        })]
      });
    }

    function TooltipU(_ref) {
      let {
        focusDelay,
        mouseoutDelay,
        mouseoverDelay,
        render
      } = _ref;
      const {
        useTooltip,
        useTooltipTrigger,
        ...info
      } = useAriaTooltip({
        focusDelay,
        mouseoutDelay,
        mouseoverDelay
      });
      const {
        useTooltipTriggerProps
      } = useTooltipTrigger();
      const {
        useTooltipProps
      } = useTooltip();
      return o$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultRender)(info, useTooltipTriggerProps({}), useTooltipProps({}))
      });
    }

    N(TooltipU);

    function DemoAccordion(props) {
        return o$1(AriaAccordion, { ...props, render: (info, children) => { return o$1("div", { id: "accordion-demo", children: children }); } });
    }
    function DemoAccordionSection({ index, body, heading, disabled, open }) {
        return o$1(AriaAccordionSection, { index: index, open: open, disabled: disabled, render: (info, headerProps, bodyProps) => {
                return (o$1(p$1, { children: o$1(Heading, { heading: o$1("div", { ...headerProps, children: [heading, " (", !info.accordionSection.expanded && "not ", " open), (", !info.accordionSection.focused && "not ", " focused)"] }), children: o$1("div", { ...bodyProps, children: body }) }) }));
            } });
    }
    function Blurb$4() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/", children: "In accordance with the ARIA guidelines for Accordion patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Each section's header and body are linked via ID; the body is ", o$1("code", { children: "labelled-by" }), " the header and the header ", o$1("code", { children: "control" }), "s the body."] }), o$1("li", { children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used." }), o$1("li", { children: ["If the header element is not a ", o$1("code", { children: "<button>" }), " element, it is given that ", o$1("code", { children: "role" }), "."] }), o$1("li", { children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab" }), o$1("li", {})] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["The ", o$1("code", { children: "render" }), " prop each ", o$1("code", { children: "AccordionSection" }), " takes must wrap the header button with a ", o$1("a", { href: "https://w3c.github.io/aria/#heading", children: "heading" }), " (e.g. ", o$1("code", { children: "h3" }), ", or ", o$1("code", { children: "<Heading>" }), "). See the default implementation for an example."] }) })] }));
    }
    function Code$4() {
        return (o$1("code", { children: `<AriaAccordion render={...}>
    <AriaAccordionSection index={0} render={...} />
    <AriaAccordionSection index={1} render={...} />
    <AriaAccordionSection index={2} render={...} />
</AriaAccordion>` }));
    }
    function Demo$4() {
        return (o$1(p$1, { children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1(DemoAccordion, { children: [o$1(DemoAccordionSection, { index: 0, heading: "Accordion section #0", body: "Body content #0", disabled: false }), o$1(DemoAccordionSection, { index: 1, heading: "Accordion section #1", body: "Body content #1", disabled: false }), o$1(DemoAccordionSection, { index: 2, heading: "Accordion section #2 (disabled)", body: "Body content #2", disabled: true }), o$1(DemoAccordionSection, { index: 3, heading: "Accordion section #3 (forced open)", body: "Body content #3", disabled: false, open: true }), o$1(DemoAccordionSection, { index: 4, heading: "Accordion section #4 (forced closed)", body: "Body content #4", disabled: false, open: false })] })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$3() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/", children: "In accordance with the ARIA guidelines for Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Whether using an actual ", o$1("code", { children: "<button>" }), ", or something else like a ", o$1("code", { children: "<div>" }), ", the proper roles and event handlers will be applied."] }), o$1("li", { children: "Buttons can be toggled (pressed or unpressed)." }), o$1("li", { children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", { children: [o$1("li", { children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click" }), o$1("li", { children: "When Enter is pressed, the button is immediately activated" }), o$1("li", { children: "When Space is pressed, the button is activated once released" }), o$1("li", { children: "iOS Safari properly focuses the button" })] })] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", { children: "aria-label" }), " manually stating what happens when the button is pressed."] }) })] }));
    }
    function Code$3() {
        return (o$1("code", { children: `<AriaButton tag="button">Button</AriaButton>
    <AriaButton tag="div">Div</AriaButton>` }));
    }
    function Demo$3() {
        const onPress = () => { alert("Button clicked"); };
        const [pressed, setPressed] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1(AriaButton, { disabled: false, onPress: onPress, tag: "button", children: "Button" }), o$1(AriaButton, { disabled: "soft", onPress: onPress, tag: "button", children: "Button, disabled (soft)" }), o$1(AriaButton, { disabled: "hard", onPress: onPress, tag: "button", children: "Button, disabled (hard)" }), o$1(AriaButton, { disabled: false, onPress: onPress, tag: "div", children: "Div" }), o$1(AriaButton, { disabled: "soft", onPress: onPress, tag: "div", children: "Div, disabled (soft)" }), o$1(AriaButton, { disabled: "hard", onPress: onPress, tag: "div", children: "Div, disabled (hard)" }), o$1(AriaButton, { disabled: false, tag: "button", pressed: pressed, onPress: e => setPressed(e[EventDetail].pressed ?? false), children: ["Button (", pressed ? "pressed" : "unpressed", ")"] })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$2() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/", children: "In accordance with the ARIA guidelines for Checkbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)" }), o$1("li", { children: ["Can be ", o$1("code", { children: "mixed" }), " instead, though ", o$1("code", { children: "onInput" }), " will only ever be called with ", o$1("code", { children: "true" }), " or ", o$1("code", { children: "false" })] }), o$1("li", { children: ["Supports using ", o$1("code", { children: "<input>" }), "s and ", o$1("code", { children: "<label>" }), "s, as well as just plain ol' ", o$1("code", { children: "<div>" }), "s on either/both"] }), o$1("li", { children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element." }), o$1("li", { children: "Checkbox groups (with a tri-state parent) are a separate component/hook" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually."] }) })] }));
    }
    function Code$2() {
        return (o$1("code", { children: `<AriaCheckbox checked={true} labelPosition="separate" tagInput="input" tagLabel="label">Label text</AriaCheckbox>` }));
    }
    function Demo$2() {
        const [checked, setChecked] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1(AriaButton, { tag: "button", onPress: () => { setChecked("mixed"); }, children: "Change to mixed" }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "separate", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "input", tagLabel: "label", children: "Separate, input & label" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "wrapping", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "input", tagLabel: "label", children: "Wrapping, input & label" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "separate", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "div", tagLabel: "label", children: "Separate, div & label" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "wrapping", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "div", tagLabel: "label", children: "Wrapping, div & label" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "separate", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "input", tagLabel: "div", children: "Separate, input & div" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "wrapping", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "input", tagLabel: "div", children: "Wrapping, input & div" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "separate", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "div", tagLabel: "div", children: "Separate, div & div" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "wrapping", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "div", tagLabel: "div", children: "Wrapping, div & div" }) }), o$1("div", { style: { border: "1px solid black" }, children: o$1(AriaCheckbox, { labelPosition: "separate", checked: checked, onInput: e => setChecked(e[EventDetail].checked), disabled: false, tagInput: "input", tagLabel: "label", render: (info, input, label) => { return o$1("input", { ...input, "aria-label": "Hidden label (technically separate), input & label" }); }, children: "This text will not be rendered." }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function DemoCheckbox({ index }) {
        const [checked, setChecked] = useState(false);
        const labelText = `Checkbox #${index}`;
        return (o$1(CheckboxGroupCheckbox, { checked: checked, index: index, disabled: false, labelPosition: "separate", text: labelText, tagInput: "input", tagLabel: "label", onInput: e => setChecked(e[EventDetail].checked), children: labelText }));
    }
    function Blurb$1() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", { children: "checkboxgroup" }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."] }), o$1("ul", { children: [o$1("li", { children: ["All normal ", o$1("code", { children: "AriaCheckbox" }), " functionality is supported on each individual checkbox."] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$1() {
        return (o$1("code", { children: `` }));
    }
    function Demo$1() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of checkboxes"] }), o$1("div", { children: o$1(CheckboxGroup, { disabled: false, labelPosition: "separate", tagInput: "input", tagLabel: "label", labelChildren: "Parent checkbox", children: Array.from((function* () {
                            for (let i = 0; i < count; ++i) {
                                yield o$1("div", { children: o$1(DemoCheckbox, { index: i }, i) });
                            }
                        })()) }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function DemoListItem({ index }) {
        const [selected, setSelected] = useState(false);
        console.log(`Rendering ListItem #${index}, ${selected.toString()}`);
        const labelText = `List item #${index}${selected ? " (selected)" : ""}`;
        return (o$1(ListboxMultiItem, { selected: selected, index: index, disabled: false, text: labelText, onSelect: e => { }, children: [" ", labelText] }));
    }
    function Blurb() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", { children: "checkboxgroup" }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."] }), o$1("ul", { children: [o$1("li", { children: ["All normal ", o$1("code", { children: "AriaCheckbox" }), " functionality is supported on each individual checkbox."] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code() {
        return (o$1("code", { children: `` }));
    }
    function Demo() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxMulti, { tagLabel: "label", tagList: "ul", children: [o$1(DemoListItem, { index: 0 }), o$1(DemoListItem, { index: 1 }), o$1(DemoListItem, { index: 2 }), o$1(DemoListItem, { index: 3 }), o$1(DemoListItem, { index: 4 })] }) })] }));
    }

    l$1.debounceRendering = queueMicrotask;
    //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const Component = () => {
        return (o$1(Heading, { heading: "Demos", children: [o$1(Heading, { heading: "Accordion", children: o$1(Demo$4, {}) }), o$1(Heading, { heading: "Button", children: o$1(Demo$3, {}) }), o$1(Heading, { heading: "Checkbox", children: o$1(Demo$2, {}) }), o$1(Heading, { heading: "Checkbox Group", children: o$1(Demo$1, {}) }), o$1(Heading, { heading: "Multi-select Listbox", children: o$1(Demo, {}) })] }));
    };
    requestAnimationFrame(() => {
        P(o$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZWZmZWN0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWNoaWxkLW1hbmFnZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1kb2N1bWVudC1jbGFzcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWV2ZW50LWhhbmRsZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWZvcmNlLXVwZGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWxvZ2ljYWwtZGlyZWN0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtdGltZW91dC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWtleWJvYXJkLW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yb3ZpbmctdGFiaW5kZXgudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbGlzdC1uYXZpZ2F0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZ3JpZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcmFuZG9tLWlkLnRzeCIsIi4uL3NyYy91c2UtYnV0dG9uLnRzIiwiLi4vc3JjL3VzZS1hY2NvcmRpb24udHN4IiwiLi4vc3JjL3VzZS1sYWJlbC50cyIsIi4uL3NyYy91c2UtY2hlY2tib3gudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LWdyb3VwLnRzIiwiLi4vc3JjL3VzZS1saXN0Ym94LXNpbmdsZS50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1tdWx0aS50cyIsIi4uL3NyYy91c2UtdG9vbHRpcC50cyIsIi4uL3NyYy91c2UtdGFibGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9hY2NvcmRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC50c3giLCIuLi9zcmMvY29tcG9uZW50L2NoZWNrYm94LWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbGlzdGJveC1tdWx0aS50c3giLCIuLi9zcmMvY29tcG9uZW50L2xpc3Rib3gtc2luZ2xlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbWVudS50c3giLCIuLi9zcmMvY29tcG9uZW50L3JhZGlvLWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvc2xpZGVyLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFibGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90YWJzLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdG9vbHRpcC50c3giLCJkZW1vcy9hY2NvcmRpb24udHN4IiwiZGVtb3MvYnV0dG9uLnRzeCIsImRlbW9zL2NoZWNrYm94LnRzeCIsImRlbW9zL2NoZWNrYm94LWdyb3VwLnRzeCIsImRlbW9zL2xpc3Rib3gtbXVsdGkudHN4IiwiaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHdhcm5Pbk92ZXJ3cml0ZSB9IGZyb20gXCIuLi9wcm9wc1wiO1xuXG5jb25zdCBIZWFkaW5nTGV2ZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgwKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRpbmcoeyBjaGlsZHJlbiwgaGVhZGluZywgLi4ucHJvcHMgfTogeyBoZWFkaW5nOiBDb21wb25lbnRDaGlsZHJlbiB9ICYgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SFRNTEhlYWRpbmdFbGVtZW50Pikge1xuICAgIGNvbnN0IGhlYWRpbmdMZXZlbEJlZm9yZVVzID0gdXNlQ29udGV4dChIZWFkaW5nTGV2ZWxDb250ZXh0KTtcbiAgICBjb25zdCBuZXdIZWFkaW5nTGV2ZWwgPSBoZWFkaW5nTGV2ZWxCZWZvcmVVcyArIDE7XG4gICAgbGV0IHRhZzogc3RyaW5nO1xuICAgIGlmIChuZXdIZWFkaW5nTGV2ZWwgPD0gNikge1xuICAgICAgICB0YWcgPSBgaCR7bmV3SGVhZGluZ0xldmVsfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YWcgPSAnZGl2JztcbiAgICAgICAgcHJvcHNbXCJhcmlhLWxldmVsXCJdID0gd2Fybk9uT3ZlcndyaXRlKFwiSGVhZGluZ1wiLCBcImFyaWEtbGV2ZWxcIiwgcHJvcHNbXCJhcmlhLWxldmVsXCJdLCBgJHtuZXdIZWFkaW5nTGV2ZWx9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgIDxIZWFkaW5nUmVzZXQgbmV3TGV2ZWw9e2hlYWRpbmdMZXZlbEJlZm9yZVVzICsgMX0+XG4gICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWcgYXMgYW55LCBwcm9wcywgaGVhZGluZyl9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvSGVhZGluZ1Jlc2V0PlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkaW5nUmVzZXQoeyBuZXdMZXZlbCwgY2hpbGRyZW4gfTogeyBuZXdMZXZlbDogbnVtYmVyLCBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSl7ICAgIFxuICAgIHJldHVybiAoXG4gICAgICAgIDxIZWFkaW5nTGV2ZWxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtuZXdMZXZlbH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvSGVhZGluZ0xldmVsQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiXG5cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8Uz4gPSAodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUykpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiA9ICgodmFsdWU6IFQsIHByZXZWYWx1ZTogVCB8IHVuZGVmaW5lZCkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGgsIDApO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VT4odmFsdWU6IFUsIGluZGV4OiBudW1iZXIpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmKHZhbHVlKTtcbiAgICAgICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2luZGV4fS1pbmRleGVkIGFyZ3VtZW50LmApO1xuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gc2V0VGltZW91dCkoZik7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgdXNlU3RhdGVgLCBidXQgZm9yIHZhbHVlcyB0aGF0IGFyZW4ndCBcInJlbmRlci1pbXBvcnRhbnRcIiAmbmRhc2g7IHVwZGF0ZXMgZG9uJ3QgY2F1c2UgYSByZS1yZW5kZXIgYW5kIHNvIHRoZSB2YWx1ZSBzaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgcmVuZGVyICh0aG91Z2ggaXQgY2VydGFpbmx5IGNhbiwgYXQgbGVhc3QgYnkgcmUtcmVuZGVyaW5nIGFnYWluKS5cbiAqIFxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXG4gKiBcbiAqIFRvIHN1bW1hcml6ZSwgaXQncyBsaWtlIGEgYHVzZVN0YXRlYC1gdXNlRWZmZWN0YCBtYXNodXA6XG4gKiBcbiAqIDEuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgdGhpcyB2ZXJzaW9uIG9mIGBzZXRTdGF0ZWAgZG9lc24ndCByZS1yZW5kZXIgdGhlIHdob2xlIGNvbXBvbmVudFxuICogMi4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB5b3UgY2FuIHJ1biBhIGZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgdGhhdCBvcHRpb25hbGx5IHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXG4gKiA0LiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB0aGUgc2luZ2xlIFwiZGVwZW5kZW5jeVwiIGlzIGJhc2VkIG9uIHlvdXIgY2FsbHMgdG8gYHNldFN0YXRlYFxuICogXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cbiAqIFxuICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBcImVmZmVjdFwiIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBgdXNlRWZmZWN0YCdzIFwiZWZmZWN0XCIgZnVuY3Rpb24uICBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBUKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cblxuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3QgciA9IHVzZVJlZih7IG1pY3JvdGFza1F1ZXVlZDogZmFsc2UsIGFyZzogdW5kZWZpbmVkIGFzIHVuZGVmaW5lZCB8IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxUPj5bMF0sIHByZXZEZXA6IHVuZGVmaW5lZCBhcyBUIHwgdW5kZWZpbmVkIH0pO1xuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxUPj4oKGFyZykgPT4ge1xuICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogZ2V0VmFsdWUoKTtcbiAgICAgICAgci5jdXJyZW50LmFyZyA9IGFyZztcbiAgICAgICAgaWYgKCFyLmN1cnJlbnQubWljcm90YXNrUXVldWVkKSB7XG4gICAgICAgICAgICByLmN1cnJlbnQubWljcm90YXNrUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICByLmN1cnJlbnQubWljcm90YXNrUXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy9yLmN1cnJlbnQuaGFuZGxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gci5jdXJyZW50LnByZXZEZXA7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gci5jdXJyZW50LmFyZyE7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVwID0gYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcocHJldkRlcCEpIDogYXJnO1xuICAgICAgICAgICAgICAgIGlmIChkZXAgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSB0byB0aGUgdXNlciB0aGF0IHRoZXkgc2hvdWxkbid0IGNhbGwgZ2V0VmFsdWUgZHVyaW5nIG9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGRlcCwgcHJldkRlcCkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkZXA7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9IiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlUmVmRWxlbWVudFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPjtcclxuICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cclxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXHJcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxyXG4gKiBcclxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXHJcbiAqIFxyXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzPzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XHJcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncyA/PyB7fSk7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XHJcblxyXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXHJcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+PigoZSwgcHJldlZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcclxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XHJcblxyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcclxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbD4oaGFuZGxlciwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCB1c2VSZWZFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXT4oKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wczxUPih7IHJlZjogc2V0RWxlbWVudCB9LCBwcm9wcyksIFtdKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH1cclxufVxyXG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuXG5cbi8qKlxuICogXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0aGF0IGEgZm9jdXMgZXZlbnQgY2FuIGhhcHBlbi4gIEFzc3VtZVxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XG4gKiBcbiAqIDEuIFRoZSBwYWdlIGxvYWRzLlxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cbiAqIDIuIFRoZSB3aW5kb3cgaXMgZm9jdXNlZCwgYW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cbiAqICAgICAgdGhlIGJyb3dzZXIsIHRoaXMgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBoYW5kbGVyIHdhcyBhdHRhY2hlZCB0byBgd2luZG93YCBvciBgZG9jdW1lbnRgLlxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50IGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqIDQuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIG5vdyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIGBib2R5YC5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogXG4gKiBcbiAqIEluIHN1bW1hcnk6XG4gKiAxLiBGb2N1cyBldmVudHMgKmRvKiBub3RpZnkgdXMgb2YgYWxsIGNoYW5nZXMgaW4gZm9jdXMsIGJ1dCB0aGVyZSBpcyBubyBvbmUgc2luZ2xlIGNvbXByZWhlbnNpdmUgZXZlbnQgdGhhdCBwcm92aWRlcyB1cyB3aXRoIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb24uXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cbiAqIDMuIEEgYGJsdXJgIHdpdGhvdXQgYSBgZm9jdXNgIGNhbiBhbmQgd2lsbCBvY2N1ci4gVGhpcyBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gc29sZWx5IHVzZSBgZm9jdXNgIHRvIGRldGVjdCBhbGwgY2hhbmdlcy5cbiAqIDQuIEEgYGJsdXJgIGV2ZW50IHdob3NlIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsIGluZGljYXRlcyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZm9sbG93aW5nIGBmb2N1c2AgZXZlbnQuXG4gKiBcbiAqIFxuICogQHBhcmFtIGNhbGxiYWNrIFxuICogQHJldHVybnMgXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSB8IG51bGwpID0+IHZvaWQpPj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUpID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTtcblxuY29uc3QgbWljcm90YXNrcyA9IG5ldyBTZXQ8TWFwPGFueSwgYW55Pj4oKTtcblxuLy8gVGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBvZnRlbiBmaXJlIHN5bmNyb25vdXNseSBpbiB0aGUgbWlkZGxlIG9mIHJ1bm5pbmcgY29kZS5cbi8vIEUuRy4gY2FsbGluZyBlbGVtZW50LmZvY3VzKCkgY2FuIGNhdXNlIGEgZm9jdXNpbiBldmVudCBoYW5kbGVyIHRvIGltbWVkaWF0ZWx5IGludGVycnVwdCB0aGF0IGNvZGUuXG4vLyBGb3IgdGhlIHB1cnBvc2Ugb2YgaW1wcm92aW5nIHN0YWJpbGl0eSwgd2UgZGVib3VuY2UgYWxsIGZvY3VzIGV2ZW50cyB0byB0aGUgbmV4dCBtaWNyb3Rhc2suXG5mdW5jdGlvbiBmb3JFYWNoVXBkYXRlcjxUPih3aW5kb3c6IFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIG1hcDogTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IFQpID0+IHZvaWQpPj4sIHZhbHVlOiBUKSB7XG4gICAgaWYgKCFtaWNyb3Rhc2tzLmhhcyhtYXApKSB7XG4gICAgICAgIG1pY3JvdGFza3MuYWRkKG1hcCk7XG4gICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgIG1pY3JvdGFza3MuZGVsZXRlKG1hcCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXJzID0gbWFwLmdldCh3aW5kb3cpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVyIG9mIHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXI/Lih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgbnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gd2luZG93Rm9jdXMoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIHRydWUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dCbHVyKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgZmFsc2UpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBOb2RlPiB7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsPjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcyBhbmQgaXMgbm90IG51bGwuIFxuICAgICAqIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50PjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgd2luZG93IGdhaW5zL2xvc2VzIGZvY3VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuPjtcblxuICAgIG9uTW91bnQ/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPltcIm9uTW91bnRcIl07XG4gICAgb25Vbm1vdW50PzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD5bXCJvblVubW91bnRcIl07XG4gICAgb25Nb3VudENoYW5nZT86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25FbGVtZW50Q2hhbmdlXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+IHtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciBgbnVsbGAgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudCB8IG51bGw7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlQWN0aXZlRWxlbWVudFByb3BzOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXTtcbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGluc3BlY3Qgd2hpY2ggZWxlbWVudCBpbiB0aGUgYGRvY3VtZW50YCBjdXJyZW50bHkgaGFzIGZvY3VzLCB3aGljaCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIG5vbmUgYXJlIGN1cnJlbnRseSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB3aW5kb3cgaGFzIGZvY3VzIGJ5IHJldHVybmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqICogYGdldEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRXaW5kb3dGb2N1c2VkKClgXG4gKiBcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcbiAqIFxuICogVGhpcyBpcyBhIHBhc3NpdmUgaG9vaywgc28gYnkgZGVmYXVsdCBpdCByZXR1cm5zIGdldHRlciBmdW5jdGlvbnMgdGhhdCByZXBvcnQgdGhpcyBpbmZvcm1hdGlvbiBidXQgdGhlIGNvbXBvbmVudCB3aWxsIG5vdCByZS1yZW5kZXIgYnkgZGVmYXVsdCB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLlxuICogXG4gKiBJZiB5b3UgbmVlZCB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLCB1c2UgdGhlIGBvbipDaGFuZ2VgIGFyZ3VtZW50cyB0byBzZXQgc29tZSBzdGF0ZSBvbiB5b3VyIGVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQ8VCBleHRlbmRzIE5vZGU+KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgb25Nb3VudENoYW5nZSB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUFjdGl2ZUVsZW1lbnRcIiwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG9uTW91bnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XG5cbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XG4gICAgICAgIG9uTW91bnQsXG4gICAgICAgIG9uVW5tb3VudCxcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZWxlbWVudDogVCB8IG51bGwsIHByZXZWYWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIG9uTW91bnRDaGFuZ2U/LihlbGVtZW50LCBwcmV2VmFsdWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBkb2N1bWVudD8uZGVmYXVsdFZpZXc7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KT8uc2l6ZSA/PyAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGVtIGV2ZW4gaWYgdGhleSdyZSB1bmRlZmluZWQgdG8gbW9yZSBlYXNpbHlcbiAgICAgICAgICAgICAgICAvLyBtYW5hZ2UgdGhlIFwiPjAgbWVhbnMgZG9uJ3QgYWRkIGhhbmRsZXJzXCIgbG9naWMuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4pO1xuICAgICAgICAgICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcbiAgICAgICAgICAgICAgICBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycy5hZGQoc2V0V2luZG93Rm9jdXNlZCk7XG5cbiAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICAgICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgICAgICAgICB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldFdpbmRvd0ZvY3VzZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSlcbiAgICB9KVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQgfCBudWxsPihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xuXG4gICAgcmV0dXJuIHsgZ2V0RWxlbWVudCwgdXNlQWN0aXZlRWxlbWVudFByb3BzOiB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XG59XG4iLCJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiB3aXRob3V0IGFsc28gbWFraW5nIGEgdXRpbGl0aWVzIGZpbGUuXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xuY29uc3QgdG9SdW4gPSBuZXcgTWFwPHN0cmluZywgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gb3B0aW9uc1tjb21taXROYW1lXSBhcyAodm5vZGU6IFZOb2RlLCBjb21taXRRdWV1ZTogQ29tcG9uZW50W10pID0+IHZvaWQ7XG5jb25zdCBuZXdDb21taXQ6IHR5cGVvZiBvcmlnaW5hbENvbW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IHByZXZpb3VzSW5wdXRzLmdldChpZCk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChvbGRJbnB1dHMsIGVmZmVjdEluZm8uaW5wdXRzKSkge1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cCA9IGVmZmVjdEluZm8uZWZmZWN0KCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5zZXQoaWQsIGVmZmVjdEluZm8uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1J1bi5jbGVhcigpO1xuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XG59XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cykge1xuXG4gICAgLyooKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gdXNlUmVmPHZvaWQgfCAoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcbiAgICAgICAgY29uc3QgcHJldkFyZ3NSZWYgPSB1c2VSZWY8SW5wdXRzPihudWxsISk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBwcmV2QXJnc1JlZi5jdXJyZW50ID0gaW5wdXRzITtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XG4gICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQgPSBlZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pKCk7Ki9cblxuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKCkpO1xuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3RcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCk6ICgpID0+IFQge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0sIFt2YWx1ZV0pO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIERvIG5vdCB1c2UgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UhICBgdXNlTGF5b3V0RWZmZWN0YCBpcyBmaW5lIHRob3VnaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KGZuOiBUKTogVCB7XG4gICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFQ+KGZuKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJnczogUGFyYW1ldGVyczxUPik6IFJldHVyblR5cGU8VD4gPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgfSwgW10pIGFzIFQ7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogU2xpZ2h0bHkgZW5oYW5jZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgIHRoYXQgaW5jbHVkZXMgYSBnZXR0ZXIgdGhhdCByZW1haW5zIGNvbnN0YW50XG4gKiAoaS5lLiB5b3UgY2FuIHVzZSBpdCBpbiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGl0IGJlaW5nIGEgZGVwZW5kZW5jeSkuXG4gKiBcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlPFQ+KGluaXRpYWxTdGF0ZTogVCB8ICgoKSA9PiBUKSk6IHJlYWRvbmx5IFt2YWx1ZTogVCwgc2V0VmFsdWU6IFN0YXRlVXBkYXRlcjxUPiwgZ2V0VmFsdWU6ICgpID0+IFRdIHtcblxuICAgIC8vIFdlIGtlZXAgYm90aCwgYnV0IG92ZXJycmlkZSB0aGUgYHNldFN0YXRlYCBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZVBdID0gdXNlU3RhdGVQKGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHN0YXRlKTtcblxuICAgIC8vIEhpamFjayB0aGUgbm9ybWFsIHNldHRlciBmdW5jdGlvbiBcbiAgICAvLyB0byBhbHNvIHNldCBvdXIgcmVmIHRvIHRoZSBuZXcgdmFsdWVcbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFN0YXRlVXBkYXRlcjxUPj4odmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsdWUgYXMgKChfcHJldlZhbHVlOiBUKSA9PiBUKTtcbiAgICAgICAgICAgIHNldFN0YXRlUChwcmV2VmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IGNhbGxiYWNrKHByZXZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldFN0YXRlUCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xuXG5cbiAgICBjb25zb2xlLmFzc2VydChyZWYuY3VycmVudCA9PT0gc3RhdGUgfHwgKHR5cGVvZiBzdGF0ZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihzdGF0ZSkpKTtcbiAgICByZXR1cm4gW3N0YXRlLCBzZXRTdGF0ZSwgZ2V0U3RhdGVdIGFzIGNvbnN0O1xufSIsImltcG9ydCB7IElucHV0cywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdE5hdGl2ZSwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuLyoqXHJcbiAqIFdyYXAgdGhlIG5hdGl2ZSBgdXNlRWZmZWN0YCB0byBhZGQgYXJndW1lbnRzIFxyXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICogQHBhcmFtIGltcGwgWW91IGNhbiBjaG9vc2Ugd2hldGhlciB0byB1c2UgYHVzZUVmZmVjdGAgb3IgYHVzZUxheW91dEVmZmVjdGAgYnlcclxuICogcGFzc2luZyBvbmUgb2YgdGhlbSBhcyB0aGlzIGFyZ3VtZW50LiBCeSBkZWZhdWx0LCBpdCdzIGB1c2VFZmZlY3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEksIGltcGwgPSB1c2VFZmZlY3ROYXRpdmUpIHtcclxuXHJcbiAgICBjb25zdCBwcmV2SW5wdXRzID0gdXNlUmVmPHVuZGVmaW5lZCB8IEk+KHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBlZmZlY3QyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IHsgZnJvbTogYW55LCB0bzogYW55IH1bXSA9IFtdO1xyXG4gICAgICAgIGlmIChpbnB1dHMgJiYgcHJldklucHV0cy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgocHJldklucHV0cy5jdXJyZW50Lmxlbmd0aCwgaW5wdXRzLmxlbmd0aCk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZJbnB1dHMuY3VycmVudFtpXSAhPSBpbnB1dHNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1tpXSA9IHsgZnJvbTogcHJldklucHV0cy5jdXJyZW50W2ldLCB0bzogaW5wdXRzW2ldIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXQgPSBlZmZlY3QocHJldklucHV0cy5jdXJyZW50LCBjaGFuZ2VzKTtcclxuICAgICAgICBwcmV2SW5wdXRzLmN1cnJlbnQgPSBpbnB1dHM7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcblxyXG4gICAgaW1wbChlZmZlY3QyLCBpbnB1dHMpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVmZmVjdENoYW5nZTxJIGV4dGVuZHMgSW5wdXRzLCBOIGV4dGVuZHMgbnVtYmVyPiB7IGZyb206IElbTl0sIHRvOiBJW05dIH1cclxuIiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0TmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWZmZWN0Q2hhbmdlLCB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XG5cbi8qKlxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYXMgd2VsbCBhcyB0aGUgY2hhbmdlcyB0aGF0IGNhdXNlZCB0aGUgaG9vayB0byBiZSBjYWxsZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3Q8SSBleHRlbmRzIElucHV0cz4oZWZmZWN0OiAocHJldjogSSB8IHVuZGVmaW5lZCwgY2hhbmdlczogRWZmZWN0Q2hhbmdlPEksIG51bWJlcj5bXSkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpLCBpbnB1dHM/OiBJKSB7XG4gICAgcmV0dXJuIHVzZUVmZmVjdChlZmZlY3QsIGlucHV0cywgdXNlTGF5b3V0RWZmZWN0TmF0aXZlKTtcbn1cbiIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUsIGRlYm91bmNlUmVuZGVyaW5nIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBpbmRleDogVDtcbiAgICBmbGFncz86IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PjtcbiAgICBzdWJJbmZvOiBDO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5pbnRlcmZhY2UgTUNQPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAqIFxuICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAqL1xuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VD47XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQ+O1xufVxuXG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyA9IGtleW9mIE1DUDxhbnk+O1xuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkT21pdHMgPSBrZXlvZiBNYW5hZ2VkQ2hpbGRJbmZvPGFueSwgYW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgT21pdHMgZXh0ZW5kcyBrZXlvZiBNQ1A8VD4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IE9taXQ8TUNQPFQ+LCBPbWl0cz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+IHtcbiAgICBtYW5hZ2VkQ2hpbGQ6IE9taXQ8TWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiwgTWNPbWl0cz47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQsIEMsIEs+IHtcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgdGhhdCBtdXN0IGJlIGNhbGxlZCBieSBldmVyeSBjaGlsZCBjb21wb25lbnQgdGhhdFxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIGNoaWxkJ3MgaW5kZXguXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIHVzZU1hbmFnZWRDaGlsZDogVXNlTWFuYWdlZENoaWxkPFQsIEMsIEs+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCwgQywgSywgbmV2ZXI+KSA9PiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlO1xuXG5cblxuXG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IFQpOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+KSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqICoqVU5TVEFCTEUqKiwgYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz5bXTtcbn1cblxuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyB7fT4gPSB7IGluZm86IEkgfTtcblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCwgbmV2ZXI+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxULCBDLCBLPiB7XG4gICAgLy90eXBlIEkgPSBJMyAmIE1hbmFnZWRDaGlsZEluZm9CYXNlPHN0cmluZyB8IG51bWJlcj47XG4gICAgdHlwZSBJbmZvID0gTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPjtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSA9IHBhcmVudFBhcmFtZXRlcnM7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjx7IGFycjogQXJyYXk8SW5mbz47IHJlYzogUGFydGlhbDxSZWNvcmQ8VCwgSW5mbz4+OyBoaWdoZXN0SW5kZXg6IG51bWJlciwgbG93ZXN0SW5kZXg6IG51bWJlciB9Pih7IGFycjogW10sIHJlYzoge30sIGhpZ2hlc3RJbmRleDogMCwgbG93ZXN0SW5kZXg6IDAgfSk7XG5cbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcbiAgICAvLyBDb21wYXJlIGdldE1hbmFnZWRDaGlsZEluZm9cbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xuICAgIC8vIHdoaWNoIG5lZWQgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikgeyBmKGNoaWxkKTsgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxULCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz5bXCJnZXRBdFwiXT4oKGluZGV4OiBUKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdITtcbiAgICB9LCBbXSlcblxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xuICAgIC8vIG91cnNlbHZlcyBiZWNhdXNlIG9mIGhhdmluZyBhIGBjaGlsZENvdW50YCBzdGF0ZSBvciBhbnl0aGluZyBzaW1pbGFyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcbiAgICAvLyB0byBtYXliZSBkbyBzb21ldGhpbmcgd2l0aCBhbGwgdGhlc2UgY2hpbGRyZW4gdGhhdCBqdXN0IG1vdW50ZWQuXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xuICAgIC8vIHNldENoaWxkQ291bnQgYW5kIHJlLXJlbmRlcmluZyBldmVyeSB0aW1lIGNoaWxkcmVuIG1vdW50XG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcbiAgICAvLyBcbiAgICAvLyBBcyBhbiBhbHRlcm5hdGUgc29sdXRpb24sIGFueSB0aW1lIGEgY2hpbGQgdXNlcyBVTEUgb24gbW91bnQsIGl0IHF1ZXVlcyBhIG1pY3JvdGFza1xuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XG4gICAgLy8gcnVucyBvbmNlLiBXaGVuIGl0J3MgZG9uZSwgaGFzUmVtb3RlVUxFIGlzIHJlc2V0IHNvIGl0IGNhbiBydW4gYWdhaW4gaWZcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8VD4sIHVubW91bnRzOiBTZXQ8VD4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxUPigpKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD8uKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKVxuICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4IGFzIG51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXTtcbiAgICAgICAgICAgICAgICBsZXQgc2hhdmUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzaGF2ZSA8PSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggJiYgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLnNwbGljZShtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgVF07XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IHVzZU1hbmFnZWRDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPj4oKHsgbWFuYWdlZENoaWxkOiBpbmZvLCB9KSA9PiB7XG4gICAgICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAgICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgICAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmZvLmluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5mby5pbmRleCBhcyBudW1iZXJdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZm8uaW5kZXggYXMgVF0gPSB7IGluZGV4OiBpbmZvLmluZGV4LCBmbGFnczogaW5mby5mbGFncyA/PyB7fSwgc3ViSW5mbzogaW5mby5zdWJJbmZvIH07XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZm8uaW5kZXggYXMgVCk7XG4gICAgICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcbiAgICAgICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZm8uaW5kZXggYXMgVCwgZmFsc2UpO1xuICAgICAgICB9LCBbaW5mby5pbmRleF0pO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaXMgY29uc2lkZXJlZCBhY3RpdmUgb24gbW91bnQuXG4gICAgICogXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxuICAgICAqL1xuICAgIGluaXRpYWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgLy9jbG9zZXN0Rml0PzogYm9vbGVhbjtcbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqIFxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxuICAgICAqIGlmIHRoZSByZXF1ZXN0ZWQgaW5kZXggZGlkbid0IGV4aXN0IG9yIHdhcyBoaWRkZW4uXG4gICAgICovXG4gICAgb25JbmRleENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPG51bWJlciB8IG51bGw+O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBjaGlsZHJlbiBoYXZlIG11bHRpcGxlIGZsYWdzLCB0aGUgYGtleWAgcGFyYW1ldGVyIGNvbnRyb2xzIHdoaWNoIGZsYWcgd2UncmUgY2hlY2tpbmcuXG4gICAgICogXG4gICAgICogVGhpcyBjYW4gYmUgYW55dGhpbmcgeW91IHdhbnQsIGJ1dCBtdXN0IG5vdCBjaGFuZ2UuXG4gICAgICovXG4gICAga2V5OiBLO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cbi8vZXhwb3J0IGludGVyZmFjZSBGbGFnZ2FibGVDaGlsZEluZm9CPEsgZXh0ZW5kcyBzdHJpbmc+IHsgZmxhZ3M6IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PiB9IFxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBjaGFuZ2VJbmRleDogKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICogXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCBvciB3aGVuZXZlciBjYWxsaW5nIGEgY2hpbGQncyBpc1ZhbGlkKCkgd291bGQgY2hhbmdlXG4gICAgICogICovXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcbiAqIDEuIFlvdSBoYXZlIGEgYnVuY2ggb2YgY2hpbGRyZW5cbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cbiAqIFxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB5b3UgbWF5IHdhbnQgdG8gdXNlIG11bHRpcGxlIGZsYWdzIHdpdGggdGhlIHNhbWUgY2hpbGRyZW4sIHRoaXMgaG9vayAqZG9lcyBub3QqIHVzZSBgdXNlTWFuYWdlZENoaWxkcmVuYCFcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXG4gKiBcbiAqIEFsc28gYmVjYXVzZSBvZiB0aGF0LCB0aGUgdHlwZXMgb2YgdGhpcyBmdW5jdGlvbiBhcmUgcmF0aGVyIG9kZC4gIEl0J3MgYmV0dGVyIHRvIHN0YXJ0IG9mZiB1c2luZyBhIGhvb2sgdGhhdCBhbHJlYWR5IHVzZXMgYSBmbGFnLCBzdWNoIGFzIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFzIGFuIGV4YW1wbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5GbGFnPEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwga2V5IH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8QywgSz4pOiBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlIHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwga2V5KTtcblxuICAgIGNvbnN0IFtnZXRDdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4ob25JbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4obnVsbCwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xuXG4gICAgLy8gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWMgKGJ1dCBjb3VsZCBiZSBJIGd1ZXNzKVxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLmFicyhjaGlsZC5pbmRleCAtIHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UgfHwgKG5ld0Rpc3RhbmNlID09IGNsb3Nlc3REaXN0YW5jZSAmJiBjaGlsZC5pbmRleCA8IHJlcXVlc3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlISAqL10pO1xuXG4gICAgLy8gQW55IHRpbWUgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIHdlIG5lZWQgdG8gZG91YmxlLWNoZWNrIHRvIHNlZSBpZiB0aGF0IGFmZmVjdHMgXG4gICAgLy8gdGhlIFwiY3VycmVudGx5IHNlbGVjdGVkXCIgKG9yIHdoYXRldmVyKSBpbmRleC4gIFRoZSB0d28gY2FzZXMgd2UncmUgbG9va2luZyBmb3I6XG4gICAgLy8gMS4gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjaGlsZCB1bm1vdW50ZWRcbiAgICAvLyAyLiBBIGNoaWxkIG1vdW50ZWQsIGFuZCBpdCBtb3VudHMgd2l0aCB0aGUgaW5kZXggd2UncmUgbG9va2luZyBmb3JcbiAgICBjb25zdCByZWV2YWx1YXRlQ2xvc2VzdEZpdCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KTtcblxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWN1cnJlbnRDaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RGaXRDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbiAgICBjb25zdCBjaGFuZ2VJbmRleCA9IHVzZUNhbGxiYWNrKChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnO1xuICAgICAgICAvL2lmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsICYmIGdldEZpdE51bGxUb1plcm8oKSlcbiAgICAgICAgLy8gICAgcmVxdWVzdGVkSW5kZXggPSAwO1xuXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCk7XG4gICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkICYmIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdEZpdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5pdGlhbEluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpbml0aWFsSW5kZXgpPy5mbGFncz8uW2tleV0/LnNldCh0cnVlKTtcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgZ2V0Q3VycmVudEluZGV4IH07XG59XG5cblxuXG4vKmV4cG9ydCB0eXBlIFNwcmVhZDxBIGV4dGVuZHMge30sIEIgZXh0ZW5kcyB7fT4gPSBPbWl0PEEsIGtleW9mIEI+ICYgQjtcbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWQ8QSBleHRlbmRzIHt9LCBCIGV4dGVuZHMge30+KGE6IEEsIGI6IEIpOiBTcHJlYWQ8QSwgQj4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLmJcbiAgICB9XG59Ki9cblxuLypcbmZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgdHlwZSBDID0geyBmb286IFwiYmFyXCIgfTtcbiAgICB0eXBlIEsgPSBcImZsYWcyXCI7XG5cbiAgICBjb25zdCB7IGNoaWxkcmVuLCB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IG9uQ2hpbGRyZW5Nb3VudENoYW5nZShtb3VudGVkLCB1bm1vdW50ZWQpKSB9IH0pO1xuICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogMCwgaW5mbzogeyBmb286IFwiYmFyXCIgfSwgZmxhZ3M6IHsgIH0gfSB9KTtcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCBnZXRDdXJyZW50SW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9ID0gdXNlQ2hpbGRyZW5GbGFnPEMsIEs+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleDogMCwga2V5OiBcImZsYWcyXCIgfSlcbn0qL1xuIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KGVsZW1lbnQ/OiBOb2RlKSB7IHJldHVybiAoZWxlbWVudD8ub3duZXJEb2N1bWVudCA/PyBkb2N1bWVudCA/PyB3aW5kb3cuZG9jdW1lbnQgPz8gZ2xvYmFsVGhpcy5kb2N1bWVudCk7IH1cblxudHlwZSBQID0gUGFyYW1ldGVyczx0eXBlb2YgY2xzeD47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEb2N1bWVudENsYXNzKGNsYXNzTmFtZTogUFswXSwgYWN0aXZlPzogYm9vbGVhbiwgZWxlbWVudD86IEhUTUxFbGVtZW50KSB7XG4gICAgZWxlbWVudCA/Pz0gZ2V0RG9jdW1lbnQoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY2xhc3NOYW1lID0gY2xzeChjbGFzc05hbWUpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50IS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbY2xhc3NOYW1lLCBhY3RpdmUsIGVsZW1lbnRdKTtcblxufVxuIiwiaW1wb3J0IHsgaCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxyXG4gKiBhbmQgbm90IHRoZSBnZW5lcmljIFwiSSdsbCBhY2NlcHQgYW55IHN0cmluZyBhbmQgYW55IGhhbmRsZXJcIiBvbmUuXHJcbiAqIFxyXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cclxuICogbGliLmRvbS50cyBhbHdheXMgZ2l2ZWluZyB0aGUgdHdvIG92ZXJsb2FkcyBpbiB0aGUgc2FtZSBvcmRlciwgd2l0aCB0aGVcclxuICogdHlwZWQgb25lIGZpcnN0LiAqVGhhdCogcHJvYmFibHkgd29uJ3QgY2hhbmdlLCBidXQgaWYgbW9yZSBvdmVybG9hZHNcclxuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cclxuICogXHJcbiAqIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTI3NjExNTYgZm9yIGhvdyBzZWxlY3RpbmcgdGhlIGNvcnJlY3Qgb3ZlcmxvYWQgd29ya3MuXHJcbiAqL1xyXG50eXBlIEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPFQ+ID1cclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogaW5mZXIgUiB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFIpID0+IGFueSA/IFIgOiBbXTtcclxuXHJcbi8vIEdldCBqdXN0IHRoZSB0eXBlZCB2ZXJzaW9uIG9mIGFkZEV2ZW50TGlzdGVuZXIsIGlmIGl0IGV4aXN0c1xyXG50eXBlIFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKC4uLmFyZ3M6IEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPChUW1wiYWRkRXZlbnRMaXN0ZW5lclwiXSk+KSA9PiB2b2lkO1xyXG5cclxuLy8gUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgXCJhZGRFdmVudExpc3RlbmVyXCIgKHRoZSBldmVudCB0eXBlIGFzIGEgc3RyaW5nKVxyXG50eXBlIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4gZXh0ZW5kcyAoKHR5cGU6IGluZmVyIEsyLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEsyIDogc3RyaW5nO1xyXG5cclxuXHJcbi8vIFRPRE86IFRoaXMgaXNuJ3QgcXVpdGUgYWJsZSB0byBuYXJyb3cgZG93biB0aGUgZXhhY3QgZXZlbnQgdHlwZSBmb3IgdW5rbm93biByZWFzb25zLlxyXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXHJcbi8vIEkgZG9uJ3Qga25vdyB3aHkgYGluZmVyIEhgIGlzIGRvaW5nIHRoYXQgd2hlbiB0aGUgdHlwZSBzaG91bGQgYmUgbmFycm93ZWQgYnkgYFRgIHRob3VnaC4uLlxyXG4vLyBOb3RlIHRoYXQgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIHN0aWxsIHVzZWQsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3QgbmFycm93IGRvd24gdGhlIHR5cGUsXHJcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcclxudHlwZSBUeXBlZEV2ZW50SGFuZGxlcjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IGluZmVyIEgsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gTm9uTnVsbGFibGU8SD4gOiBuZXZlcjtcclxuLy8oKFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiAmICgodHlwZTogVCwgaGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSkgZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBpbmZlciBIKSA9PiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSCA6IEZ1bmN0aW9uKSAvKiYgKFQgZXh0ZW5kcyBrZXlvZiBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXA/IEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcFtUXSA6IChlOiBFdmVudCkgPT4gdm9pZCkqLztcclxuXHJcbnR5cGUgUGFyYW1ldGVyczI8VCBleHRlbmRzIChFdmVudExpc3RlbmVyT2JqZWN0IHwgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpPiA9XHJcbiAgICBUIGV4dGVuZHMgRXZlbnRMaXN0ZW5lck9iamVjdCA/IFBhcmFtZXRlcnM8VFtcImhhbmRsZUV2ZW50XCJdPiA6XHJcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcclxuXHJcblxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYXR0YWNoaW5nIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW55ICpub24tUHJlYWN0KiBlbGVtZW50LCBhbmQgcmVtb3ZpbmcgaXQgd2hlbiB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBob29rIHVubW91bnRzLiBUaGUgY2FsbGJhY2sgZG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXHJcbiAqIFxyXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcclxuICogXHJcbiAqIGB1c2VFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJpbnB1dFwiKTxJbnB1dEV2ZW50PihlID0+IHt9KWBcclxuICogXHJcbiAqIFRoZSB0eXBlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBidXQgbmFycm93cyBkb3duIHRoZSB0eXBlIGZyb20gXCJhIHVuaW9uIG9mIGFsbCBldmVudHNcIiB0byB3aGF0ZXZlciB5b3Ugc3BlY2lmeSwgYW5kIGVycm9ycyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gKiBcclxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuIFxyXG4gKiBJdCB0YWtlcyBkaWZmZXJlbnQgZXZlbnQgc3RyaW5nIHR5cGVzIChvbkV2ZW50IHZzIG9uZXZlbnQpLlxyXG4gKiBcclxuICogQHBhcmFtIHRhcmdldCBBICpub24tUHJlYWN0KiBub2RlIHRvIGF0dGFjaCB0aGUgZXZlbnQgdG8uXHJcbiAqIEByZXR1cm5zXHJcbiAqICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xyXG5cclxuICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXHJcbiAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxyXG4gICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cclxuICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXHJcblxyXG4gICAgbGV0IHN0YWJsZUhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlciA/PyAoKCkgPT4geyB9KSkgYXMgRXZlbnRMaXN0ZW5lcjtcclxuICAgIGlmIChoYW5kbGVyID09IG51bGwpXHJcbiAgICAgICAgc3RhYmxlSGFuZGxlciA9IG51bGw7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3RhYmxlSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cclxuICogXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gbW9kaWZ5IGEgc2V0IG9mIHByb3BzIHRvIGFwcGx5IHRoaXMgaGFuZGxlci5cclxuICogXHJcbiAqIEZvciB0eXBpbmcgcmVhc29ucywgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdCBpbnRvIHR3by4gIFVzYWdlIGlzIGxpa2UgdGhlIGZvbGxvd2luZzpcclxuICogXHJcbiAqIGBgYFxyXG4gKiBjb25zdCB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfSA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PigpKFwib25Nb3VzZURvd25cIiwgZSA9PiB7ICB9KTtcclxuICogY29uc3QgZGl2UHJvcHMgPSB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzKHByb3BzKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxIYW5kbGVyPEVsZW1lbnRUeXBlIGV4dGVuZHMgKEhUTUxFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXBdIHwgU1ZHRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXBdKT4oKSB7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgaC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIGtleW9mIFByZWFjdERPTUF0dHJpYnV0ZXM+Pih0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IE5vbk51bGxhYmxlPGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YWJsZUhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFbGVtZW50VHlwZT4oeyBbdHlwZV06IHN0YWJsZUhhbmRsZXIgfSBhcyB7IFtLIGluIEV2ZW50VHlwZV06IHR5cGVvZiBoYW5kbGVyIH0sIHByb3BzKSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT47XHJcbiAgICAgICAgfSwgW3R5cGVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9O1xyXG5cclxuICAgIH0sIFtdKTtcclxufVxyXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2luZXJ0JywgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAgICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAgICovXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW5zaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc31cbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnRSb290YCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IHN1YnRyZWUsIGkuZS4gYSBET00gc3VidHJlZSB3aG9zZSByb290IGVsZW1lbnQgaGFzIGFuIGBpbmVydGBcbiAgICAgKiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBJdHMgbWFpbiBmdW5jdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAgICogICBzdWJ0cmVlLiBUaGUgYG1ha2VTdWJ0cmVlVW5mb2N1c2FibGUoKWAgbWV0aG9kIGhhbmRsZXMgY29sbGVjdGluZyBgSW5lcnROb2RlYHMgdmlhIHJlZ2lzdGVyaW5nXG4gICAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAgICogICBpbnN0YW5jZSBleGlzdHMgZm9yIGVhY2ggZm9jdXNhYmxlIG5vZGUgd2hpY2ggaGFzIGF0IGxlYXN0IG9uZSBpbmVydCByb290IGFzIGFuIGFuY2VzdG9yLlxuICAgICAqXG4gICAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICAgKiAgIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGZyb20gdGhlIHJvb3Qgbm9kZSkuIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgZGVzdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgdGhlXG4gICAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICAgKi9cblxuICAgIHZhciBJbmVydFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290RWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRSb290KTtcblxuICAgICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Tm9kZT59XG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgICAgLy8gICAgbmVlZCBldmVuIG1vcmUgY2FzdHMgdGhyb3VnaG91dCB0aGlzIGNvZGUuIEFsbCBiZXRzIGFyZSBvZmYgaWYgYW5cbiAgICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgICAvLyAgICB0byBrbm93IHdoaWNoIHByb3BlcnRpZXMgd2UncmUgc2V0dGluZy5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0Tm9kZSBtYXkgYmUgaW4gc2hhZG93IERPTSwgc28gZmluZCBpdHMgbmVhcmVzdCBzaGFkb3dSb290IHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudC5cbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByb290ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnROb2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYmx1cigpIHdpbGwgbm90IGFjdHVhbGx5IG1vdmUgdGhlIGZvY3VzLlxuICAgICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5yZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKGluZXJ0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VTdWJ0cmVlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bm1hbmFnZU5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHNhdmVkSW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25NdXRhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgIC8vIFVuLW1hbmFnZSByZW1vdmVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGlzZSBpbmVydCBub2RlIGlmIHRhYmluZGV4IGNoYW5nZXNcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBuZXcgaW5lcnQgcm9vdCBpcyBhZGRlZCwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMgYW5kIG1ha2Ugc3VyZSBpdCBrbm93cyBhYm91dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydFN1YnJvb3QuX21hbmFnZU5vZGUobWFuYWdlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9zdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcmlhSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW47XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgICAqXG4gICAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgQSBmb2N1c2FibGUgZWxlbWVudCB0byBiZSBtYWRlIGluZXJ0LlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTYXZlIGFueSBwcmlvciB0YWJpbmRleCBpbmZvIGFuZCBtYWtlIHRoaXMgbm9kZSB1bnRhYmJhYmxlXG4gICAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBgZGVsZXRlYCB0byByZXN0b3JlIG5hdGl2ZSBmb2N1cyBtZXRob2QuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICAgIHRoaXMuX25vZGUgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCwgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGl0IHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdGhyb3dJZkRlc3Ryb3llZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgICAvKiogU2F2ZSB0aGUgZXhpc3RpbmcgdGFiaW5kZXggdmFsdWUgYW5kIG1ha2UgdGhlIG5vZGUgdW50YWJiYWJsZSBhbmQgdW5mb2N1c2FibGUgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgICAqIHNvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFJbmVydE5vZGV9ICovdGhpcy5fZGVzdHJveWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9udW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRhYkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnROb2RlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE1hbmFnZXIpO1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgICAqIEB0eXBlIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgaW5lcnQgc3R5bGUuXG4gICAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb25Eb2N1bWVudExvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICAgIGtleTogJ3NldEluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLnNldChyb290LCBpbmVydFJvb3QpO1xuICAgICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZXJ0Um9vdChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAgICogYmUgYWRkZWQgdG8gaXRzIHNldCBvZiBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnROb2RlfSBpbmVydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5zZXQobm9kZSwgaW5lcnROb2RlKTtcblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgICAqIG5vZGUgZnJvbSB0aGUgSW5lcnRNYW5hZ2VyJ3Mgc2V0IG9mIG1hbmFnZWQgbm9kZXMgaWYgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudExvYWRlZCgpIHtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfd2F0Y2hGb3JJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnQgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24gKCFIVE1MRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZnkgaWYgU2hhZG93RG9tIHYxIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhfZGlzdHJpYnV0ZWROb2Rlc1tfaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAgIC8vIGVsZW1lbnQsIG5vciBhIDxzaGFkb3c+IGVsZW1lbnQgcmVjdXJzZSBub3JtYWxseS5cbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoY2hpbGQsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlI2luZXJ0LXN0eWxlLCBsaW5rI2luZXJ0LXN0eWxlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cblxuICAgIGlmICghSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZXJ0KSB7XG4gICAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KSgpO1xuXG59KSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgQmxvY2tpbmdFbGVtZW50c2AgbWFuYWdlcyBhIHN0YWNrIG9mIGVsZW1lbnRzIHRoYXQgaW5lcnQgdGhlIGludGVyYWN0aW9uXG4gKiBvdXRzaWRlIHRoZW0uIFRoZSB0b3AgZWxlbWVudCBpcyB0aGUgaW50ZXJhY3RpdmUgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gKiBUaGUgc3RhY2sgY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgbWV0aG9kcyBgcHVzaCwgcmVtb3ZlLCBwb3BgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NraW5nRWxlbWVudHMge1xuICAvKipcbiAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gVGhpcyBlbXB0aWVzXG4gICAqIHRoZSBibG9ja2luZyBlbGVtZW50c1xuICAgKi9cbiAgZGVzdHJ1Y3RvcigpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9wIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICB0b3A6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmcgZWxlbWVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGVcbiAgICogZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgdG9wIGJsb2NraW5nIGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAqL1xuICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBhIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgZXh0ZW5kcyBEb2N1bWVudCB7XG4gICRibG9ja2luZ0VsZW1lbnRzOiBCbG9ja2luZ0VsZW1lbnRzO1xufVxuXG4oKCkgPT4ge1xuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHByb3BlcnRpZXMgKi9cbiAgY29uc3QgX2Jsb2NraW5nRWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2FscmVhZHlJbmVydEVsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF90b3BFbFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3NpYmxpbmdzVG9SZXN0b3JlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9wYXJlbnRNTyA9IFN5bWJvbCgpO1xuXG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgc3RhdGljIG1ldGhvZHMgKi9cbiAgY29uc3QgX3RvcENoYW5nZWQgPSBTeW1ib2woKTtcbiAgY29uc3QgX3N3YXBJbmVydGVkU2libGluZyA9IFN5bWJvbCgpO1xuICBjb25zdCBfaW5lcnRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0UGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiA9IFN5bWJvbCgpO1xuICBjb25zdCBfaXNJbmVydGFibGUgPSBTeW1ib2woKTtcbiAgY29uc3QgX2hhbmRsZU11dGF0aW9ucyA9IFN5bWJvbCgpO1xuXG4gIGludGVyZmFjZSBJbmVydGFibGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgaW5lcnQ/OiBib29sZWFuO1xuICB9XG5cbiAgaW50ZXJmYWNlIEludGVybmFsU3RhdGUge1xuICAgIFtfc2libGluZ3NUb1Jlc3RvcmVdOiBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPjtcbiAgICBbX3BhcmVudE1PXTogTXV0YXRpb25PYnNlcnZlcjtcbiAgfVxuICBpbnRlcmZhY2UgSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgSW50ZXJuYWxTdGF0ZSB7fVxuICBpbnRlcmZhY2UgTWF5YmVIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBQYXJ0aWFsPEludGVybmFsU3RhdGU+IHt9XG5cbiAgLyoqXG4gICAqIFNoYWR5RE9NIHNoYWR5IHJvb3RzIGxvb2sgYSBsb3QgbGlrZSByZWFsIFNoYWRvd1Jvb3RzLiBUaGUgX19zaGFkeSBwcm9wZXJ0eVxuICAgKiBnaXZlcyB0aGVtIGF3YXksIHRob3VnaC5cbiAgICovXG4gIGludGVyZmFjZSBNYXliZVNoYWR5Um9vdCBleHRlbmRzIEVsZW1lbnQge1xuICAgIF9fc2hhZHk6IHVua25vd247XG4gICAgaG9zdDogRWxlbWVudDtcbiAgfVxuXG4gIGNsYXNzIEJsb2NraW5nRWxlbWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tpbmdFbGVtZW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2Jsb2NraW5nRWxlbWVudHNdOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwYXJlbnRzIG9mIHRoZSB0b3AgZWxlbWVudCwgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGl0c2VsZiB1cCB0byBib2R5LiBXaGVuIHRvcCBjaGFuZ2VzLCB0aGUgb2xkIHRvcCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAqIGZyb20gdGhlIGRvY3VtZW50LCBzbyB3ZSBuZWVkIHRvIG1lbW9pemUgdGhlIGluZXJ0ZWQgcGFyZW50cycgc2libGluZ3NcbiAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZWlyIGluZXJ0ZW5lc3Mgd2hlbiB0b3AgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BFbFBhcmVudHNdOiBIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW5lcnQgYmVmb3JlIHRoZSBmaXJzdCBibG9ja2luZyBlbGVtZW50IGlzXG4gICAgICogcHVzaGVkLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG5ldyBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPigpO1xuXG4gICAgZGVzdHJ1Y3RvcigpOiB2b2lkIHtcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgaW5lcnRuZXNzLlxuICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10odGhpc1tfdG9wRWxQYXJlbnRzXSk7XG4gICAgICAvLyBOb3RlIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBwcm9wZXJ0aWVzIG51bGxhYmxlIG9uIHRoZSBjbGFzcyxcbiAgICAgIC8vIHNpbmNlIHRoZW4gd2UnZCBuZWVkIG5vbi1udWxsIGNhc3RzIGluIG1hbnkgcGxhY2VzLiBDYWxsaW5nIGEgbWV0aG9kIG9uXG4gICAgICAvLyBhIEJsb2NraW5nRWxlbWVudHMgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkZXN0cnVjdG9yIHdpbGwgcmVzdWx0IGluIGFuXG4gICAgICAvLyBleGNlcHRpb24uXG4gICAgICBjb25zdCBudWxsYWJsZSA9IHRoaXMgYXMgdW5rbm93biBhcyB7XG4gICAgICAgIFtfYmxvY2tpbmdFbGVtZW50c106IG51bGw7XG4gICAgICAgIFtfdG9wRWxQYXJlbnRzXTogbnVsbDtcbiAgICAgICAgW19hbHJlYWR5SW5lcnRFbGVtZW50c106IG51bGw7XG4gICAgICB9O1xuICAgICAgbnVsbGFibGVbX2Jsb2NraW5nRWxlbWVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW190b3BFbFBhcmVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB0b3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCBlbGVtcyA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdO1xuICAgICAgcmV0dXJuIGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IHRoaXMudG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgd2UnbGwgYnJpbmcgaXQgdG8gdGhlIHRvcC5cbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0oZWxlbWVudCk7XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgaSA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uc3BsaWNlKGksIDEpO1xuICAgICAgLy8gVG9wIGNoYW5nZWQgb25seSBpZiB0aGUgcmVtb3ZlZCBlbGVtZW50IHdhcyB0aGUgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoaSA9PT0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKHRoaXMudG9wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgdG9wICYmIHRoaXMucmVtb3ZlKHRvcCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYGluZXJ0YCB0byBhbGwgZG9jdW1lbnQgZWxlbWVudHMgZXhjZXB0IHRoZSBuZXcgdG9wIGVsZW1lbnQsIGl0c1xuICAgICAqIHBhcmVudHMsIGFuZCBpdHMgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BDaGFuZ2VkXShuZXdUb3A6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZXxudWxsKTogdm9pZCB7XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGNvbnN0IG9sZFBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgLy8gTm8gbmV3IHRvcCwgcmVzZXQgb2xkIHRvcCBpZiBhbnkuXG4gICAgICBpZiAoIW5ld1RvcCkge1xuICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzKTtcbiAgICAgICAgdG9LZWVwSW5lcnQuY2xlYXIoKTtcbiAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1BhcmVudHMgPSB0aGlzW19nZXRQYXJlbnRzXShuZXdUb3ApO1xuICAgICAgLy8gTmV3IHRvcCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBtYWluIGRvY3VtZW50IVxuICAgICAgaWYgKG5ld1BhcmVudHNbbmV3UGFyZW50cy5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb24tY29ubmVjdGVkIGVsZW1lbnQgY2Fubm90IGJlIGEgYmxvY2tpbmcgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ2FzdCBoZXJlIGJlY2F1c2Ugd2Uga25vdyB3ZSdsbCBjYWxsIF9pbmVydFNpYmxpbmdzIG9uIG5ld1BhcmVudHNcbiAgICAgIC8vIGJlbG93LlxuICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IG5ld1BhcmVudHMgYXMgQXJyYXk8SGFzSW50ZXJuYWxTdGF0ZT47XG5cbiAgICAgIGNvbnN0IHRvU2tpcCA9IHRoaXNbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKG5ld1RvcCk7XG5cbiAgICAgIC8vIE5vIHByZXZpb3VzIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKCFvbGRQYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IG9sZFBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBqID0gbmV3UGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgLy8gRmluZCBjb21tb24gcGFyZW50LiBJbmRleCAwIGlzIHRoZSBlbGVtZW50IGl0c2VsZiAoc28gc3RvcCBiZWZvcmUgaXQpLlxuICAgICAgd2hpbGUgKGkgPiAwICYmIGogPiAwICYmIG9sZFBhcmVudHNbaV0gPT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgaS0tO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICAvLyBJZiB1cCB0aGUgcGFyZW50cyB0cmVlIHRoZXJlIGFyZSAyIGVsZW1lbnRzIHRoYXQgYXJlIHNpYmxpbmdzLCBzd2FwXG4gICAgICAvLyB0aGUgaW5lcnRlZCBzaWJsaW5nLlxuICAgICAgaWYgKG9sZFBhcmVudHNbaV0gIT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgdGhpc1tfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRQYXJlbnRzW2ldLCBuZXdQYXJlbnRzW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgb2xkIHBhcmVudHMgc2libGluZ3MgaW5lcnRuZXNzLlxuICAgICAgaSA+IDAgJiYgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cy5zbGljZSgwLCBpKSk7XG4gICAgICAvLyBNYWtlIG5ldyBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0LlxuICAgICAgaiA+IDAgJiYgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cy5zbGljZSgwLCBqKSwgdG9Ta2lwLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyBpbmVydG5lc3MgYmV0d2VlbiB0d28gc2libGluZyBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19zd2FwSW5lcnRlZFNpYmxpbmddKFxuICAgICAgICBvbGRJbmVydDogSGFzSW50ZXJuYWxTdGF0ZSwgbmV3SW5lcnQ6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2libGluZ3NUb1Jlc3RvcmUgPSBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgLy8gb2xkSW5lcnQgaXMgbm90IGNvbnRhaW5lZCBpbiBzaWJsaW5ncyB0byByZXN0b3JlLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgICAvLyBpZiBpdCdzIGluZXJ0YWJsZSBhbmQgaWYgYWxyZWFkeSBpbmVydC5cbiAgICAgIGlmICh0aGlzW19pc0luZXJ0YWJsZV0ob2xkSW5lcnQpICYmICFvbGRJbmVydC5pbmVydCkge1xuICAgICAgICBvbGRJbmVydC5pbmVydCA9IHRydWU7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmFkZChvbGRJbmVydCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBuZXdJbmVydCB3YXMgYWxyZWFkeSBiZXR3ZWVuIHRoZSBzaWJsaW5ncyB0byByZXN0b3JlLCBpdCBtZWFucyBpdCBpc1xuICAgICAgLy8gaW5lcnRhYmxlIGFuZCBtdXN0IGJlIHJlc3RvcmVkLlxuICAgICAgaWYgKHNpYmxpbmdzVG9SZXN0b3JlLmhhcyhuZXdJbmVydCkpIHtcbiAgICAgICAgbmV3SW5lcnQuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuZGVsZXRlKG5ld0luZXJ0KTtcbiAgICAgIH1cbiAgICAgIG5ld0luZXJ0W19wYXJlbnRNT10gPSBvbGRJbmVydFtfcGFyZW50TU9dO1xuICAgICAgbmV3SW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHNpYmxpbmdzVG9SZXN0b3JlO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgaW5lcnRuZXNzIHRvIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10oZWxlbWVudHM6IEhhc0ludGVybmFsU3RhdGVbXSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG1vID0gZWxlbWVudFtfcGFyZW50TU9dO1xuICAgICAgICBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2libGluZyBvZiBzaWJsaW5ncykge1xuICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5lcnRzIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMgZXhjZXB0IHRoZSBlbGVtZW50cyB0byBza2lwLiBTdG9yZXNcbiAgICAgKiB0aGUgaW5lcnRlZCBzaWJsaW5ncyBpbnRvIHRoZSBlbGVtZW50J3Mgc3ltYm9sIGBfc2libGluZ3NUb1Jlc3RvcmVgLlxuICAgICAqIFBhc3MgYHRvS2VlcEluZXJ0YCB0byBjb2xsZWN0IHRoZSBhbHJlYWR5IGluZXJ0IGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX2luZXJ0U2libGluZ3NdKFxuICAgICAgICBlbGVtZW50czogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10sIHRvU2tpcDogU2V0PEhUTUxFbGVtZW50PnxudWxsLFxuICAgICAgICB0b0tlZXBJbmVydDogU2V0PEhUTUxFbGVtZW50PnxudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIGVsZW1lbnQgaXMgbm90IGEgRG9jdW1lbnQsIHNvIGl0IG11c3QgaGF2ZSBhIHBhcmVudE5vZGUuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSE7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGNoaWxkcmVuW2pdIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAvLyBTa2lwIHRoZSBpbnB1dCBlbGVtZW50LCBpZiBub3QgaW5lcnRhYmxlIG9yIHRvIGJlIHNraXBwZWQuXG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGVsZW1lbnQgfHwgIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAodG9Ta2lwICYmIHRvU2tpcC5oYXMoc2libGluZykpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbGxlY3RlZCBzaW5jZSBhbHJlYWR5IGluZXJ0ZWQuXG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgc2libGluZ3MgdGhhdCB3ZXJlIGluZXJ0ZWQuXG4gICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IGluZXJ0ZWRTaWJsaW5ncztcbiAgICAgICAgLy8gT2JzZXJ2ZSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlbiBtdXRhdGlvbnMgb24gdGhlIHBhcmVudC5cbiAgICAgICAgY29uc3QgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW19oYW5kbGVNdXRhdGlvbnNdLmJpbmQodGhpcykpO1xuICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSBtbztcbiAgICAgICAgbGV0IHBhcmVudFRvT2JzZXJ2ZSA9IHBhcmVudDtcbiAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCB0aGVuIG91ciBwYXJlbnQgY291bGQgYmUgYVxuICAgICAgICAvLyBzaGFkeSByb290LCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBhY3RzIGxpa2UgYSBTaGFkb3dSb290LCBidXQgaXNuJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgYSBub2RlIGluIHRoZSByZWFsIERPTS4gT2JzZXJ2ZSB0aGUgcmVhbCBET00gcGFyZW50IGluc3RlYWQuXG4gICAgICAgIGNvbnN0IG1heWJlU2hhZHlSb290ID0gcGFyZW50VG9PYnNlcnZlIGFzIE1heWJlU2hhZHlSb290O1xuICAgICAgICBpZiAobWF5YmVTaGFkeVJvb3QuX19zaGFkeSAmJiBtYXliZVNoYWR5Um9vdC5ob3N0KSB7XG4gICAgICAgICAgcGFyZW50VG9PYnNlcnZlID0gbWF5YmVTaGFkeVJvb3QuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBtby5vYnNlcnZlKHBhcmVudFRvT2JzZXJ2ZSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBuZXdseSBhZGRlZC9yZW1vdmVkIG5vZGVzIGJ5IHRvZ2dsaW5nIHRoZWlyIGluZXJ0bmVzcy5cbiAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgY3VycmVudCB0b3AgQmxvY2tpbmcgRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAqIG5vdGlmeWluZyBhbmQgcmVtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaGFuZGxlTXV0YXRpb25zXShtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10pOiB2b2lkIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgc2hhZG93Um9vdCwgZ2V0IGl0cyBob3N0IGFzIHdlIHNraXAgc2hhZG93Um9vdHMgd2hlblxuICAgICAgICAvLyBjb21wdXRpbmcgX3RvcEVsUGFyZW50cy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG11dGF0aW9uLnRhcmdldCBhcyBTaGFkb3dSb290KS5ob3N0IHx8IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5ID9cbiAgICAgICAgICAgIHBhcmVudHMubGVuZ3RoIDpcbiAgICAgICAgICAgIHBhcmVudHMuaW5kZXhPZih0YXJnZXQgYXMgSGFzSW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRDaGlsZCA9IHBhcmVudHNbaWR4IC0gMV07XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IGluZXJ0ZWRDaGlsZFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuXG4gICAgICAgIC8vIFRvIHJlc3RvcmUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGluZXJ0ZWRDaGlsZCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdEZXRlY3RlZCByZW1vdmFsIG9mIHRoZSB0b3AgQmxvY2tpbmcgRWxlbWVudC4nKTtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmVydGVkU2libGluZ3MuaGFzKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuZGVsZXRlKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGluZXJ0LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24uYWRkZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKCF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBpbmVydGFibGUuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaXNJbmVydGFibGVdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gZmFsc2UgPT09IC9eKHN0eWxlfHRlbXBsYXRlfHNjcmlwdCkkLy50ZXN0KGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG5ld1BhcmVudHMgb2YgYW4gZWxlbWVudCwgc3RhcnRpbmcgZnJvbSBlbGVtZW50XG4gICAgICogKGluY2x1ZGVkKSB1cCB0byBgZG9jdW1lbnQuYm9keWAgKGV4Y2x1ZGVkKS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXRQYXJlbnRzXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICBsZXQgY3VycmVudDogSFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWQgPSBlbGVtZW50O1xuICAgICAgLy8gU3RvcCB0byBib2R5LlxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAvLyBTa2lwIHNoYWRvdyByb290cy5cbiAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYWRvd0RvbSB2MVxuICAgICAgICBpZiAoY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHNsb3RzIGZyb20gZGVlcGVzdCBzbG90IHRvIHRvcC5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggb24gdGhlIHRvcCBzbG90LlxuICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgIChjdXJyZW50IGFzIE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHNoYWRvdyByb290LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTpcbiAgICAgICAgU2V0PEhUTUxFbGVtZW50PnxudWxsIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgbGV0IGk7XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBub2RlcztcbiAgICAgIGNvbnN0IHNsb3RzID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICBpZiAoc2xvdHMubGVuZ3RoICYmIHNsb3RzWzBdLmFzc2lnbmVkTm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMgPSBzbG90c1tpXS5hc3NpZ25lZE5vZGVzKHtcbiAgICAgICAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbal0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hZGQobm9kZXNbal0gYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIHNlYXJjaCBmb3IgPGNvbnRlbnQ+LlxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAoZG9jdW1lbnQgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgPVxuICAgICAgbmV3IEJsb2NraW5nRWxlbWVudHNJbXBsKCk7XG59KSgpO1xuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsLCB3aGVuIGNhbGxlZCwgZm9yY2UgdGhlIGNvbXBvbmVudFxuICogdGhhdCB1c2VzIHRoaXMgaG9vayB0byByZS1yZW5kZXIgaXRzZWxmLlxuICogXG4gKiBJdCdzIGEgYml0IHNtZWxseSwgc28gYmVzdCB0byB1c2Ugc3BhcmluZ2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgWywgc2V0XSA9IHVzZVN0YXRlKDApO1xuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50U2l6ZSwgdXNlRWxlbWVudFNpemUgfSBmcm9tIFwiLi91c2UtZWxlbWVudC1zaXplXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5cbi8vZXhwb3J0IHR5cGUgQmxvY2tGbG93RGlyZWN0aW9uID0gXCJkb3dud2FyZHNcIiB8IFwibGVmdHdhcmRzXCIgfCBcInJpZ2h0d2FyZHNcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsRGlyZWN0aW9uID0gXCJsdHJcIiB8IFwicnRsXCIgfCBcInR0YlwiIHwgXCJidHRcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsU2l6ZSA9IFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI7XG5cbmV4cG9ydCB0eXBlIExvZ2ljYWxPcmllbnRhdGlvbiA9IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbi8vZXhwb3J0IHR5cGUgTGluZU9yaWVudGF0aW9uID0gXCJ1cHJpZ2h0XCIgfCBcImxlZnRyaWdodFwiIHwgXCJkb3ducmlnaHRcIiB8IFwicmlnaHRyaWdodFwiO1xuXG50eXBlIFdyaXRpbmdNb2RlID0gXCJob3Jpem9udGFsLXRiXCIgfCBcInZlcnRpY2FsLWxyXCIgfCBcInNpZGV3YXlzLXJsXCIgfCBcInZlcnRpY2FsLXJsXCIgfCBcInNpZGV3YXlzLWxyXCI7XG50eXBlIERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiO1xudHlwZSBUZXh0T3JpZW50YXRpb24gPSBcIm1peGVkXCIgfCBcInVwcmlnaHRcIiB8IFwic2lkZXdheXNcIjtcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZTxUIGV4dGVuZHMgc3RyaW5nPihzdHI6IFQpOiBDYXBpdGFsaXplPFQ+IHtcbiAgICByZXR1cm4gKHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKSkgYXMgQ2FwaXRhbGl6ZTxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyB7XG4gICAgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPyhpbmZvOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxFbGVtZW50U2l6ZSB7XG4gICAgY2xpZW50SW5saW5lU2l6ZTogbnVtYmVyO1xuICAgIHNjcm9sbElubGluZVNpemU6IG51bWJlcjtcbiAgICBvZmZzZXRJbmxpbmVTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50QmxvY2tTaXplOiBudW1iZXI7XG4gICAgc2Nyb2xsQmxvY2tTaXplOiBudW1iZXI7XG4gICAgb2Zmc2V0QmxvY2tTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50SW5saW5lSW5zZXQ6IG51bWJlcjtcbiAgICBzY3JvbGxJbmxpbmVJbnNldDogbnVtYmVyO1xuICAgIG9mZnNldElubGluZUluc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50QmxvY2tJbnNldDogbnVtYmVyO1xuICAgIHNjcm9sbEJsb2NrSW5zZXQ6IG51bWJlcjtcbiAgICBvZmZzZXRCbG9ja0luc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5zcGVjdHMgdGhlIGVsZW1lbnQncyBzdHlsZSBhbmQgZGV0ZXJtaW5lcyB0aGUgbG9naWNhbCBkaXJlY3Rpb24gdGhhdCB0ZXh0IGZsb3dzLlxuICogXG4gKiBDZXJ0YWluIENTUyBwcm9wZXJ0aWVzLCBsaWtlIGBibG9jay1zaXplYCwgcmVzcGVjdCB0aGUgY3VycmVudCB3cml0aW5nIG1vZGUgYW5kIHRleHQgZGlyZWN0aW9uLlxuICogQnV0IGB0cmFuc2Zvcm1gLCBgY2xpcGAsIGV0Yy4gZG9uJ3QuXG4gKiBcbiAqIFRoaXMgaXMgcHJvdmlkZWQgc28gdGhhdCBDU1MgcHJvcGVydGllcyBjYW4gY29uc2lzdGVudGx5IHVzZSB0aG9zZSBsb2dpY2FsIHByb3BlcnRpZXMuXG4gKiBcbiAqIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMvI2xvZ2ljYWwtdG8tcGh5c2ljYWxcbiAqIFxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gKiAqIGBnZXRMb2dpY2FsRGlyZWN0aW9uYDogcmV0cmlldmVzIGEgYExvZ2ljYWxEaXJlY3Rpb25JbmZvYCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuIChGdW5jdGlvbiBpcyBjb25zdGFudCBiZXR3ZWVuIHJlbmRlcnMpXG4gKiAqIGBjb252ZXJ0RWxlbWVudFNpemVgOiBXaGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlRWxlbWVudFNpemVgLCBhbGxvd3MgeW91IHRvIHJldHJpZXZlIHRoZSBsb2dpY2FsIHNpemUgb2YgYW4gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBwaHlzaWNhbCBzaXplLiBcbiAqICogYGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbmA6IEJhc2VkIG9uIHRoZSBjdXJyZW50IGRpcmVjdGlvbiwgY29udmVydHMgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiIHRvIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiLlxuICogKiBgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbmA6ICBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiIHRvIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvZ2ljYWxEaXJlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHsgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIH06IFVzZUxvZ2ljYWxEaXJlY3Rpb25QYXJhbWV0ZXJzKTogVXNlTG9naWNhbERpcmVjdGlvblJldHVyblR5cGU8VD4ge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTG9naWNhbERpcmVjdGlvblwiLCBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldENvbXB1dGVkU3R5bGVzLCBzZXRDb21wdXRlZFN0eWxlc10gPSB1c2VQYXNzaXZlU3RhdGU8Q1NTU3R5bGVEZWNsYXJhdGlvbiB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xuXG5cbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XG4gICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNldENvbXB1dGVkU3R5bGVzKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byByZWZyZXNoIHdoaWNoIHdyaXRpbmcgbW9kZSB3ZSBoYXZlIG9uY2UgbW91bnRlZC5cbiAgICAvLyAgIEEuIFRoZXJlJ3Mgbm8gd2F5IHRvIHdhdGNoIGZvciBDU1Mgc3R5bGUgY2hhbmdlc1xuICAgIC8vICAgQi4gQ2FsbGluZyBnZXRDb21wdXRlZFN0eWxlIGFmdGVyIGV2ZXJ5IHJlbmRlciBmb3IgZXZlcnkgZWxlbWVudCBnZXRzIGV4cGVuc2l2ZSBmYXN0IGFuZFxuICAgIC8vICAgQy4gSXMgbm90IG5lY2Vzc2FyeSBmb3IgbW9zdCB1c2UgY2FzZXMgdGhhdCB3aWxsIG5ldmVyIHN3aXRjaCB3cml0aW5nLW1vZGUgd2l0aGluIGEgc2luZ2xlIGNvbXBvbmVudFxuICAgIC8vICAgICAgKFRob3NlIHRoYXQgZG8gd2lsbCBuZWVkIHRvIG1vdW50IGFuZCB1bm1vdW50IHRoZSBjb21wb25lbnQgdGhhdCB1c2VzIGl0KVxuICAgIC8vXG4gICAgLy8gQXMgYSBzb2x1dGlvbiwgaGVyZSdzIGEgY2hlYXAgd29ya2Fyb3VuZCB0aGF0IGNoZWNrcyB3aGVuIHRoZSBlbGVtZW50J3Mgc2l6ZSBoYXMgY2hhbmdlZCxcbiAgICAvLyBhbmQgaWYgc28sIHRlc3RzIGlmIHRoZSB3cml0aW5nIG1vZGUgaGFzIGNoYW5nZWQgdG9vLlxuICAgIC8vXG4gICAgLy8gVGhpcyB3aWxsIHdvcmsgZm9yIGF0IGxlYXN0IHNvbWUgbnVtYmVyIG9mIGNhc2VzLCBidXQgYSBiZXR0ZXIgc29sdXRpb24gaXMgc3RpbGwgbmVlZGVkLlxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcyB9ID0gdXNlRWxlbWVudFNpemU8VD4oeyBvblNpemVDaGFuZ2U6IHVzZUNhbGxiYWNrKF8gPT4gb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPy4oZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKSksIFtdKSB9KVxuXG4gICAgY29uc3QgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZXMoKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGVzKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gY29tcHV0ZWRTdHlsZXMud3JpdGluZ01vZGUgYXMgV3JpdGluZ01vZGU7XG4gICAgICAgICAgICBsZXQgZCA9IGNvbXB1dGVkU3R5bGVzLmRpcmVjdGlvbiBhcyBEaXJlY3Rpb247XG4gICAgICAgICAgICBjb25zdCB0ID0gY29tcHV0ZWRTdHlsZXMudGV4dE9yaWVudGF0aW9uIGFzIFRleHRPcmllbnRhdGlvbjtcblxuICAgICAgICAgICAgaWYgKHQgPT0gXCJ1cHJpZ2h0XCIpXG4gICAgICAgICAgICAgICAgZCA9IFwibHRyXCI7XG5cbiAgICAgICAgICAgIHJldHVybiAoeyAuLi5Xcml0aW5nTW9kZXNbdyB8fCBcImhvcml6b250YWwtdGJcIl1bZCB8fCBcImx0clwiXSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIFtdKVxuXG4gICAgLy9jb25zdCBbZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHNldExvZ2ljYWxEaXJlY3Rpb25JbmZvXSA9IHVzZVBhc3NpdmVTdGF0ZTxMb2dpY2FsRGlyZWN0aW9uSW5mbz4ob25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcblxuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBlbGVtZW50T3JpZW50YXRpb24pXG4gICAgICAgICAgICByZXR1cm4gXCJpbmxpbmVcIjtcbiAgICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb252ZXJ0VG9QaHlzaWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcblxuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmJsb2NrRGlyZWN0aW9uID8/IFwidHRiXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVsyXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5pbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIilbMF0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5pbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsU2lkZSA9IHVzZUNhbGxiYWNrKChzaWRlOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcInR0YlwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwiYnR0XCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcImx0clwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImx0clwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHJldHVybiBcImlubGluZS1zdGFydFwiO1xuXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZWxlbWVudE9yaWVudGF0aW9uID09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcbiAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5ibG9ja09yaWVudGF0aW9uID09IFwidmVydGljYWxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb252ZXJ0RWxlbWVudFNpemUgPSB1c2VDYWxsYmFjaygoZWxlbWVudFNpemU6IEVsZW1lbnRTaXplLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBMb2dpY2FsRWxlbWVudFNpemUgfCBudWxsID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlubGluZVNpemUsIGJsb2NrU2l6ZSwgaW5saW5lRGlyZWN0aW9uLCBibG9ja0RpcmVjdGlvbiB9ID0gZGlyZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBTaXplIGlzIHJlbGF0aXZlbHkgc2ltcGxlXG4gICAgICAgICAgICBjb25zdCBjbGllbnRJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcblxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG5cbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQmxvY2tTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuXG5cblxuXG4gICAgICAgICAgICBjb25zdCBmMSA9IGdldFBoeXNpY2FsTGVmdFRvcChpbmxpbmVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgZjIgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGlubGluZURpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGYzID0gZ2V0UGh5c2ljYWxMZWZ0VG9wKGJsb2NrRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGY0ID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShibG9ja0RpcmVjdGlvbik7XG5cblxuICAgICAgICAgICBjb25zdCBjbGllbnRJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYyKX1gXSk7XG4gICAgICAgICAgIGNvbnN0IHNjcm9sbElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjIpfWBdKTtcbiAgICAgICAgICAgY29uc3Qgb2Zmc2V0SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYxKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0hICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYyKX1gXSEpKTtcblxuXG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjMpfWBdID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IChlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSEgKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjQpfWBdISkpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tJbnNldCxcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja0luc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrSW5zZXQsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gdXNlUmVmRWxlbWVudFByb3BzKHVzZUVsZW1lbnRTaXplUHJvcHMocHJvcHMpKSwgW10pLFxuICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyxcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpemU6IGNvbnZlcnRFbGVtZW50U2l6ZSxcbiAgICAgICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uLFxuICAgICAgICBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uLFxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZSxcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxTaWRlXG4gICAgfTtcbn1cblxuLy8gUG9zaXRpb24gcmVxdWlyZXMgdXMgdG8gc29tZXRpbWVzIHVzZSBvbmUgcHJvcGVydHkgKGxpa2UgYGxlZnRgKVxuLy8gb3Igc29tZXRpbWVzIHR3byAobGlrZSBgbGVmdGAgKyBgd2lkdGhgKVxuZnVuY3Rpb24gZ2V0UGh5c2ljYWxMZWZ0VG9wKGRpcjogUGh5c2ljYWxEaXJlY3Rpb24pIHsgaWYgKGRpciA9PT0gXCJsdHJcIiB8fCBkaXIgPT0gXCJydGxcIikgcmV0dXJuIFwibGVmdFwiOyByZXR1cm4gXCJ0b3BcIjsgfVxuZnVuY3Rpb24gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwicnRsXCIpIHJldHVybiBcIndpZHRoXCI7IGlmIChkaXIgPT09IFwiYnR0XCIpIHJldHVybiBcImhlaWdodFwiOyByZXR1cm4gbnVsbDsgfVxuXG4vLyBIZWxwZXIgZm9yIGV4dHJhY3RpbmcgaW5mbyBmcm9tIFwibHRyXCIsIFwidHRiXCIsIGV0Yy5cbmNvbnN0IE0gPSB7XG4gICAgdDogXCJ0b3BcIixcbiAgICBiOiBcImJvdHRvbVwiLFxuICAgIGw6IFwibGVmdFwiLFxuICAgIHI6IFwicmlnaHRcIlxufSBhcyBjb25zdDtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTG9naWNhbERpcmVjdGlvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldEVsZW1lbnQ6ICgpID0+IFQgfCBudWxsO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm86ICgpID0+IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBFbGVtZW50U2l6ZSBpbmZvIGZyb20gdXNlRWxlbWVudFNpemUsIGNvbnZlcnRzIGFsbCB0aG9zZSBwaHlzaWNhbCBwcm9wZXJ0aWVzIHRvIHRoZWlyIGxvZ2ljYWwgY291bnRlcnBhcnRzLlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Mb2dpY2FsU2l6ZTogKGVsZW1lbnRTaXplOiBFbGVtZW50U2l6ZSwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBMb2dpY2FsRWxlbWVudFNpemUgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgYFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiYCBpbnRvIGBcImlubGluZVwiIHwgXCJibG9ja1wiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb246IChlbGVtZW50T3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJpbmxpbmVcIiB8IFwiYmxvY2tcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImlubGluZVwiIHwgXCJibG9ja1wiYCBpbnRvIGBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcImBcbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbjogKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgYFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCJgIGludG8gYFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgfCBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCJgXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGNvbnZlcnRUb0xvZ2ljYWxTaWRlOiAoc2lkZTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiO1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgYFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgfCBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCJgIGludG8gYFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCJgXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGNvbnZlcnRUb1BoeXNpY2FsU2lkZTogKHNpZGU6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naWNhbERpcmVjdGlvbkluZm8ge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBnbHlwaCBieSBnbHlwaC4gIEJ5IGZhciB0aGUgbW9zdCBjb21wbGV4IHByb3BlcnR5LlxuICAgICAqIFxuICAgICAqIHxgd3JpdGluZy1tb2RlYHxgZGlyZWN0aW9uYHxSZXN1bHR8XG4gICAgICogfC0tLS0tfC0tLS0tfC0tLS0tfFxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YGx0cmB8YGx0cmB8XG4gICAgICogfGBob3Jpem9udGFsLXRiYHxgcnRsYHxgcnRsYHxcbiAgICAgKiB8YHZlcnRpY2FsLXJsYCAmIGBzaWRld2F5cy1ybGB8YGx0cmB8YHR0YmB8XG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBydGxgfGBidHRgfFxuICAgICAqIHxgdmVydGljYWwtbHJgfGBsdHJgfGB0dGJgfFxuICAgICAqIHxgdmVydGljYWwtbHJgfGBydGxgfGBidHRgfFxuICAgICAqIHxgc2lkZXdheXMtbHJgfGBsdHJgfGBidHRgfFxuICAgICAqIHxgc2lkZXdheXMtbHJgfGBydGxgfGB0dGJgfFxuICAgICAqL1xuICAgIGlubGluZURpcmVjdGlvbjogUGh5c2ljYWxEaXJlY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGlmaWVkIHZlcnNpb24gb2YgYGlubGluZURpcmVjdGlvbmA6XG4gICAgICogXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGlubGluZU9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyB0aGUgZGlyZWN0aW9uIHRleHQgZmxvd3MsIGxpbmUgYnkgbGluZS5cbiAgICAgKiBcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgcnRsYCBmb3IgYHZlcnRpY2FsLXJsYCAmIGBzaWRld2F5cy1ybGAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgbHRyYCBmb3IgYHZlcnRpY2FsLWxyYCAmIGBzaWRld2F5cy1scmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICovXG4gICAgYmxvY2tEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBibG9ja0RpcmVjdGlvbmA6XG4gICAgICogXG4gICAgICogKiBgdmVydGljYWxgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGBob3Jpem9udGFsYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGJsb2NrT3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGhvdyB5b3UgY2FuICpwaHlzaWNhbGx5KiByZWZlciB0byB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCBpbiB0aGUgKmlubGluZSogc2l6ZS5cbiAgICAgKiBcbiAgICAgKiAqIGB3aWR0aGAgZm9yIGBob3Jpem9udGFsLXRiYCwgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb25cbiAgICAgKiAqIGBoZWlnaHRgIGZvciBhbGwgb3RoZXJzXG4gICAgICovXG4gICAgaW5saW5lU2l6ZTogUGh5c2ljYWxTaXplO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICpibG9jayogc2l6ZS5cbiAgICAgKiBcbiAgICAgKiAqIGBoZWlnaHRgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgd2lkdGhgIGZvciBhbGwgb3RoZXJzXG4gICAgICovXG4gICAgYmxvY2tTaXplOiBQaHlzaWNhbFNpemU7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBnbHlwaCwgYXNjZW5kZXJzIHRvIGRlc2NlbmRlcnMgKnBoeXNpY2FsbHkqIGdvOlxuICAgICAqIFxuICAgICAqICogYHR0YmAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxuICAgICAqICogYGx0cmAgZm9yIGBzaWRld2F5cy1scmBcbiAgICAgKi9cbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGl0cyBcImxlZnRcIiBzaWRlICh0aGluayBvZiB0aGlzIHJlbGF0aXZlIHRvIGB3cml0aW5nLW1vZGVgIGJ1dCAqbm90KiByZWxhdGl2ZSB0byBgZGlyZWN0aW9uYCwgb3IgYWx0ZXJuYXRpdmVseSB3aGF0IGB0ZXh0LWFsaWduOiBsZWZ0YCBtZWFucykgdG8gaXRzIFwicmlnaHRcIiBzaWRlICpwaHlzaWNhbGx5KiBnb2VzIGZyb206XG4gICAgICogXG4gICAgICogKiBgbHRyYCBmb3IgYGhvcml6b250YWwtdGJgXG4gICAgICogKiBgdHRiYCBmb3IgYHZlcnRpY2FsLXJsYCwgYHZlcnRpY2FsLWxyYCwgJiBgc2lkZXdheXMtcmxgXG4gICAgICogKiBgYnR0YCBmb3IgYHNpZGV3YXlzLWxyYFxuICAgICAqL1xuICAgIGxlZnRSaWdodERpcmVjdGlvbjogUGh5c2ljYWxEaXJlY3Rpb247XG59XG5cbmNvbnN0IEhvcml6b250YWxUYkx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImx0clwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInR0YlwiLFxuXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgIGJsb2NrT3JpZW50YXRpb246IFwidmVydGljYWxcIixcblxuICAgIGlubGluZVNpemU6IFwid2lkdGhcIixcbiAgICBibG9ja1NpemU6IFwiaGVpZ2h0XCIsXG5cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwibHRyXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInR0YlwiXG59O1xuXG5jb25zdCBIb3Jpem9udGFsVGJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLkhvcml6b250YWxUYkx0cixcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwicnRsXCIsXG59O1xuXG5jb25zdCBWZXJ0aWNhbFJsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwidHRiXCIsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwicnRsXCIsXG5cbiAgICBpbmxpbmVPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgIGJsb2NrT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuXG4gICAgaW5saW5lU2l6ZTogXCJoZWlnaHRcIixcbiAgICBibG9ja1NpemU6IFwid2lkdGhcIixcblxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJ0dGJcIixcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwicnRsXCJcbn07XG5cbmNvbnN0IFZlcnRpY2FsUmxSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsUmxMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImJ0dFwiXG59O1xuXG5cbmNvbnN0IFNpZGV3YXlzUmxMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0geyAuLi5WZXJ0aWNhbFJsTHRyIH07XG5jb25zdCBTaWRld2F5c1JsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbFJ0bCB9O1xuXG5jb25zdCBWZXJ0aWNhbExyTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcImx0clwiLFxufTtcblxuY29uc3QgVmVydGljYWxMclJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uVmVydGljYWxSbFJ0bCxcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5cbmNvbnN0IFNpZGV3YXlzTHRMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsTHJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImJ0dFwiLFxuXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImJ0dFwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJsdHJcIlxufTtcblxuY29uc3QgU2lkZXdheXNMdFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uU2lkZXdheXNMdEx0cixcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwidHRiXCJcbn07XG5cblxuXG5jb25zdCBIb3Jpem9udGFsVGIgPSB7XG4gICAgbHRyOiBIb3Jpem9udGFsVGJMdHIsXG4gICAgcnRsOiBIb3Jpem9udGFsVGJSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFZlcnRpY2FsUmwgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbFJsTHRyLFxuICAgIHJ0bDogVmVydGljYWxSbFJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgVmVydGljYWxMciA9IHtcbiAgICBsdHI6IFZlcnRpY2FsTHJMdHIsXG4gICAgcnRsOiBWZXJ0aWNhbExyUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBTaWRld2F5c1JsID0ge1xuICAgIGx0cjogU2lkZXdheXNSbEx0cixcbiAgICBydGw6IFNpZGV3YXlzUmxSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFNpZGV3YXlzTHIgPSB7XG4gICAgbHRyOiBTaWRld2F5c0x0THRyLFxuICAgIHJ0bDogU2lkZXdheXNMdFJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgV3JpdGluZ01vZGVzID0ge1xuICAgIFwiaG9yaXpvbnRhbC10YlwiOiBIb3Jpem9udGFsVGIsXG4gICAgXCJ2ZXJ0aWNhbC1sclwiOiBWZXJ0aWNhbExyLFxuICAgIFwidmVydGljYWwtcmxcIjogVmVydGljYWxSbCxcbiAgICBcInNpZGV3YXlzLWxyXCI6IFNpZGV3YXlzTHIsXG4gICAgXCJzaWRld2F5cy1ybFwiOiBTaWRld2F5c1JsXG59IGFzIGNvbnN0O1xuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRpbWVvdXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC4gIFxuICAgICAqIElmIGBudWxsYCwgY2FuY2VscyB0aGUgdGltZW91dCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0byB0aGlzIHByb3AgYmV0d2VlbiByZW5kZXJzIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBjdXJyZW50IHRpbWVvdXQgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdHJpZ2dlckluZGV4PzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKiBcbiAgICAgKiBEb2VzICpub3QqIG5lZWQgdG8gYmUgc3RhYmxlLiBHbyBhaGVhZCBhbmQgcGFzcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9OiBVc2VUaW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7IHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gbnVsbDsgY2FsbGJhY2soKTsgfSk7XG4gICAgY29uc3QgZ2V0VGltZW91dCA9IHVzZVN0YWJsZUdldHRlcih0aW1lb3V0KTtcblxuICAgIC8vIFNldCBhbnkgdGltZSB3ZSBzdGFydCB0aW1lb3V0LlxuICAgIC8vIFVuc2V0IGFueSB0aW1lIHRoZSB0aW1lb3V0IGNvbXBsZXRlc1xuICAgIGNvbnN0IHN0YXJ0VGltZVJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IHRpbWVvdXRJc051bGwgPSAodGltZW91dCA9PSBudWxsKTtcblxuICAgIC8vIEFueSB0aW1lIHRoZSB0cmlnZ2VySW5kZXggY2hhbmdlcyAoaW5jbHVkaW5nIG9uIG1vdW50KVxuICAgIC8vIHJlc3RhcnQgdGhlIHRpbWVvdXQuICBUaGUgdGltZW91dCBkb2VzIE5PVCByZXNldFxuICAgIC8vIHdoZW4gdGhlIGR1cmF0aW9uIG9yIGNhbGxiYWNrIGNoYW5nZXMsIG9ubHkgdHJpZ2dlckluZGV4LlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdGltZW91dElzTnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRpbWVvdXRJc051bGwgPT0gKHRpbWVvdXQgPT0gbnVsbCkpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gKyhuZXcgRGF0ZSgpKTtcbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KHN0YWJsZUNhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSwgW3RyaWdnZXJJbmRleCwgdGltZW91dElzTnVsbF0pXG5cbiAgICBjb25zdCBnZXRFbGFwc2VkVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgrKG5ldyBEYXRlKCkpKSAtICgrKHN0YXJ0VGltZVJlZi5jdXJyZW50ID8/IG5ldyBEYXRlKCkpKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSZW1haW5pbmdUaW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0VGltZW91dCgpO1xuICAgICAgICByZXR1cm4gdGltZW91dCA9PSBudWxsID8gbnVsbCA6IE1hdGgubWF4KDAsIHRpbWVvdXQgLSBnZXRFbGFwc2VkVGltZSgpKVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGdldEVsYXBzZWRUaW1lLCBnZXRSZW1haW5pbmdUaW1lIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZUxvZ2ljYWxEaXJlY3Rpb24gfSBmcm9tIFwiLi91c2UtbG9naWNhbC1kaXJlY3Rpb25cIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwiLi91c2UtdGltZW91dFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgbGluZWFyTmF2aWdhdGlvbjoge31cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICAvKiogXG4gICAgICogVGhlc2UgcHJvcHMgY2FuIGJlIGF0dGF0Y2hlZCBlaXRoZXIgdG8gdGhlIHBhcmVudCBvciB0byBlYWNoIGluZGl2aWR1YWwgY2hpbGQuXG4gICAgICogV2hpY2hldmVyIHdvcmtzIGJldHRlciBmb3IgeW91ciBzY2VuYXJpby5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIFxuICAgICAqICovXG4gICAgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xufVxuXG5pbnRlcmZhY2UgTE5QIHtcbiAgICBuYXZpZ2F0ZVRvTmV4dCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9QcmV2KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb0ZpcnN0KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb0xhc3QoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGljaCBhcnJvdyBrZXlzIGFyZSB1c2VkIHRvIG5hdmlnYXRlIHRocm91Z2ggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBSZWxhdGl2ZSB0byB0aGUgd3JpdGluZyBtb2RlLCBzbyBpbiBFbmdsaXNoLCBcImlubGluZVwiIGNvcnJlc3BvbmRzXG4gICAgICogdG8gdGhlIGxlZnQgJiByaWdodCBhcnJvdyBrZXlzLCBhbmQgXCJibG9ja1wiIHRvIHRoZSB1cCAmIGRvd24gYXJyb3cga2V5cy5cbiAgICAgKiBcbiAgICAgKiBVc2UgXCJlaXRoZXJcIiB0byBhbGxvdyBuYXZpZ2F0aW9uIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gICAgICogXG4gICAgICogVXNlIFwibm9uZVwiIHRvIGRpc2FsbG93IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyBpbiBhbnkgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24/OiBcImlubGluZVwiIHwgXCJibG9ja1wiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxuICAgICAqIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAqIGJlIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUFycm93S2V5cz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAqIGJlIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmVcbiAgICAgKiB1bmFmZmVjdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVIb21lRW5kS2V5cz86IGJvb2xlYW47XG59XG5leHBvcnQgdHlwZSBMaW5lYXJOYXZpZ2F0aW9uT21pdHMgPSBrZXlvZiBMTlA7XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzPiB7XG4gICAgbGluZWFyTmF2aWdhdGlvbjogT21pdDxMTlAsIE9taXRzPlxufVxuXG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkYCAqL1xuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25DaGlsZEluZm8geyB9XG5cbi8qKlxuICogV2hlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFsbG93cyBjb250cm9sIG9mXG4gKiB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0ZpcnN0OiBudGYsIG5hdmlnYXRlVG9MYXN0OiBudGwsIG5hdmlnYXRlVG9OZXh0OiBudG4sIG5hdmlnYXRlVG9QcmV2OiBudHAsIG5hdmlnYXRpb25EaXJlY3Rpb246IG5kLCBkaXNhYmxlQXJyb3dLZXlzOiBkYWssIGRpc2FibGVIb21lRW5kS2V5czogZGhlayB9IH06IFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyPik6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cbiAgICBuZCA/Pz0gXCJlaXRoZXJcIjtcblxuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyB9ID0gdXNlTG9naWNhbERpcmVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe30pO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRmKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bCk7XG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VTdGFibGVDYWxsYmFjayhudG4pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRwKTtcbiAgICBjb25zdCBnZXREaXNhYmxlQXJyb3dLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRhayk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUhvbWVFbmRLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRoZWspO1xuICAgIGNvbnN0IGdldE5hdmlnYXRpb25EaXJlY3Rpb24gPSB1c2VTdGFibGVHZXR0ZXIobmQpO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzOiB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25EaXJlY3Rpb24gPSBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUFycm93S2V5cyA9IGdldERpc2FibGVBcnJvd0tleXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlSG9tZUVuZEtleXMgPSBnZXREaXNhYmxlSG9tZUVuZEtleXMoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiYmxvY2tcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c0lubGluZU5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImlubGluZVwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIDogYWxsb3dzSW5saW5lTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJidHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIDogYWxsb3dzSW5saW5lTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJidHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyh1c2VNZXJnZWRQcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4oeyBvbktleURvd24gfSwgcHJvcHMpKVxuICAgICAgICB9LCBbXSksXG4gICAgfVxuXG5cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICBjdXJyZW50VHlwZWFoZWFkOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkOiBib29sZWFuIHwgbnVsbDtcbiAgICB9XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKlxuICAgICAqIENhbiBiZSB1c2VkIG9uIGVpdGhlciB0aGUgcGFyZW50IG9yIGVhY2ggY2hpbGQgZWxlbWVudC5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDtcblxufVxuXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcblxuaW50ZXJmYWNlIFROUCB7XG4gICAgLyoqXG4gICAgICogQSBjb2xsYXRvciB0byB1c2Ugd2hlbiBjb21wYXJpbmcuIElmIG5vdCBwcm92aWRlZCwgc2ltcGx5IHVzZXMgYGxvY2FsZUNvbXBhcmVgIGFmdGVyIHRyYW5zZm9ybWluZyBlYWNoIHRvIGxvd2VyY2FzZSwgd2hpY2ggd2lsbCwgYXQgYmVzdCwgd29yayBva2F5IGluIEVuZ2xpc2guXG4gICAgICovXG4gICAgY29sbGF0b3I/OiBJbnRsLkNvbGxhdG9yO1xuXG4gICAgbm9UeXBlYWhlYWQ/OiBib29sZWFuO1xuXG4gICAgdHlwZWFoZWFkVGltZW91dD86IG51bWJlcjtcbiAgICBnZXRJbmRleCgpOiBudW1iZXIgfCBudWxsO1xuICAgIHNldEluZGV4KHZhbHVlOiBudW1iZXIgfCBudWxsIHwgKChwcmV2aW91c1ZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgVE5QO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzPiB7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogT21pdDxUTlAsIE9taXRzPlxufVxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZGAgKi9cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIElmIHByb3ZpZGVkLCBhbGxvd3MgdGhpcyBjb21wb25lbnQgdG8gYmUgbmF2aWdhdGVkIHRvIGJ5IHR5cGluZyB0aGlzIHN0cmluZy4gXG4gICAgICogSXQgc2hvdWxkIGJlIHRoZSBzYW1lIHRleHQgY29udGVudCBhcyB3aGF0ZXZlcidzIGRpc3BsYXllZCwgaWRlYWxseS5cbiAgICAgKi9cbiAgICB0ZXh0OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgaW5kZXg6IG51bWJlcjtcbn1cblxuLyoqIFR5cGUgb2YgdGhlIGNoaWxkJ3Mgc3ViLWhvb2sgKi9cbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IChhcmdzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzKSA9PiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlO1xuXG5cbi8qKlxuICogQWxsb3dzIGZvciB0aGUgc2VsZWN0aW9uIG9mIGEgbWFuYWdlZCBjaGlsZCBieSB0eXBpbmcgdGhlIGdpdmVuIHRleHQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgZ2V0SW5kZXgsIHR5cGVhaGVhZFRpbWVvdXQsIHNldEluZGV4LCBub1R5cGVhaGVhZCB9IH06IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyPik6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cblxuICAgIC8vIEZvciB0eXBlYWhlYWQsIGtlZXAgdHJhY2sgb2Ygd2hhdCBvdXIgY3VycmVudCBcInNlYXJjaFwiIHN0cmluZyBpcyAoaWYgd2UgaGF2ZSBvbmUpXG4gICAgLy8gYW5kIGFsc28gY2xlYXIgaXQgZXZlcnkgMTAwMCBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IGNoYW5nZWQuXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxuICAgIC8vIEFuZCwgZm9yIHRoZSB1c2VyJ3Mgc2FrZSwgbGV0IHRoZW0ga25vdyB3aGVuIHRoZWlyIHR5cGVhaGVhZCBjYW4ndCBtYXRjaCBhbnl0aGluZyBhbnltb3JlXG4gICAgY29uc3QgW2N1cnJlbnRUeXBlYWhlYWQsIHNldEN1cnJlbnRUeXBlYWhlYWQsIGdldEN1cnJlbnRUeXBlYWhlYWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xuICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZm8gPSB1c2VSZWY8eyB0ZXh0OiBzdHJpbmcsIHVuc29ydGVkSW5kZXg6IG51bWJlciB9W10+KFtdKTtcbiAgICBjb25zdCBbaW52YWxpZFR5cGVhaGVhZCwgc2V0SW52YWxpZFR5cGVhaGVhZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4oZmFsc2UpO1xuXG4gICAgLy8gSGFuZGxlIHR5cGVhaGVhZCBmb3IgaW5wdXQgbWV0aG9kIGVkaXRvcnMgYXMgd2VsbFxuICAgIC8vIEVzc2VudGlhbGx5LCB3aGVuIGFjdGl2ZSwgaWdub3JlIGZ1cnRoZXIga2V5cyBcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHdhaXRpbmcgZm9yIGEgQ29tcG9zaXRpb25FbmQgZXZlbnRcbiAgICBjb25zdCBbLCBzZXRJbWVBY3RpdmUsIGdldEltZUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICAvLyBCZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlICphZnRlcioga2V5ZG93biBldmVudHMgXG4gICAgLy8gKGJ1dCB3aXRoaW4gdGhlIHNhbWUgdGFzaywgd2hpY2gsIFRPRE8sIGNvdWxkIGJlIGJyb3dzZXItZGVwZW5kZW50KSxcbiAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBldmVudCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIG9uIHRoZSBmaXJzdCBrZXlkb3duLlxuICAgIGNvbnN0IFtuZXh0VHlwZWFoZWFkQ2hhciwgc2V0TmV4dFR5cGVhaGVhZENoYXJdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5leHRUeXBlYWhlYWRDaGFyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHR5cGVhaGVhZCA9PiAoKHR5cGVhaGVhZCA/PyBcIlwiKSArIG5leHRUeXBlYWhlYWRDaGFyKSk7XG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFtuZXh0VHlwZWFoZWFkQ2hhcl0pO1xuXG5cbiAgICBjb25zdCBjb21wYXJhdG9yU2hhcmVkID0gdXNlU3RhYmxlQ2FsbGJhY2soKHNhZmVMaHM6IHN0cmluZywgc2FmZVJoczogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBjb21wYXJlOiBudW1iZXI7XG4gICAgICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdHlwZWFoZWFkLCBvbmx5IGNvbXBhcmUgYSBzdHJpbmcgb2YgdGhlIHNhbWUgc2l6ZSBhcyBvdXIgY3VycmVudGx5IHR5cGVkIHN0cmluZy5cbiAgICAgICAgLy8gQnkgbm9ybWFsaXppbmcgdGhlbSBmaXJzdCwgd2UgZW5zdXJlIHRoaXMgYnl0ZS1ieS1ieXRlIGhhbmRsaW5nIG9mIHJhdyBjaGFyYWN0ZXIgZGF0YSB3b3JrcyBvdXQgb2theS5cbiAgICAgICAgc2FmZUxocyA9IHNhZmVMaHMubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICBzYWZlUmhzID0gc2FmZVJocy5ub3JtYWxpemUoXCJORkRcIilcblxuICAgICAgICBpZiAoY29sbGF0b3IpXG4gICAgICAgICAgICBjb21wYXJlID0gY29sbGF0b3IuY29tcGFyZShzYWZlTGhzLCBzYWZlUmhzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21wYXJlID0gc2FmZUxocy50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoc2FmZVJocy50b0xvd2VyQ2FzZSgpID8/IFwiXCIpO1xuXG4gICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW5zZXJ0aW5nQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdHlwZWFoZWFkQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSdyZSBhbGwgY29uc2lkZXJlZCBlcXVhbGx5IGJ5IHRoYXQgcG9pbnQuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0LnN1YnN0cmluZygwLCBsaHMubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB1c2VTdGFibGVHZXR0ZXIobm9UeXBlYWhlYWQpO1xuXG5cbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25TdGFydCA9IChfZTogQ29tcG9zaXRpb25FdmVudCkgPT4geyBzZXRJbWVBY3RpdmUodHJ1ZSkgfTtcbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IChlOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihlLmRhdGEpO1xuICAgICAgICAgICAgc2V0SW1lQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGltZUFjdGl2ZSA9IGdldEltZUFjdGl2ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlLmtleTtcblxuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICghaW1lQWN0aXZlICYmIGUua2V5ID09PSBcIkJhY2tzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHdheSB0aGF0IGRvZXNuJ3Qgc3BsaXQgVVRGLTE2IHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0ID0+IHQgPT09IG51bGwgPyBudWxsIDogWy4uLnRdLnJldmVyc2UoKS5zbGljZSgxKS5yZXZlcnNlKCkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUga2V5IHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHR5cGVkIGNoYXJhY3RlciBPUiB0aGUgXCJuYW1lZCBrZXkgYXR0cmlidXRlXCIgb2YgdGhlIGtleSBwcmVzc2VkLlxuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBkZWZpbml0ZSB3YXkgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSwgYnV0IGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBvbmUtY2hhcmFjdGVyIG5hbWVzLCBhbmQgdGhlcmUgYXJlIG5vIG5vbi1BU0NJSS1hbHBoYSBuYW1lcy5cbiAgICAgICAgICAgIC8vIFRodXMsIGFueSBvbmUtY2hhcmFjdGVyIG9yIG5vbi1BU0NJSSB2YWx1ZSBmb3IgYGtleWAgaXMgKmFsbW9zdCBjZXJ0YWlubHkqIGEgdHlwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJLZXkgPSAoa2V5Lmxlbmd0aCA9PT0gMSB8fCAhL15bQS1aYS16XS8udGVzdChrZXkpKTtcbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlcktleSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcIiBcIiAmJiAoZ2V0Q3VycmVudFR5cGVhaGVhZCgpID8/IFwiXCIpLnRyaW0oKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBiZWNhdXNlIGEgc3BhY2ViYXIgY2FuJ3QgZXZlciBcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYSB0eXBlYWhlYWQsIG9ubHkgY29udGludWUgb25lLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIChTcGVjaWZpY2FsbHksIGxldCB0aGUgZXZlbnQgY29udGludWUgcHJvcGFnYXRpb24gaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV29uJ3QgYmUgdHJ1ZSBmb3IgdGhlIGZpcnN0IGtleWRvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVmb3JlIHVzZUxheW91dEVmZmVjdCBpcyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biwgb25Db21wb3NpdGlvblN0YXJ0LCBvbkNvbXBvc2l0aW9uRW5kLCB9LCBwcm9wcyk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gSGFuZGxlIGNoYW5nZXMgaW4gdHlwZWFoZWFkIHRoYXQgY2F1c2UgY2hhbmdlcyB0byB0aGUgdGFiYmFibGUgaW5kZXhcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XG5cblxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIHR5cGVhaGVhZENvbXBhcmF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgaGFzIHR5cGVkIGFuIGVudHJ5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxuXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXG5cbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCBpZiB5b3UncmUgYWxyZWFkeSBkb2luZyB0eXBlYWhlYWQgb24gYW4gdW5zb3J0ZWQgbGlzdCwgbGlrZSwganVtcGluZXNzIGNhbid0IGJlIGF2b2lkZWQuXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxuXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXG5cbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxuICAgICAgICAgICAgICAgICAgc2VhcmNoZXMgYXJlLCB0aGFua3MgdG8gcGlnZW9uaG9sZSBwcmluY2lwYWwsIGV2ZW50dWFsbHkgZ3VhcmFudGVlZCB0byBiZWNvbWUgXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhbiBcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXG4gICAgICAgICAgICAgICAgICB0aGUgcm9hZC4gTWF5YmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHdvdWxkIGJlIGdvb2QgZW5vdWdoIHRob3VnaC5cbiAgICAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQmVzdEZpdCA9ICh1OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhOZXh0XS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRUeXBlYWhlYWRdKTtcblxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZD4oKHsgaW5kZXgsIHRleHQgfSkgPT4ge1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0byBpbnNlcnQgdGhpcyBpdGVtLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2UoLXNvcnRlZEluZGV4IC0gMSwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0ZXh0XSk7XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsXG5cbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBZb3VyIHVzdWFsIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24uXG4gKiBcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0gd2FudGVkIFRoZSB2YWx1ZSB5b3UnZCBsaWtlIHRvIGZpbmRcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxuICogQHJldHVybnMgQSBub24tbmVnYXRpdmUgdmFsdWUgaWYgYHdhbnRlZGAgd2FzIGZvdW5kLCBhbmQgYSBuZWdhdGl2ZSBudW1iZXIgaWYgbm90LiBcbiAqIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIG51bWJlciwgbWludXMgb25lLCBpcyB3aGVyZSBgd2FudGVkYCAqd291bGQqIGJlIGZvdW5kIGlmIGl0ICp3YXMqIGluIGBhcnJheWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDxULCBVLCBGIGV4dGVuZHMgKGxoczogVSwgcmhzOiBUKSA9PiBudW1iZXI+KGFycmF5OiBUW10sIHdhbnRlZDogVSwgY29tcGFyYXRvcjogRik6IG51bWJlciB7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICAgIGxldCBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChmaXJzdEluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICBjb25zdCB0ZXN0SW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgPj4gMTtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtZmlyc3RJbmRleCAtIDE7XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgcmV0dXJuWmVybywgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuLy9leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEs+PiA9IFJlcXVpcmVkPEk+ICYgRmxhZ2dhYmxlQ2hpbGRJbmZvPFwidGFiYmFibGVcIj4gJiB7XG4vL307XG5cbmV4cG9ydCB0eXBlIE9uVGFiYmFibGVJbmRleENoYW5nZSA9ICh0YWJiYWJsZUluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxFIGV4dGVuZHMgRWxlbWVudCwgQz4ge1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRhYmJpbmcgdGhyb3VnaCB0aGlzIGNvbXBvbmVudCB3aWxsIGNhdXNlIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgdG8gYmUgZm9jdXNlZC5cbiAgICAgKiBcbiAgICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudCBpZiB5b3UnZCBsaWtlLlxuICAgICAqL1xuICAgIGZvY3VzU2VsZigpOiB2b2lkO1xuXG4gICAgYmx1clNlbGYoKTogdm9pZDtcblxuICAgIGdldEVsZW1lbnQoKTogRSB8IG51bGw7XG5cbiAgICBoaWRkZW46IGJvb2xlYW47XG5cbiAgICBzdWJJbmZvOiBDO1xufVxuXG5pbnRlcmZhY2UgUlRJUCB7XG4gICAgLy8gQ2FsbGVkIGR1cmluZyBhbiBlZmZlY3QgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgcmVuZGVyZWQgaXRzZWxmIGluIGEgdGFiYmFibGUgc3RhdGVcbiAgICBvblRhYmJhYmxlUmVuZGVyPzogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG5cbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U/OiBPblRhYmJhYmxlSW5kZXhDaGFuZ2U7XG5cbiAgICBvblRhYmJlZEluVG8/OiAoKSA9PiB2b2lkO1xuICAgIG9uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xuXG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgPSBrZXlvZiBSVElQO1xuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBNY09taXRzPiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZUluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBmb2N1c1NlbGY6ICgpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj5cbntcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbn1cblxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBSdGljT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIj4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiBPbWl0PFBhcnRpYWw8T21pdDxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+LCBcImdldEVsZW1lbnRcIiB8IFwic3ViSW5mb1wiPj4sIFJ0aWNPbWl0cz47XG4gICAgc3ViSW5mbzogU3ViYmVzdEluZm87XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cywgbmV2ZXIsIG5ldmVyLCBSdGlTdWJJbmZvPikgPT4gVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRFbGVtZW50KCk6IENoaWxkRWxlbWVudCB8IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHJvdmluZyB0YWJpbmRleCBzeXN0ZW0gd2hlcmUgb25seSBvbmUgXCJmb2N1c2FibGVcIlxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXG4gKiByZWNvbW1lbmRlZCB0byBvZmZsb2FkIHRoYXQgbG9naWMgdGhlbiB0byBhbm90aGVyIGhvb2ssIGxpa2VcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXG4gKiBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdHlwZWFoZWFkLCBvclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKiBcbiAqIGBzaG91bGRGb2N1c09uQ2hhbmdlYCBzaG91bGQgcmV0dXJuIHRydWUgaWYgZm9jdXMgaXMgXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XG4gKiBgYGBcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xuICogYGBgXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICBsZXQgeyByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmVkSW5Ubywgb25UYWJiZWRPdXRPZiwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiYWJsZUluZGV4Q2hhbmdlIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xuXG4gICAgaW5pdGlhbEluZGV4ID8/PSAwO1xuICAgIGNvbnN0IHN0YWJsZU9uVGFiYmFibGVSZW5kZXIgPSB1c2VTdGFibGVDYWxsYmFjayhvblRhYmJhYmxlUmVuZGVyID8/ICgoKSA9PiB7IH0pKTtcbiAgICBjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKG9sZENvdW50ID09IDAgJiYgbmV3Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZEluVG8/LigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuWmVybyk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRocmVlIHRoaW5ncyByZWxhdGVkIHRvIHRoZSBjdXJyZW50bHkgdGFiYmFibGUgZWxlbWVudCdzIGluZGV4OlxuICAgIC8vIFdoYXQgaXQgaXMsIGFuZCB3aGV0aGVyLCB3aGVuIHdlIHJlbmRlciB0aGlzIGNvbXBvbmVudCBhbmQgaXQncyBjaGFuZ2VkLCB0byBhbHNvIGZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIG1hZGUgdGFiYmFibGUuXG4gICAgY29uc3QgW2dldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXgyXSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXIgfCBudWxsPihvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuIGluaXRpYWxJbmRleCA/PyAwIH0sIFtdKSk7XG4gICAgY29uc3Qgc2V0VGFiYmFibGVJbmRleCA9IHVzZUNhbGxiYWNrKCh1cGRhdGVyOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0sIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHtcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleDIoKHByZXZJbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5leHRJbmRleCA9IHByZXZJbmRleDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gdXBkYXRlcihwcmV2SW5kZXggPz8gbnVsbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gdXBkYXRlcjtcblxuICAgICAgICAgICAgbmV4dEluZGV4ID0gY2hhbmdlSW5kZXgobmV4dEluZGV4KTtcblxuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAhPSBuZXh0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChuZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IHByZXZJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KHByZXZJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGlsZC5zdWJJbmZvLmJsdXJTZWxmKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkICE9IG51bGwgJiYgZnJvbVVzZXJJbnRlcmFjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoaWxkLnN1YkluZm8uZm9jdXNTZWxmKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleDtcbiAgICAgICAgfSk7XG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyxcbiAgICAvLyBub3RpZnkgdGhlIHByZXZpb3VzIGNoaWxkIHRoYXQgaXQncyBubyBsb25nZXIgdGFiYmFibGUsXG4gICAgLy8gYW5kIG5vdGlmeSB0aGUgbmV4dCBjaGlsZCB0aGF0IGlzIGFsbG93ZWQgdG8gYmUgdGFiYmVkIHRvLlxuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obW91bnRlZCwgdW5tb3VudGVkKTsgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTsgfSksXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCB9ID0gcGFyZW50UmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHsgaW5pdGlhbEluZGV4LCBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4sIGNsb3Nlc3RGaXQ6IHRydWUsIGtleTogXCJ0YWJiYWJsZVwiIH0pO1xuXG4gICAgY29uc3QgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPj4oKGNoaWxkUGFyYW1ldGVycykgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3ViSW5mbywgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW4sIGJsdXJTZWxmOiBibHVyU2VsZk92ZXJyaWRlLCBmb2N1c1NlbGY6IGZvY3VzU2VsZk92ZXJyaWRlIH0gfSA9IGNoaWxkUGFyYW1ldGVycztcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTtcbiAgICAgICAgfSwgWyEhaGlkZGVuXSlcblxuXG4gICAgICAgIGNvbnN0IGJzT3ZlcnJpZGUgPSB1c2VTdGFibGVHZXR0ZXIoYmx1clNlbGZPdmVycmlkZSk7XG4gICAgICAgIGNvbnN0IGZzT3ZlcnJpZGUgPSB1c2VTdGFibGVHZXR0ZXIoZm9jdXNTZWxmT3ZlcnJpZGUpO1xuICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcyA9IGZzT3ZlcnJpZGUoKTtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpIGFzIChFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgICAgICBjb25zdCBibHVyU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJzID0gYnNPdmVycmlkZSgpO1xuICAgICAgICAgICAgaWYgKGJzKSB7XG4gICAgICAgICAgICAgICAgYnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYmx1cj8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCBvbkZvY3VzZWRJbm5lckNoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgc2V0QW55Rm9jdXNlZChwcmV2ID0+IChmb2N1c2VkID8gKChwcmV2ID8/IDApICsgMSkgOiAoKHByZXYgPz8gMCkgLSAxKSkpO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8Q2hpbGRFbGVtZW50Pih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCB9KTtcblxuICAgICAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlLCBnZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhYmJhYmxlRmxhZ3MgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFRhYmJhYmxlLCBzZXQ6IHNldFRhYmJhYmxlLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhaGlkZGVuKSB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGZsYWdzOiB7IC4uLmZsYWdzLCB0YWJiYWJsZTogdGFiYmFibGVGbGFncy5jdXJyZW50IH0gYXMgUGFydGlhbDxSZWNvcmQ8RXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+LFxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgYmx1clNlbGYsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhIWhpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgc3ViSW5mb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFiYmFibGUpXG4gICAgICAgICAgICAgICAgc3RhYmxlT25UYWJiYWJsZVJlbmRlcihpbmRleCk7XG4gICAgICAgIH0sIFt0YWJiYWJsZSwgaW5kZXhdKVxuICAgICAgICBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLnRhYkluZGV4ID09IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENoaWxkRWxlbWVudD4odXNlSGFzRm9jdXNQcm9wcyh7IHRhYkluZGV4OiB0YWJiYWJsZSA/IDAgOiAtMSB9KSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgdXNlUm92aW5nVGFiSW5kZXguZm9jdXNTZWxmYCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0VGFiYmFibGVJbmRleCgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KGluZGV4KT8uc3ViSW5mby5mb2N1c1NlbGY/LigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4gfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLypmdW5jdGlvbiB0ZXN0KCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxEaXZFbGVtZW50LCB7IFwiZm9vXCI6IFwiYmFyXCIgfSwgXCJmbGFnMlwiPih7IG1hbmFnZWRDaGlsZHJlbjoge30sIHJvdmluZ1RhYkluZGV4OiB7fSB9KTtcbiAgICBjb25zdCB7IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4OiAwLCBmbGFnczoge30gfSwgcnRpOiB7IGluZm8zOiB7IGZvbzogXCJiYXJcIiB9IH0gfSk7XG59Ki9cbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJhbmRvbTtcbiIsImltcG9ydCBiYXNlUmFuZG9tIGZyb20gJy4vX2Jhc2VSYW5kb20uanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICB9XG4gIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZVNlbGY7XG4iLCJpbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNodWZmbGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCJpbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7XG4iLCJpbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICcuL3ZhbHVlcy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNodWZmbGU7XG4iLCJpbXBvcnQgYXJyYXlTaHVmZmxlIGZyb20gJy4vX2FycmF5U2h1ZmZsZS5qcyc7XG5pbXBvcnQgYmFzZVNodWZmbGUgZnJvbSAnLi9fYmFzZVNodWZmbGUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZTtcbiIsImltcG9ydCAqIGFzIF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNdXRhYmxlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRJbmZvLCBNYW5hZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcblxuZXhwb3J0IHR5cGUgR2V0SW5kZXg8QywgSyBleHRlbmRzIHN0cmluZz4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4pID0+IChudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKTtcbmV4cG9ydCB0eXBlIEdldFZhbHVlPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4sIC4uLmFyZ3M6IEcpID0+IFY7XG5leHBvcnQgdHlwZSBDb21wYXJlPFY+ID0gKGxoczogViwgcmhzOiBWKSA9PiBudW1iZXI7XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiwgZS5nLiwgdGhlIHJvdyBpbmRleCBvZiB0aGlzIGNoaWxkXG4gICAgICogKFVzdWFsbHkganVzdCBhbiBgaW5kZXhgIHByb3ApXG4gICAgICovXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiBHZXRJbmRleDxDLCBLPjsgfVxufVxuXG4vKipcbiAqIEFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgKipNVVNUKiogYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+IHtcbiAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXN0IHJldHVybiB0aGUgdmFsdWUgdGhpcyBjaGlsZCB1c2VzIFJFOiBzb3J0aW5nLlxuICAgICAgICAgKiBJZiB5b3UgZG9uJ3QgY2FyZSBhYm91dCBzb3J0aW5nICh5b3UganVzdCB1c2UgXG4gICAgICAgICAqIHlvdXIgb3duYXJiaXRyYXJ5IHJlb3JkZXJpbmcpLCB0aGlzIHdpbGwgbmV2ZXJcbiAgICAgICAgICogYmUgdXNlZCwgc28gaXQgY2FuIHJldHVybiBhbnl0aGluZy5cbiAgICAgICAgICogQHBhcmFtIHJvdyBcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogR2V0VmFsdWU8QywgSywgRywgVj47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIGhvdyB2YWx1ZXMgY29tcGFyZSBhZ2FpbnN0IGVhY2ggb3RoZXIuXG4gICAgICAgICAqIEBwYXJhbSBsaHMgXG4gICAgICAgICAqIEBwYXJhbSByaHMgXG4gICAgICAgICAqL1xuICAgICAgICBjb21wYXJlOiBDb21wYXJlPFY+O1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISpcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9IH06IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4pOiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIEMsIEs+IHtcblxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYSBtYXBwaW5nIGJldHdlZW4gdW5zb3J0ZWQgaW5kZXggPC0tLT4gc29ydGVkIGluZGV4LlxuICAgIC8vIFRoZXNlIGFyZSBuZWVkZWQgZm9yIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAgICBjb25zdCBtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgZGVtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgaW5kZXhNYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKG1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuICAgIGNvbnN0IGluZGV4RGVtYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKGRlbWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG5cbiAgICAvLyBUaGUgc29ydCBmdW5jdGlvbiBuZWVkcyB0byBiZSBhYmxlIHRvIHVwZGF0ZSB3aG9ldmVyIGhhcyBhbGwgdGhlIHNvcnRhYmxlIGNoaWxkcmVuLlxuICAgIC8vIEJlY2F1c2UgdGhhdCBtaWdodCBub3QgYmUgdGhlIGNvbnN1bWVyIG9mICp0aGlzKiBob29rIGRpcmVjdGx5IChlLmcuIGEgdGFibGUgdXNlc1xuICAgIC8vIHRoaXMgaG9vaywgYnV0IGl0J3MgdGJvZHkgdGhhdCBhY3R1YWxseSBuZWVkcyB1cGRhdGluZyksIHdlIG5lZWQgdG8gcmVtb3RlbHlcbiAgICAvLyBnZXQgYW5kIHNldCBhIGZvcmNlVXBkYXRlIGZ1bmN0aW9uLlxuICAgIC8vY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG5cbiAgICBjb25zdCByZWFycmFuZ2UgPSB1c2VDYWxsYmFjaygoc29ydGVkUm93czogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+W10pID0+IHtcblxuICAgICAgICAvLyBVcGRhdGUgb3VyIHNvcnRlZCA8LS0+IHVuc29ydGVkIGluZGljZXMgbWFwIFxuICAgICAgICAvLyBhbmQgcmVyZW5kZXIgdGhlIHdob2xlIHRhYmxlLCBiYXNpY2FsbHlcbiAgICAgICAgZm9yIChsZXQgaW5kZXhBc1NvcnRlZCA9IDA7IGluZGV4QXNTb3J0ZWQgPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytpbmRleEFzU29ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEFzVW5zb3J0ZWQgPSBzb3J0ZWRSb3dzW2luZGV4QXNTb3J0ZWRdLmluZGV4O1xuXG4gICAgICAgICAgICBtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1Vuc29ydGVkLCBpbmRleEFzU29ydGVkKTtcbiAgICAgICAgICAgIGRlbWFuZ2xlTWFwLmN1cnJlbnQuc2V0KGluZGV4QXNTb3J0ZWQsIGluZGV4QXNVbnNvcnRlZCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldEZvcmNlVXBkYXRlKCk/LigpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVJlYXJyYW5nZWFibGVQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB9KSA9PiB7XG5cbiAgICAgICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRGb3JjZVVwZGF0ZShfcHJldiA9PiBmb3JjZVVwZGF0ZSk7IH0sIFtmb3JjZVVwZGF0ZV0pXG5cbiAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wczxQYXJlbnRFbGVtZW50Pih7XG4gICAgICAgICAgICBjaGlsZHJlbjpcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gYXMgVk5vZGU8TWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+PltdKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGNoaWxkID0+ICh7IGNoaWxkLCBtYW5nbGVkSW5kZXg6IGluZGV4TWFuZ2xlcihnZXRJbmRleChjaGlsZC5wcm9wcyEpISksIGRlbWFuZ2xlZEluZGV4OiBnZXRJbmRleChjaGlsZC5wcm9wcykgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KChsaHMsIHJocykgPT4geyByZXR1cm4gbGhzLm1hbmdsZWRJbmRleCAtIHJocy5tYW5nbGVkSW5kZXggfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoeyBjaGlsZCwgbWFuZ2xlZEluZGV4LCBkZW1hbmdsZWRJbmRleCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaChjaGlsZC50eXBlIGFzIGFueSwgeyAuLi5jaGlsZC5wcm9wcywga2V5OiBkZW1hbmdsZWRJbmRleCwgXCJkYXRhLW1hbmdsZWQtaW5kZXhcIjogbWFuZ2xlZEluZGV4LCBcImRhdGEtdW5tYW5nbGVkLWluZGV4XCI6IGRlbWFuZ2xlZEluZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LCBwcm9wcykpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IHVzZVJlYXJyYW5nZWFibGVQcm9wcywgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIsIG1hbmdsZU1hcCwgZGVtYW5nbGVNYXAsIHJlYXJyYW5nZSB9IH07XG59XG5cblxuLyoqXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cbiAqIFxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKiBcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9LCBzb3J0YWJsZUNoaWxkcmVuOiB7IGNvbXBhcmU6IHVzZXJDb21wYXJlLCBnZXRWYWx1ZSB9IH06IFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEssIEcsIFY+KTogVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSywgRz4ge1xuXG4gICAgY29uc3QgY29tcGFyZSA9ICh1c2VyQ29tcGFyZSA/PyBkZWZhdWx0Q29tcGFyZSk7XG5cbiAgICBjb25zdCB7IHVzZVJlYXJyYW5nZWFibGVQcm9wczogdXNlU29ydGFibGVQcm9wcywgLi4ucmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEs+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfSk7XG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgcmVhcnJhbmdlIH0gfSA9IHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGU7XG4gICAgLy8gVGhlIGFjdHVhbCBzb3J0IGZ1bmN0aW9uLlxuICAgIGNvbnN0IHNvcnQgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRyk6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcblxuICAgICAgICBjb25zdCBzb3J0ZWRSb3dzID0gbWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpLnNvcnQoKGxoc1JvdywgcmhzUm93KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gZ2V0VmFsdWUobGhzUm93LCAuLi5hcmdzKSBhcyBhbnk7XG4gICAgICAgICAgICBjb25zdCByaHNWYWx1ZSA9IGdldFZhbHVlKHJoc1JvdywgLi4uYXJncykgYXMgYW55O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZShsaHNWYWx1ZSwgcmhzVmFsdWUpIC8vIGxoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlLCByaHNSb3cuZ2V0TWFuYWdlZENlbGxzKCk/Lltjb2x1bW5dPy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uWzBdID09IFwiZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAtcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNvcnRlZFJvd3MpO1xuXG4gICAgfSwgWyAvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IHNodWZmbGUgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzaHVmZmxlZFJvd3MgPSBsb2Rhc2hTaHVmZmxlKG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKSlcbiAgICAgICAgcmV0dXJuIHJlYXJyYW5nZShzaHVmZmxlZFJvd3MpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsgc29ydCwgc2h1ZmZsZSB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUucmVhcnJhbmdlYWJsZUNoaWxkcmVuXG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIGFuIGFycmF5IG9mIG5vdC1zb3J0ZWQgY2hpbGQgaW5mb3JtYXRpb24gdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgKiBhbmQgdGhlIGNoaWxkcmVuIHdpbGwgcmUtYXJyYW5nZSB0aGVtc2VsdmVzIHRvIG1hdGNoLlxuICAgICAgICAgKiAgXG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICogIFxuICAgICAgICAgKiBcbiAgICAgICAgICovXG4gICAgICAgIHJlYXJyYW5nZTogKHJvd3NJbk9yZGVyOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4gdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIG1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZGVtYW5nbGVNYXA6IE11dGFibGVSZWY8TWFwPG51bWJlciwgbnVtYmVyPj47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIHwgdW5kZWZpbmVkOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PjtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzb3J0OiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNodWZmbGU6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kc1xuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VTb3J0YWJsZVByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIHwgdW5kZWZpbmVkOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50Pjtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29tcGFyZTEobGhzLCByaHMpO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZTMobGhzOiBzdHJpbmcgfCBudW1iZXIsIHJoczogc3RyaW5nIHwgbnVtYmVyKSB7XG5cbiAgICAgICAgLy8gQ29lcmNlIHN0cmluZ3MgdG8gbnVtYmVycyBpZiB0aGV5IHNlZW0gdG8gc3RheSB0aGUgc2FtZSB3aGVuIHNlcmlhbGl6ZWRcbiAgICAgICAgaWYgKGAkeytsaHN9YCA9PT0gbGhzKVxuICAgICAgICAgICAgbGhzID0gK2xocztcbiAgICAgICAgaWYgKGAkeytyaHN9YCA9PT0gcmhzKVxuICAgICAgICAgICAgcmhzID0gK3JocztcblxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBpZiBlaXRoZXIgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHR1cm4gdGhlIG90aGVyIG9uZSBpbnRvIG9uZSB0b29cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByaHMgPSBgJHtyaHN9YDtcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBsaHMgPSBgJHtsaHN9YDtcblxuICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgbGhzID09PSB0eXBlb2YgcmhzKTtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBsaHMubG9jYWxlQ29tcGFyZShyaHMgYXMgc3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gK2xocyAtICtyaHM7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUyKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwiYm9vbGVhblwiIHx8IGxocyBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJib29sZWFuXCIgfHwgcmhzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XG4gICAgICAgIHJldHVybiBjb21wYXJlMyhsaHMsIHJocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUxKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBudWxsXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCB8fCByaHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gT25lIG9mIHRoZSB0d28gaXMgbnVsbCAtLSBlYXN5IGNhc2VcbiAgICAgICAgICAgIHJldHVybiBsaHMgIT0gbnVsbCA/IDEgOiAtMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlMihsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cywgdXNlQ2hpbGRyZW5GbGFnIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIHVzZVJvdmluZ1RhYkluZGV4LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcbmltcG9ydCB7IHVzZVNvcnRhYmxlQ2hpbGRyZW4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxuICogXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XG4gKiB8LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXxcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcbiAqIHxFTnxIaXzvvKjvvYl84pyFfOKchXzinIV84p2MfFxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGFhfOKdjHzinYx84p2MfOKdjHxcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfEFhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfOOBi3zinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB844KrfOOCrHzinIV84p2MfOKdjHzinYx8XG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XG4gKiBcbiAqIFxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15OiBhbnkgPSBudWxsO1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5PFQ+KHQ6IFQpIHsgcmV0dXJuIHQ7IH1cbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4ge1xuICAgIHRleHQ6IHN0cmluZztcblxuICAgIHN1YkluZm86IEM7XG59XG5cbi8qKlxuICogQHBhcmFtIGZyb21Vc2VySW50ZXJhY3Rpb24gV2hldGhlciB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhpcyBjaGlsZCBhcyBhIG1lYW5zIG9mIG5hdmlnYXRpbmcgdG8gaXQuICBJbiB0aGF0IHdhcyB0aGUgY2FzZSwgdGhlIGNoaWxkIGlzIGFsc28gZm9jdXNlZC4gT3RoZXJ3aXNlLCBmb2N1cyBtb3ZlcyBhcyB0aGUgYnJvd3NlciBkZXRlcm1pbmVzLlxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0ZVRvSW5kZXggPSAoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcblxuXG5pbnRlcmZhY2UgTFNQIHtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYW5kIGluZGV4RGVtYW5nbGVyIGFyZSB1c2VkIHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG5hdmlnYXRlZCBpbiBhbiBvcmRlclxuICAgICAqIHRoYXQgZG9lc24ndCBuZWNlc3NhcmlseSBtYXRjaCB0aGVpciBjaGlsZCBvcmRlciwgbGlrZSBpZiBhIGxpc3QgaXMgc29ydGVkLlxuICAgICAqIFxuICAgICAqIFVzZWQgdG8gdHVybiBhbiBcImFic29sdXRlXCIgaW5kZXggaW50byBhIFwic29ydGVkL2ZpbHRlcmVkL21hbmdsZWRcIiBvbmUuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXG4gICAgICogQHBhcmFtIHJhd0luZGV4IFxuICAgICAqL1xuICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHVybiBhIFwibWFuZ2xlZFwiIGluZGV4IGludG8gaXQncyBcInVuc29ydGVkXCIgb3IgXCJ1bm1hbmdsZWRcIiBpbmRleC5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXgsXG4gICAgICogaXQgbmVlZHMgdG8gYmUgZGVtYW5nbGVkIHRvIGRvIFwibm9ybWFsXCIgbWF0aCBvbiBpdCwgYW5kIHRoZW4gcmUtbWFuZ2xlZCAoYWJvdmUpXG4gICAgICogdG8gdHVybiB0aGF0IGFic29sdXRlIHJvdyBpbmRleCBiYWNrIGludG8gYSBtYW5nbGVkIG9uZS5cbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtZWRJbmRleCBcbiAgICAgKi9cbiAgICBpbmRleERlbWFuZ2xlcj8odHJhbnNmb3JtZWRJbmRleDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIExTUDtcblxuLy8gKioqIFBhcmFtZXRlcnMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFJ0aU9taXRzLCBNY09taXRzPixcbiAgICBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxUbk9taXRzIHwgXCJnZXRJbmRleFwiIHwgXCJzZXRJbmRleFwiPixcbiAgICBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxMbk9taXRzIHwgXCJuYXZpZ2F0ZVRvRmlyc3RcIiB8IFwibmF2aWdhdGVUb0xhc3RcIiB8IFwibmF2aWdhdGVUb05leHRcIiB8IFwibmF2aWdhdGVUb1ByZXZcIj4ge1xuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PExTUCwgTHNPbWl0cz47XG59XG5cbmludGVyZmFjZSBTU1Age1xuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG59XG5leHBvcnQgdHlwZSBTaW5nbGVTZWxlY3Rpb25PbWl0cyA9IGtleW9mIFNTUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cywgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IE9taXQ8U1NQLCBTU09taXRzPjtcbn1cbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyA9IGtleW9mIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxhbnk+O1xuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIFJ0aU9taXRzLCBNY09taXRzLCBTdWJiZXN0SW5mbz4ge1xuICAgIC8vcm92aW5nVGFiSW5kZXg6IE9taXQ8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIG5ldmVyPltcInJvdmluZ1RhYkluZGV4XCJdLCBcInN1YkluZm9cIj47XG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIExzT21pdHMgfCBcInN1YkluZm9cIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyB8IFwic2VsZWN0ZWRcIiwgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG5cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPj4sIFwidGFiYmFibGVcIiB8IEV4dHJhRmxhZ0tleXM+LCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4OiBOYXZpZ2F0ZVRvSW5kZXggfTtcbn1cblxuLy8gKioqIFJldHVybiB0eXBlcyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+O1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHt9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz5bXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PltcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1wiXTtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHByb3BlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBjb21wb25lbnRzIGxpa2UgbGlzdGJveGVzLCBidXR0b24gZ3JvdXBzLCBtZW51cywgZXRjLlxuICogXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXG4gKiBOYXZpZ2F0aW5nIGZvcndhcmRzL2JhY2t3YXJkcyBjYW4gYmUgZG9uZSB3aXRoIHRoZSBhcnJvdyBrZXlzLCBIb21lL0VuZCBrZXlzLCBvciBhbnkgYW55IHRleHQgZm9yIHR5cGVhaGVhZCB0byBmb2N1cyB0aGUgbmV4dCBpdGVtIHRoYXQgbWF0Y2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICByb3ZpbmdUYWJJbmRleCxcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBpbmRleE1hbmdsZXIgPz89IGlkZW50aXR5O1xuICAgIGluZGV4RGVtYW5nbGVyID8/PSBpZGVudGl0eTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxpc3ROYXZpZ2F0aW9uXCIsIGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIpO1xuXG5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSwgcm92aW5nVGFiSW5kZXg6IHsgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCB9IH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0luZGV4ID0gdXNlQ2FsbGJhY2soKGk6IG51bWJlciB8IG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdHJ5TmF2aWdhdGVUb0luZGV4KHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGksXG4gICAgICAgICAgICAgICAgc2VhcmNoRGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LFxuICAgICAgICAgICAgICAgIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGkgPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXgsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChudWxsLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgICAgICBpbnZhbGlkVHlwZWFoZWFkXG4gICAgICAgIH1cbiAgICB9ID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIHNldEluZGV4OiB1c2VDYWxsYmFjaygoaW5kZXg6IChudW1iZXIgfCBudWxsKSB8ICgocHJldjogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgLi4udHlwZWFoZWFkTmF2aWdhdGlvblxuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXY6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KHsgY2hpbGRyZW4sIGRlZmF1bHQ6IGMgPz8gMCwgdGFyZ2V0OiBpbmRleERlbWFuZ2xlciEoaW5kZXhNYW5nbGVyISgoYyA/PyAwKSkgLSAxKSwgc2VhcmNoRGlyZWN0aW9uOiAtMSwgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSB9KVxuICAgICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dDogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKGMgPz8gMCkgKyAxKSwgc2VhcmNoRGlyZWN0aW9uOiAxLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyISgwKSwgdHJ1ZSk7IH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0OiB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleChpbmRleERlbWFuZ2xlciEoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkpLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgLi4ubGluZWFyTmF2aWdhdGlvblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvblByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyhwcm9wcykpO1xuICAgIH0sIFt1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMsIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wc10pO1xuXG5cbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSwgc3ViSW5mbyB9KSA9PiB7XG5cbiAgICAgICAgY29uc3QgX3Y6IHZvaWQgPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQoeyB0ZXh0LCBpbmRleCB9KTtcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChnZXRUYWJiYWJsZUluZGV4KCkgPT0gZ2V0SW5kZXgoKSkge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbjogISFoaWRkZW4gfSxcbiAgICAgICAgICAgIHN1YkluZm86IHsgdGV4dCwgc3ViSW5mbyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMoKCh7IGluZXJ0OiBoaWRkZW4gfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSkpLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBuYXZpZ2F0ZVRvSW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG5cbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH1cbiAgICAgICAgLypsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfSovXG4gICAgfVxufVxuXG5cblxuXG5cblxuLyoqXG4gKiBJdCdzIHZlcnkgY29tbW9uIHRvIGNvbWJpbmUgYSB0YWJiYWJsZSBsaXN0IG9mIHRoaW5ncyBhbmQgXCJzZWxlY3Rpb25cIiBvZiBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICogXG4gKiBMaXN0cywgcmFkaW8gYnV0dG9ucywgdGFicywgZXRjLiBldGMuXG4gKiBcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCB0aGF0IGNvbWJpbmVzIHRoZSB0d28gd2l0aCB0aGUgY29ycmVjdCB0eXBpbmcuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCB9LFxuICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgIG1hbmFnZWRDaGlsZHJlbjogeyAvKm9uQ2hpbGRyZW5Nb3VudENoYW5nZTogb2NtYywqLyAuLi5tYyB9LFxuICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgLi4ucm92aW5nVGFiSW5kZXggfSxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbn06IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgLi4ubWMsXG4gICAgICAgICAgICAvKm9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IHtcbiAgICAgICAgICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpO1xuICAgICAgICAgICAgICAgIG9jbWM/Lihtb3VudGVkLCB1bm1vdW50ZWQpO1xuICAgICAgICAgICAgfSkqL1xuICAgICAgICB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgaW5pdGlhbEluZGV4OiAoaW5pdGlhbEluZGV4ID8/IHNlbGVjdGVkSW5kZXggPz8gdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIC4uLnJvdmluZ1RhYkluZGV4XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdFJlc3RcbiAgICB9ID0gcGFyZW50UmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0gfSA9IGxpc3RSZXN0O1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjaGFuZ2VJbmRleDogY2hhbmdlU2VsZWN0ZWRJbmRleCxcbiAgICAgICAgZ2V0Q3VycmVudEluZGV4OiBnZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICAvL3JlZXZhbHVhdGVDbG9zZXN0Rml0XG4gICAgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBLIHwgXCJzZWxlY3RlZFwiPih7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbEluZGV4OiBzZWxlY3RlZEluZGV4LFxuICAgICAgICBrZXk6IFwic2VsZWN0ZWRcIixcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcbiAgICB9KTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZVNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgfSwgW3NlbGVjdGVkSW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IHVzZUNhbGxiYWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogcnRpLCBsaXN0TmF2aWdhdGlvbjogbHMsIHN1YkluZm8gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldElzU2VsZWN0ZWQsIGdldElzU2VsZWN0ZWRdID0gdXNlU3RhdGUoZ2V0U2VsZWN0ZWRJbmRleCgpID09IGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUmVmID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRJc1NlbGVjdGVkLCBzZXQ6IHNldElzU2VsZWN0ZWQsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFydGkuaGlkZGVuKSB9KTtcblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1xuICAgICAgICAgICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBQYXJ0aWFsPFJlY29yZDxLIHwgXCJzZWxlY3RlZFwiIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IGxzLFxuICAgICAgICAgICAgICAgIHN1YkluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsIGdldFNlbGVjdGVkOiBnZXRJc1NlbGVjdGVkIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKC4uLnA6IFBhcmFtZXRlcnM8dHlwZW9mIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM+KSA9PiB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKC4uLnApIH0sIFtdKSxcbiAgICAgICAgLi4ubGlzdFJlc3QsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge31cbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFYsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4ge1xufVxuXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHMsIEM+O1xuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+KHsgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbiwgcm92aW5nVGFiSW5kZXgsIHR5cGVhaGVhZE5hdmlnYXRpb24sIHJlYXJyYW5nZWFibGVDaGlsZHJlbiwgc29ydGFibGVDaGlsZHJlbiB9OiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxDLCBLLCBHLCBWLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSywgRywgVj4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW4sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgLi4ubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHModXNlU29ydGFibGVQcm9wcyhwcm9wcykpKVxuICAgIH1cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+ID0gKHApID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQocClcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlLFxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxuICAgICAgICAvKm1hbmFnZWRDaGlsZHJlbjogbGlzdE5hdlJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0TmF2UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogc29ydGFibGVDaGlsZHJlblJldHVyblR5cGUuc29ydGFibGVDaGlsZHJlbixcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW4qL1xuICAgIH0pO1xuXG59XG5cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhcmdzOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzLCBMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kc1xuICAgIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgc2luZ2xlU2VsZWN0aW9uLCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLLCBbXT4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGVcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBbXSwgbnVtYmVyPih7XG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSkgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgZ2V0VmFsdWU6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxuICAgICAgICAgICAgY29tcGFyZTogdXNlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMgLSByaHM7IH0sIFtdKSxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZVJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHNpbmdsZVNlbGVjdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzID0gKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiB7XG4gICAgICAgIHJldHVybiAodXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh1c2VTb3J0YWJsZVByb3BzKHByb3BzKSkpO1xuICAgIH1cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh7XG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxuICAgICAgICAvL3NvcnRhYmxlOiB7IHNvcnQsIHNodWZmbGUsIHJlYXJyYW5nZSwgZGVtYW5nbGVNYXAsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIG1hbmdsZU1hcCB9LFxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGUsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSk7XG5cbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEs+O1xuICAgIGRlZmF1bHQ6IG51bWJlcjtcbiAgICB0YXJnZXQ6IG51bWJlcjtcbiAgICBzZWFyY2hEaXJlY3Rpb246IDEgfCAtMTtcbiAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlOYXZpZ2F0ZVRvSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbiwgc2VhcmNoRGlyZWN0aW9uLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCB0YXJnZXQgfTogVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEs+KSB7XG4gICAgY29uc3QgdXBwZXIgPSBjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKTtcbiAgICBjb25zdCBsb3dlciA9IDA7XG5cbiAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICB3aGlsZSAoKHRhcmdldCA+PSBsb3dlciAmJiAoY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKSlcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpIC0gMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA8IGxvd2VyID8gaW5kZXhEZW1hbmdsZXIobG93ZXIpIDogdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPD0gdXBwZXIgJiYgY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgKyAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0ID4gdXBwZXIgPyBpbmRleERlbWFuZ2xlcih1cHBlcikgOiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG93ZXI7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyB9IGZyb20gXCJ1c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMgfSBmcm9tIFwidXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgfSBmcm9tIFwidXNlLXJvdmluZy10YWJpbmRleFwiO1xuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG4vKipcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXG4gKiBcbiAqIFRoaXMgcmVzdWx0cyBpbiBhIGxvdCBvZiB0aGluZ3Mgd2l0aCB2ZXJ5IHNpbWlsYXIgbmFtZXMgYW5kIGp1c3QgY29uZnVzaW9uIGFsbCBhcm91bmQuIFBsZWFzZSB1c2UgY2F1dGlvbi5cbiAqL1xuXG4vLyBQYXJhbWV0ZXJzIChwYXJlbnQsIHJvdywgY2VsbClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XG4gICAgQ1IsXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxuICAgIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxuICAgIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyxcblxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcbiAgICBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLFxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLFxuXG4gICAgU3ViYmVzdEluZm9cbiAgICA+IHtcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPjtcbiAgICBhc0NoaWxkUm93T2ZTZWN0aW9uOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDUiwgS1IsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz5cblxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPENDLCBLQyBleHRlbmRzIHN0cmluZywgTHNDaGlsZE9taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQywgS0MsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4ge1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Sb3c6IFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSLCBLQz47XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGFzQ2hpbGRSb3c6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxSb3c+O1xuICAgIGFzUGFyZW50T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDZWxsLCBDQywgS0M+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93LCBDZWxsLCBDQywgS0M+IHtcbiAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGw6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsLCBDQywgS0M+O1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIC8vcm93SXNUYWJiYWJsZTogYm9vbGVhbjtcbiAgICAgICAgLy9nZXRSb3dJc1RhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPENSLCBLUiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDUj4pID0+IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3csIENlbGwsIENDLCBLQz47XG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDQywgS0MsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIENDPikgPT4gVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsPjtcblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb248XG4gICAgUGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93U3ViSW5mbyxcbiAgICBDZWxsU3ViSW5mbyxcbiAgICBSb3dFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nLFxuICAgIENlbGxFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nXG4+KHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgbGlzdE5hdmlnYXRpb246IGxzLFxuICAgIGxpbmVhck5hdmlnYXRpb246IGxuLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXG59OiBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+IHtcbiAgICBjb25zdCBbY3VycmVudENvbHVtbiwgc2V0Q3VycmVudENvbHVtbiwgZ2V0Q3VycmVudENvbHVtbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihydGkuaW5pdGlhbEluZGV4ID8/IDApO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93LFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxuICAgICAgICAuLi5wYXJlbnRMc1JldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBSb3dTdWJJbmZvLCBSb3dFeHRyYUZsYWdzPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImJsb2NrXCIsIC4uLmxuIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuLFxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiBhc0NoaWxkLCBhc1BhcmVudFJvd09mQ2VsbHM6IGFzUGFyZW50IH0pID0+IHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGZvY3VzU2VsZiB0aGF0IHJvdmluZ1RhYkluZGV4IGRvZXMuXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZm9jdXNpbmcgdGhlIGVudGlyZSByb3csIHdlIGFzayB0aGUgY2VsbCB0aGF0IGNvcnJlc3BvbmRzXG4gICAgICAgIC8vIHRvIG91ciBjdXJyZW50IGNvbHVtbiB0byBmb2N1cyBpdHNlbGYuXG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZ2V0Q3VycmVudENvbHVtbigpO1xuICAgICAgICAgICAgaWYgKGFzQ2hpbGQucm92aW5nVGFiSW5kZXguZm9jdXNTZWxmKSB7XG4gICAgICAgICAgICAgICAgYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChjMiA/PyAwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgcm93THNDaGlsZFJldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogYXNDaGlsZC5tYW5hZ2VkQ2hpbGQsXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc0NoaWxkLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc0NoaWxkLnJvdmluZ1RhYkluZGV4LCBmb2N1c1NlbGYgfSxcbiAgICAgICAgICAgIHN1YkluZm86IGFzQ2hpbGQuc3ViSW5mbyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSByb3dMc0NoaWxkUmV0dXJuVHlwZTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGFiYmFibGUpIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgobnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGFiYmFibGVdKTtcblxuICAgICAgICBjb25zdCByb3dMc1JldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbjxDZWxsRWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4oe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLmFzUGFyZW50Lm1hbmFnZWRDaGlsZHJlbiB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgLi4uYXNQYXJlbnQucm92aW5nVGFiSW5kZXggfSxcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcbiAgICAgICAgICAgICAgICAuLi5hc1BhcmVudC5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb246IFwiaW5saW5lXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC50eXBlYWhlYWROYXZpZ2F0aW9uLCBub1R5cGVhaGVhZDogdHJ1ZSB9LFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4uYXNQYXJlbnQubGlzdE5hdmlnYXRpb24gfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlR3JpZE5hdmlnYXRpb25Db2x1bW4yLCB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtblByb3BzLCBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSB9ID0gcm93THNSZXR1cm5UeXBlO1xuXG4gICAgICAgIC8vY29uc3Qgcm93SGlkZGVuID0gISFhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmhpZGRlbjtcblxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDYWxsYmFjazxVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4+KCh7IHN1YkluZm8sIG1hbmFnZWRDaGlsZCwgbGlzdE5hdmlnYXRpb246IGxzLCByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZjogYnMsIGZvY3VzU2VsZjogZnMsIC4uLnJ0aSB9IH0pID0+IHtcbiAgICAgICAgICAgIC8vcnRpLmhpZGRlbiB8fCByb3dIaWRkZW47XG5cbiAgICAgICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sdW1uKG1hbmFnZWRDaGlsZC5pbmRleCk7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZnMpXG4gICAgICAgICAgICAgICAgICAgIGZzKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5mb2N1cz8uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJsdXJTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChicylcbiAgICAgICAgICAgICAgICAgICAgYnMoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIChydGlfY2VsbF9yZXQuZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik/LmJsdXI/LigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfY2VsbF9yZXRcbiAgICAgICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIoe1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogbWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgLi4ucnRpIH0sXG4gICAgICAgICAgICAgICAgc3ViSW5mb1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8Q2VsbEVsZW1lbnQ+KHtcbiAgICAgICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+ID0ge1xuICAgICAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7IGdldEN1cnJlbnRDb2x1bW4gfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0LFxuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50Pj4ocHJvcHM6IFApIHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VHcmlkTmF2aWdhdGlvbkNvbHVtblByb3BzKHVzZUhhc0ZvY3VzUHJvcHMocHJvcHMpKSk7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4gPSB7XG4gICAgICAgICAgICBhc1BhcmVudE9mQ2VsbHM6IHtcbiAgICAgICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcm93THNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcm93THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNDaGlsZFJvdzogcm93THNDaGlsZFJldHVyblR5cGUsXG5cbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICByZXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBncmlkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgZ2V0Q3VycmVudENvbHVtbixcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW5cbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRMc1JldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudExzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH0gZnJvbSBcIi4vdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5leHBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnMgPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8XCJpZFwiPjtcbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSYW5kb21JZFByb3BzUGFyYW1ldGVycz4gPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGU8UCwgXCJpZFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFwicmVmZXJlbmNlclwiIHwgXCJzb3VyY2VcIiwgbmV2ZXI+IHtcbiAgICByYW5kb21JZDoge1xuICAgICAgICBwcmVmaXg/OiBzdHJpbmc7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUGFyYW1ldGVyczxLIGV4dGVuZHMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pj4gPSBQYXJ0aWFsPFJlY29yZDxLLCBhbnk+PjsvLzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7IH07XG5cblxuZXhwb3J0IHR5cGUgVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8YW55PiwgSyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gT21pdDxQLCBLPiAmIFJlY29yZDxLLCBzdHJpbmc+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIHt9LCBuZXZlcj4ge1xuICAgIHJhbmRvbUlkOiB7XG4gICAgICAgIHVzZWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGVXaXRoSG9va3M8UyBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmFuZG9tSWRSZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ7XG59XG5cbmludGVyZmFjZSBSYW5kb21JZENoaWxkSW5mb0Jhc2Uge1xuICAgIHNldFVzZWRJZChpZDogc3RyaW5nKTogdm9pZDtcbiAgICAvL3NlbmRTb3VyY2VJZFRvUmVmZXJlbmNlckVsZW1lbnQoc291cmNlSWQ6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkU291cmNlRWxlbWVudFJldHVyblR5cGU8UyBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+KSA9PiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8UiBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj47XG59XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBob29rIHRoYXQgbW9kaWZpZXMgYSBzZXQgb2YgcHJvcHMgdG8gcHJvdmlkZSBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqIFxuICogSWYgeW91J2QgbGlrZSB0byB1c2UgdGhlIElEIGluIGEgcHJvcGVydHkgdGhhdCdzICpub3QqIG5hbWVkIGBpZGAgKGxpa2UgYGZvcmAgb3IgYGFyaWEtbGFiZWxsZWRieWAgb3Igd2hhdG5vdCksIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaXMgYWxzbyBwcm92aWRlZC5cbiAqIFxuICogQW5kIHRoZSByYW5kb21seS1nZW5lcmF0ZWQgaWQgaXRzZWxmIGlzIGFsc28gcHJvdmlkZWQgaW4gY2FzZSB5b3Ugd2FudCB0byBoYW5kbGUgdGhlIGxvZ2ljIHlvdXJzZWxmIHdpdGhvdXQgYHVzZU1lcmdlZFByb3BzYC5cbiAqIFxuICogVW5saWtlIG1vc3Qgb3RoZXIgYHVzZSpQcm9wc2AgaG9va3MsIHRoZXNlIGFyZSBtb3N0bHkgc3RhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tSWQ8UyBleHRlbmRzIEVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZVJhbmRvbUlkUGFyYW1ldGVycyk6IFVzZVJhbmRvbUlkUmV0dXJuVHlwZVdpdGhIb29rczxTPiB7XG4gICAgY29uc3QgW2JhY2t1cFJhbmRvbUlkLCAsIGdldEJhY2t1cFJhbmRvbUlkXSA9IHVzZVN0YXRlPHN0cmluZz4oKCkgPT4gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXgpKTtcbiAgICBjb25zdCBbdXNlZElkLCBzZXRVc2VkSWQsIGdldFVzZWRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KCgpID0+IGdldEJhY2t1cFJhbmRvbUlkKCkpO1xuICAgIGNvbnN0IG1pc21hdGNoRXJyb3JSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJhbmRvbUlkXCIsIHByZWZpeCk7XG5cbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgLi4ubWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPFwicmVmZXJlbmNlclwiIHwgXCJzb3VyY2VcIiwgUmFuZG9tSWRDaGlsZEluZm9CYXNlLCBuZXZlcj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9KTtcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50ID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50PFM+PigoKSA9PiB7XG4gICAgICAgIGNvbnN0IFt1c2VkSWRMb2NhbCwgc2V0VXNlZElkTG9jYWwsIGdldFVzZWRJZExvY2FsXSA9IHVzZVN0YXRlKGdldFVzZWRJZCgpKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8Uz4oKTtcbiAgICAgICAgLy8gRXZlcnkgdGltZSB0aGUgc291cmNlIGVsZW1lbnQgcmVuZGVycywgaW5zcGVjdCB0aGUgSUQgaXQgYWN0dWFsbHkgdXNlZFxuICAgICAgICAvLyAod2hldGhlciBpdCB3YXMgb3VycyBvciBub3QgaXNuJ3QgdXAgdG8gdXMsIGl0J3MgdXAgdG8gdGhlIGNvbXBvbmVudClcbiAgICAgICAgLy8gc28gdGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSByZWZlcmVuY2VyIGNvbXBvbmVudCBvZiBjaGFuZ2VzXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KFwicmVmZXJlbmNlclwiKSEuc3ViSW5mby5zZXRVc2VkSWQoZWxlbWVudC5pZCk7XG4gICAgICAgICAgICAgICAgc2V0VXNlZElkKGVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4OiBcInNvdXJjZVwiLCBzdWJJbmZvOiB7IHNldFVzZWRJZDogc2V0VXNlZElkTG9jYWwgfSB9IH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPltcInVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzXCJdPihmdW5jdGlvbiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz4pIHtcbiAgICAgICAgICAgIHAuaWQgfHw9IGJhY2t1cFJhbmRvbUlkO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyhwKTtcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZWRJZDogdXNlZElkTG9jYWwsXG4gICAgICAgICAgICBnZXRVc2VkSWQ6IGdldFVzZWRJZExvY2FsLFxuICAgICAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHNcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudD4oPFIgZXh0ZW5kcyBFbGVtZW50PihpZFByb3BOYW1lOiBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIC8vIFdoYXRldmVyIElEIHdhcyBtb3N0IHJlY2VudGx5IHVzZWQgYnkgdGhlIGFjdHVhbCBcImlkXCIgcHJvcCBvZiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgdXNlRW5zdXJlU3RhYmlsaXR5KGlkUHJvcE5hbWUpO1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4OiBcInJlZmVyZW5jZXJcIiwgc3ViSW5mbzogeyBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSB9KTtcblxuICAgICAgICBjb25zdCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPltcInVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wc1wiXT4oZnVuY3Rpb24gPFIgZXh0ZW5kcyBFbGVtZW50Pih7IFtpZFByb3BOYW1lXTogZ2l2ZW5JZCwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikge1xuICAgICAgICAgICAgaWYgKGdpdmVuSWQgJiYgdXNlZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdpdmVuSWQgIT0gdXNlZElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWlzbWF0Y2hFcnJvclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNtYXRjaEVycm9yUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgbWlzLW1hdGNoZWQgSURzIHdlcmUgcHJvdmlkZWQgZm9yIHRoZSAke2lkUHJvcE5hbWV9IHByb3A6IHRoZSBjaGlsZCBleHBsaWNpdGx5IHNwZWNpZmllZCAke2dpdmVuSWR9IGluIGl0cyAgJHtpZFByb3BOYW1lfSBwcm9wLCBidXQgdGhlIHBhcmVudCB0b2xkIHRoaXMgY2hpbGQgdG8gdXNlICR7dXNlZElkfSAodGhlIHBhcmVudCdzIElEKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxSPihwLCB7IFtpZFByb3BOYW1lXTogdXNlZElkIH0pO1xuICAgICAgICB9LCBbdXNlZElkXSk7XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlZElkOiB1c2VkSWRMb2NhbCxcbiAgICAgICAgICAgIGdldFVzZWRJZDogZ2V0VXNlZElkTG9jYWwsXG4gICAgICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHNcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmRvbUlkOiB7XG4gICAgICAgICAgICB1c2VkSWQsXG4gICAgICAgICAgICBnZXRVc2VkSWRcbiAgICAgICAgfSxcbiAgICAgICAgLi4ubWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSxcbiAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LFxuICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxubGV0IHB1bHNlID0gKFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcikgPyAoKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApKSA6ICgoKSA9PiB7IH0pO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZW5hYmxlL2Rpc2FibGUgYnV0dG9uIHZpYnJhdGlvbiBwdWxzZXMgb24gYW4gYXBwLXdpZGUgc2NhbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGEgYnV0dG9uIGlzIHRhcHBlZC5cbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEJ1dHRvblZpYnJhdGUoZnVuYzogKCkgPT4gdm9pZCkge1xuICAgIHB1bHNlID0gZnVuYztcbn1cblxuZXhwb3J0IHR5cGUgQnV0dG9uUHJlc3NFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudD4gPSBFdmVudFR5cGUgJiB7IFtFdmVudERldGFpbF06IHsgcHJlc3NlZDogYm9vbGVhbiB8IG51bGwgfSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBUYWdTZW5zaXRpdmVQcm9wczxFPiB7XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuIHwgXCJzb2Z0XCIgfCBcImhhcmRcIjtcbiAgICBwcmVzc2VkPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgb25QcmVzcz8oZXZlbnQ6IEJ1dHRvblByZXNzRXZlbnQ8aC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+PiB8IEJ1dHRvblByZXNzRXZlbnQ8aC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+IHwgQnV0dG9uUHJlc3NFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+Pj4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFCdXR0b25SZXR1cm5UeXBlPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlQXJpYUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbn1cblxuXG5mdW5jdGlvbiBleGNsdWRlcyh0YXJnZXQ6IFwiY2xpY2tcIiB8IFwic3BhY2VcIiB8IFwiZW50ZXJcIiwgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBpZiAoZXhjbHVkZT8uW3RhcmdldF0pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHNlbGVjdGlvbi5jb250YWluc05vZGUgZG9lc24ndCBhY2NvdW50IGZvciBzZWxlY3Rpb24uaXNDb2xsYXBzZWQsXG4gKiBzbyBoZXJlJ3MgYSB3b3JrYXJvdW5kIGZvciB0aGF0LlxuICogXG4gKiBXZSBhbHNvIG9ubHkgbG9vayBmb3IgdGhlIHNlbGVjdGlvbiBlbmQgdG8gb25seSBjYXRjaCB0aGUgXG4gKiBlc3NlbnNlIG9mIGEgbm9uLWV4aXN0YW50IFwic2VsZWN0aW9uc3RvcFwiIGV2ZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzZWxlY3Rpb24/LnJhbmdlQ291bnQgPz8gMCk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24hLmdldFJhbmdlQXQoaSkhO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJiAhc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24hLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHRvIGNyZWF0ZSBhIFwicHJlc3NcIi1saWtlIGV2ZW50IGZvclxuICogYnV0dG9ucyBhbmQgYW55dGhpbmcgZWxzZSB0aGF0J3MgXCJjbGljay90YXAvcHJlc3MvdG91Y2hcIi1hYmxlLlxuICogXG4gKiBOb3RhYmx5LCB0aGUgZm9sbG93aW5nIGNhc2VzIGFyZSBjb3ZlcmVkOlxuICogKiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgcHJvcGVybHkgZm9jdXNlZCwgZXZlbiBvbiBpT1MgU2FmYXJpICgqZXNwZWNpYWxseSogb24gaU9TIFNhZmFyaSlcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXG4gKiAqIENvbnZlcnNlbHksIG1hbnVhbGx5IHNlbGVjdGluZyB0ZXh0IHdvbid0IGludm9rZSBhIHByZXNzLlxuICogKiBLZXlib2FyZCBldmVudHMgJm1kYXNoOyBgZW50ZXJgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGhhbmRsZXIsIHdoaWxlIGBzcGFjZWAgaW52b2tlcyBpdCBvbiBrZXl1cC5cbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcbiAqIFxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcbiAqIFxuICogQHBhcmFtIG9uQ2xpY2tTeW5jIFxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkbid0IGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc3NFdmVudEhhbmRsZXJzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ob25DbGlja1N5bmM6ICgoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkLCBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcblxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PEU+KHt9KTtcblxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcbiAgICAvLyB0aGF0IG11bHRpcGxlIGFyZSB0cmlnZ2VyZWQgYXQgb25jZSwgd2Ugb25seSAqYWN0dWFsbHkqIHJlZ2lzdGVyXG4gICAgLy8gYSBwcmVzcyBvbmNlIGFsbCBvZiBvdXIgXCJvblwiIHNpZ25hbHMgaGF2ZSB0dXJuZWQgYmFjayB0byBcIm9mZlwiLlxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxuICAgIC8vIGRlY3JlbWVudGluZyB3aGVuIGRlYWN0aXZhdGVkLlxuICAgIC8vXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxuICAgIC8vIHRoaXMgaXMgcmVzZXQgYmFjayB0byAwLlxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZSwgZ2V0QWN0aXZlXSA9IHVzZVN0YXRlKDApO1xuXG4gICAgLy8gSWYgd2UgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcyB0byBpbmNsdWRlIHRoaXMgZWxlbWVudFxuICAgIC8vIERVUklORyBlLmcuIGEgbW91c2Vkb3duLCB0aGVuIHdlIGRvbid0IHdhbnQgdGhlIG1vdXNldXAgdG8gXCJjb3VudFwiLCBhcyBpdCB3ZXJlLFxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxuICAgIC8vXG4gICAgLy8gVG8gY2F0Y2ggdGhpcywgYW55IHRpbWUgdGhlIHRleHQgc2VsZWN0aW9uIGluY2x1ZGVzIHVzIHdoaWxlIGluIHRoZSBtaWRkbGVcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXG4gICAgLy8gVGhlIGZsYWcgaXMgcmVzZXQgYW55IHRpbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBvciB0aGUgYnV0dG9uIGlzXG4gICAgLy8gbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCBfID0+IHtcbiAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShwcmV2ID0+IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA9PSAwID8gbnVsbCA6IHByZXYgIT0gbnVsbCA/IHByZXYgOiBuZXcgRGF0ZSgpKTtcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XG4gICAgfSwgW2FjdGl2ZSA9PSAwXSk7XG5cbiAgICBjb25zdCBvbkFjdGl2ZVN0YXJ0ID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKF8pID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gKythKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RvcCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZShhID0+IE1hdGgubWF4KDAsIC0tYSkpO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZURpZmZlcmVuY2UgPSAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsID8gbnVsbCA6ICtjdXJyZW50VGltZSAtICt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyc1NlbGVjdGVkID0gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpXG5cbiAgICAgICAgLy8gSWYgd2UncmUgc2VsZWN0aW5nIHRleHQgKGhldXJpc3RpY2FsbHkgZGV0ZXJtaW5lZCBieSBzZWxlY3RpbmcgZm9yIGxvbmdlciB0aGFuIDEvNCBhIHNlY29uZCwgb3IgbW9yZSB0aGFuIDIgY2hhcmFjdGVycylcbiAgICAgICAgLy8gdGhlbiB0aGlzIGlzbid0IGEgcHJlc3MgZXZlbnQuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG1lYXN1cmUgZ2x5cGhzIGluc3RlYWQgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoYXJhY3RlcnNTZWxlY3RlZCA+IDEgfHwgKCh0aW1lRGlmZmVyZW5jZSA/PyAwKSA+IDI1MCAmJiBjaGFyYWN0ZXJzU2VsZWN0ZWQgPj0gMSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZXRBY3RpdmUoKSA8PSAwKSB7XG4gICAgICAgICAgICBoYW5kbGVQcmVzcyhlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaGFuZGxlUHJlc3MgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoZSkgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcblxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBoZXJlIGJlY2F1c2Ugb2YgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJdCdzIGFsd2F5cyBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlPUyBTYWZhcmkgKHRlc3RlZCBvbiAxMikgZG93bnJpZ2h0IHJlZnVzZXMgdG8gYWxsb3cgXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0byBiZSBtYW51YWxseSBmb2N1c2VkIFVOTEVTUyBpdCBoYXBwZW5zIHdpdGhpblxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXMuICBJdCBhbHNvIGRvZXNuJ3QgZm9jdXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbnMgYnkgZGVmYXVsdCB3aGVuIGNsaWNrZWQsIHRhcHBlZCwgZXRjLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIGl0IGJlY29tZXMgcHJvYmxlbWF0aWMgdGhhdCBidXR0b24tbGlrZXMgZXhwbGljaXRseSBiZWNvbWVcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgd2hlbiB0aGV5IGFyZSBwcmVzc2VkLCB0aGVuIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIGZvclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXN0aW9uIG9mIFwiaG93IGRvIG1lbnUgYnV0dG9ucyBrZWVwIHRoZWlyIG1lbnVzIG9wZW5cIlxuICAgICAgICAgICAgLy8gYW5kIG90aGVyIGZvY3VzLXJlbGF0ZWQgbm9uc2Vuc2UgbmVlZHMgdG8gYmUgZmlndXJlZCBvdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRm9yIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIFwiZm9jdXNcIiBpbiAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXMoKTtcblxuICAgICAgICAgICAgLy8gV2hhdGV2ZXIgdGhlIGJyb3dzZXIgd2FzIGdvaW5nIHRvIGRvIHdpdGggdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIGZvcmdldCBpdC4gV2UncmUgdHVybmluZyBpdCBpbnRvIGEgXCJwcmVzc1wiIGV2ZW50LlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAvLyBBbHNvIHN0b3AgYW55b25lIGVsc2UgZnJvbSBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4cGxpY2l0bHkgaGFuZGxpbmcgaXQuXG4gICAgICAgICAgICAvLyAoTm90YWJseSwgdGhpcyBhbGxvd3MgbGFiZWxzIHRvIHdyYXAgaW5wdXRzLCB3aXRoIHRoZW1cbiAgICAgICAgICAgIC8vIGJvdGggaGF2aW5nIHByZXNzIGV2ZW50IGhhbmRsZXJzLCB3aXRob3V0IGRvdWJsZS1maXJpbmcpXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBIYXB0aWMgZmVlZGJhY2sgZm9yIHRoaXMgcHJlc3MgZXZlbnRcbiAgICAgICAgICAgIHB1bHNlKCk7XG5cbiAgICAgICAgICAgIC8vIEFjdHVhbGx5IGNhbGwgb3VyIGhhbmRsZXIuXG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICAvLyBTdG9wIGRvdWJsZSBjbGlja3MgZnJvbSBzZWxlY3RpbmcgdGV4dCBpbiBhbiBjb21wb25lbnQgdGhhdCdzICpzdXBwb3NlZCogdG8gYmUgYWN0aW5nIGxpa2UgYSBidXR0b24sXG4gICAgICAgIC8vIGJ1dCBhbHNvIGRvbid0IHByZXZlbnQgdGhlIHVzZXIgZnJvbSBzZWxlY3RpbmcgdGhhdCB0ZXh0IG1hbnVhbGx5IGlmIHRoZXkgcmVhbGx5IHdhbnQgdG9cbiAgICAgICAgLy8gKHdoaWNoIHVzZXItc2VsZWN0OiBub25lIHdvdWxkIGRvLCBidXQgY2FuY2VsbGluZyBhIGRvdWJsZSBjbGljayBvbiBtb3VzZURvd24gZG9lc24ndClcbiAgICAgICAgaWYgKGUuZGV0YWlsID4gMSlcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuXG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMClcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgfVxuICAgIGNvbnN0IG9uTW91c2VVcCA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBhY3RpdmUgPiAwKVxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkJsdXIgPSAoXzogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoMCk7XG4gICAgfVxuXG5cbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogb25CbHVyO1xuXG4gICAgY29uc3Qgb25LZXlEb3duID0gZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSAmJiBleGNsdWRlcyhcImVudGVyXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgb25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGFjdGl2YXRlIGl0IG9uIGEgc3BhY2Uga2V5ZG93blxuICAgICAgICAgICAgLy8gYnV0IHdlIGRvIHByZXZlbnREZWZhdWx0IHRvIHN0b3AgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcuXG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUua2V5ID09IFwiRW50ZXJcIiAmJiAhZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9uS2V5VXAgPSBleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb25DbGljayA9IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKSB7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMoKHsgb25LZXlEb3duLCBvbktleVVwLCBvbkJsdXIsIG9uTW91c2VEb3duLCBvbk1vdXNlVXAsIG9uTW91c2VMZWF2ZSwgb25DbGljaywgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsIC4uLnsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogYWN0aXZlICYmICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwpID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyB7fSB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQnV0dG9uPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyB0YWcsIHByZXNzZWQsIG9uUHJlc3MsIGRpc2FibGVkIH06IFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEU+KTogVXNlQXJpYUJ1dHRvblJldHVyblR5cGU8RT4ge1xuICAgIGRlYnVnTG9nKFwidXNlQXJpYUJ1dHRvblwiKTtcblxuICAgIGZ1bmN0aW9uIHVzZUFyaWFCdXR0b25Qcm9wcyh7IFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkLCB0YWJJbmRleCwgcm9sZSwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcblxuICAgICAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzPEU+KHVzZVByZXNzRXZlbnRIYW5kbGVyczxFPigoZSkgPT4gKGRpc2FibGVkID8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSwgdW5kZWZpbmVkKSwgcCk7XG5cbiAgICAgICAgY29uc3QgYmFzZVByb3BzID0geyByb2xlLCB0YWJJbmRleCwgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQgPz8gKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xuICAgICAgICBjb25zdCBidXR0b25Qcm9wcyA9IHsgLi4uYmFzZVByb3BzLCBkaXNhYmxlZDogKGRpc2FibGVkICYmIGRpc2FibGVkICE9IFwic29mdFwiKSA/IHRydWUgOiBmYWxzZSwgXCJhcmlhLWRpc2FibGVkXCI6IChkaXNhYmxlZCA9PT0gJ3NvZnQnID8gJ3RydWUnIDogdW5kZWZpbmVkKSB9O1xuICAgICAgICBjb25zdCBkaXZQcm9wcyA9IHsgLi4uYmFzZVByb3BzLCB0YWJJbmRleDogdGFiSW5kZXggPz8gKGRpc2FibGVkID09PSBcImhhcmRcIiA/IC0xIDogMCksIHJvbGU6IHJvbGUgPz8gXCJidXR0b25cIiwgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oYnV0dG9uUHJvcHMsIHByb3BzKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oZGl2UHJvcHMsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUFyaWFCdXR0b25Qcm9wc1xuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCByZXR1cm5UcnVlLCB1c2VDaGlsZHJlbkZsYWcsIHVzZUhhc0ZvY3VzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZyB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VBcmlhQnV0dG9uLCBVc2VBcmlhQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcblxuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBcmlhQWNjb3JkaW9uUGFyYW1ldGVycykgPT4gVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+KSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8XCJuYXZpZ2F0ZVRvRmlyc3RcIiB8IFwibmF2aWdhdGVUb0xhc3RcIiB8IFwibmF2aWdhdGVUb05leHRcIiB8IFwibmF2aWdhdGVUb1ByZXZcIj4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xuICAgIGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXg/OiBudW1iZXIgfCBudWxsOyB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCI+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGFjY29yZGlvbjogeyBjaGFuZ2VFeHBhbmRlZEluZGV4OiAoYXJnOiBudW1iZXIgfCAoKHByZXZTdGF0ZTogbnVtYmVyIHwgbnVsbCkgPT4gbnVtYmVyIHwgbnVsbCkgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsOyB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb246IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlIHtcbiAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRPcGVuRnJvbVBhcmVudCgpOiBib29sZWFuIHwgbnVsbDtcbiAgICBmb2N1cygpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIG1hbmFnZWRDaGlsZHJlbjogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSW5mb0Jhc2UsIFwidGFiYmVkXCIgfCBcIm9wZW5cIiwgXCJzdWJJbmZvXCIgfCBcImZsYWdzXCI+W1wibWFuYWdlZENoaWxkXCJdO1xuICAgIGFjY29yZGlvblNlY3Rpb246IHsgb3Blbj86IGJvb2xlYW4gfCB1bmRlZmluZWQ7IH1cbiAgICBidXR0b246IE9taXQ8VXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwib25QcmVzc1wiIHwgXCJwcmVzc2VkXCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIGFjY29yZGlvblNlY3Rpb246IHtcbiAgICAgICAgZXhwYW5kZWQ6IGJvb2xlYW47XG4gICAgICAgIGZvY3VzZWQ6IGJvb2xlYW47XG4gICAgICAgIGhlYWRlcklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIGJvZHlJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICBnZXRIZWFkZXJJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIGdldEJvZHlJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD47XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pjtcbn1cblxuXG4vL2V4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBcmlhQnV0dG9uUGFyYW1ldGVyczxFPikgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEU+O1xuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4geyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfVxuLy9leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHk8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UmV0dXJuVHlwZTxFPjtcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50Pih7IGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXggfSwgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfTogVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMpOiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD4ge1xuICAgIGRlYnVnTG9nKFwidXNlQXJpYUFjY29yZGlhblwiKTtcbiAgICBjb25zdCBbX2N1cnJlbnRGb2N1c2VkSW5kZXgsIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgsIGdldEN1cnJlbnRGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCI+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4geyBvY21jMigpOyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihtLCB1KTsgfSksXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQsIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBtY1JldHVyblR5cGU7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvRmlyc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KDApOyB9LCBbXSk7XG4gICAgY29uc3QgbmF2aWdhdGVUb0xhc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpKTsgfSwgW10pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpID0+ICgoaSA/PyAwKSAtIDEpKSB9LCBbXSk7XG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGkgPT4gKChpID8/IDApICsgMSkpIH0sIFtdKTtcbiAgICBjb25zdCBsaW5lYXJSZXR1cm5UeXBlID0gdXNlTGluZWFyTmF2aWdhdGlvbjxIZWFkZXJFbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0LFxuICAgICAgICAgICAgbmF2aWdhdGVUb05leHQsXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldixcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuYXZpZ2F0aW9uRGlyZWN0aW9uID8/IFwiYmxvY2tcIlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gbGluZWFyUmV0dXJuVHlwZTtcblxuXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlRXhwYW5kZWRJbmRleCwgZ2V0Q3VycmVudEluZGV4OiBfZ2V0Q3VycmVudEV4cGFuZGVkSW5kZXggfSA9IHVzZUNoaWxkcmVuRmxhZyh7XG4gICAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGtleTogXCJvcGVuXCIsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGNoYW5nZUluZGV4OiBjaGFuZ2VUYWJiZWRJbmRleCwgZ2V0Q3VycmVudEluZGV4OiBfZ2V0VGFiYmVkSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiBvY21jMiB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAga2V5OiBcInRhYmJlZFwiLFxuICAgICAgICBjbG9zZXN0Rml0OiB0cnVlLFxuICAgICAgICBvbkluZGV4Q2hhbmdlOiB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGkpPy5zdWJJbmZvLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pXG5cbiAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbjogVXNlQXJpYUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2s8VXNlQXJpYUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+PigoeyBidXR0b246IHsgdGFnLCBkaXNhYmxlZCB9LCBhY2NvcmRpb25TZWN0aW9uOiB7IG9wZW46IG9wZW5Gcm9tVXNlciB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXggfSB9KSA9PiB7XG5cbiAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhQWNjb3JkaWFuU2VjdGlvblwiKTtcbiAgICAgICAgY29uc3QgW29wZW5Gcm9tUGFyZW50LCBzZXRPcGVuRnJvbVBhcmVudCwgZ2V0T3BlbkZyb21QYXJlbnRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xuXG5cblxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlQm9keUFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkLCByYW5kb21JZDogeyB1c2VkSWQ6IGJvZHlJZCwgZ2V0VXNlZElkOiBnZXRCb2R5SWQgfSB9ID0gdXNlUmFuZG9tSWQ8Qm9keUVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtYWNjb3JkaW9uLXNlY3Rpb24tYm9keS1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUhlYWRlckFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUJvZHlBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBoZWFkZXJJZCwgZ2V0VXNlZElkOiBnZXRIZWFkZXJJZCB9IH0gPSB1c2VSYW5kb21JZDxIZWFkZXJFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWhlYWRlci1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlQm9keUFzU291cmNlSWRQcm9wcyB9ID0gdXNlQm9keUFzU291cmNlSWQoKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUJvZHlBc1JlZmVyZW5jZXJJZFByb3BzIH0gPSB1c2VCb2R5QXNSZWZlcmVuY2VySWQ8Qm9keUVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUhlYWRlckFzU291cmNlSWQoKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkPEhlYWRlckVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcblxuICAgICAgICBjb25zdCBvcGVuID0gKChvcGVuRnJvbVVzZXIgPz8gb3BlbkZyb21QYXJlbnQpID8/IGZhbHNlKTtcbiAgICAgICAgLy9jb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKCEhb3Blbik7XG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcblxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEhlYWRlckVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlSGVhZGVyUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEhlYWRlckVsZW1lbnQ+KHt9KTtcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRCb2R5RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VCb2R5UmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEJvZHlFbGVtZW50Pih7fSk7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIChnZXRIZWFkZXJFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk/LmZvY3VzKCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgY29uc3Qgb3BlblJlZiA9IHVzZVJlZih7XG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0T3BlbkZyb21QYXJlbnQoKSxcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBib2R5RWxlbWVudC5mb2N1cygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiByZXR1cm5UcnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0YWJiZWRSZWYgPSB1c2VSZWYoe1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpID09IGdldEluZGV4KCkpLFxuICAgICAgICAgICAgc2V0OiAob3BlbjogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuKVxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Rm9jdXNlZEluZGV4KGdldEluZGV4KCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9fOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICBvcGVuOiBvcGVuUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRhYmJlZDogdGFiYmVkUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIGdldE9wZW5Gcm9tUGFyZW50LFxuICAgICAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gaW5mbzogeyBpbmRleCwgc2V0T3BlbkZyb21QYXJlbnQsIGdldE9wZW5Gcm9tUGFyZW50LCBmb2N1cywgZmxhZ3M6IHsgb3Blbjogb3BlblJlZi5jdXJyZW50LCB0YWJiZWQ6IHRhYmJlZFJlZi5jdXJyZW50IH0gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4ge1xuXG4gICAgICAgICAgICAvL2NvbnN0IG9uRm9jdXMgPSAoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGluZGV4KTsgfVxuICAgICAgICAgICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0T3BlbkZyb21QYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChudWxsKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgeyB1c2VBcmlhQnV0dG9uUHJvcHMgfSA9IHVzZUFyaWFCdXR0b24oeyB0YWcsIGRpc2FibGVkLCBvblByZXNzIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV0QiA9IHVzZUFyaWFCdXR0b25Qcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAvL2NvbnN0IHJldEIgPSB1c2VNZXJnZWRQcm9wczxIZWFkZXJFbGVtZW50Pih1c2VQcmVzc0V2ZW50SGFuZGxlcnM8SGVhZGVyRWxlbWVudD4ob25DbGljaywgdW5kZWZpbmVkKSwgcHJvcHMpO1xuXG5cblxuICAgICAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIZWFkZXJFbGVtZW50Pih7XG4gICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRhYmJlZEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy9jb25zdCByZXQzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PlxuICAgICAgICAgICAgLy8gICAgPSB1c2VNZXJnZWRQcm9wczxIZWFkZXJFbGVtZW50PihyZXRELCB7IG9uRm9jdXMgfSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIHVzZUhhc0ZvY3VzUHJvcHModXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyh1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzKHtcbiAgICAgICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGFyaWFFeHBhbmRlZCA/PyBvcGVuID8/IGZhbHNlKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgICAgICAuLi51c2VIZWFkZXJSZWZFbGVtZW50UHJvcHMocmV0QilcbiAgICAgICAgICAgIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pKSkpO1xuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh7IHJvbGUsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiB7XG4gICAgICAgICAgICBjb25zdCByZXQxID0gdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMoeyByb2xlOiByb2xlID8/IFwicmVnaW9uXCIsIC4uLnByb3BzIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUJvZHlBc1NvdXJjZUlkUHJvcHMocmV0MSk7XG4gICAgICAgICAgICByZXQyLnRhYkluZGV4ID8/PSAtMTtcbiAgICAgICAgICAgIHJldHVybiB1c2VCb2R5UmVmRWxlbWVudFByb3BzKHJldDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY29yZGlvblNlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZDogb3BlbixcbiAgICAgICAgICAgICAgICBmb2N1c2VkOiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpID09IGluZGV4KSxcbiAgICAgICAgICAgICAgICBib2R5SWQsXG4gICAgICAgICAgICAgICAgaGVhZGVySWQsXG4gICAgICAgICAgICAgICAgZ2V0Qm9keUlkLFxuICAgICAgICAgICAgICAgIGdldEhlYWRlcklkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyxcbiAgICAgICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzLFxuXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIGFjY29yZGlvbjogeyBjaGFuZ2VFeHBhbmRlZEluZGV4IH0sXG4gICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uLFxuICAgIH1cbn1cblxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUHJlc3NFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xuXG5pbnRlcmZhY2UgVUxJPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBwcmVmaXhMYWJlbDogc3RyaW5nO1xuICAgIHByZWZpeElucHV0OiBzdHJpbmc7XG4gICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJbnB1dEVsZW1lbnQ+O1xuICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IHR5cGUgTGFiZWxPbWl0cyA9IGtleW9mIFVMSTxhbnksIGFueT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExPbWl0cyBleHRlbmRzIExhYmVsT21pdHM+IHtcbiAgICBsYWJlbDogT21pdDxVTEk8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBMT21pdHM+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxSZXR1cm5UeXBlSW5mbyB7XG4gICAgbGFiZWw6IHtcbiAgICAgICAgbGFiZWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICBpbnB1dElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIC8qKiAqKlN0YWJsZSoqICovXG4gICAgICAgIGdldExhYmVsSWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqICoqU3RhYmxlKiogKi9cbiAgICAgICAgZ2V0SW5wdXRJZDogKCkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcbiAgICAvKiogKk5vdGFibHkgdW5zdGFibGUqICovXG4gICAgdXNlTGFiZWxJbnB1dDogKCkgPT4geyB1c2VMYWJlbElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjsgfTtcbiAgICAvKiogKk5vdGFibHkgdW5zdGFibGUqICovXG4gICAgdXNlTGFiZWxMYWJlbDogKCkgPT4geyB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfTtcbn1cblxuLyoqXG4gKiBBZGRzIGFuIElEIGFuZCBcImFyaWEtbGFiZWxsZWRieVwiIGZvciB0d28gZWxlbWVudHMsIGFuIFwiaW5wdXRcIiBlbGVtZW50IGFuZCBhIFwibGFiZWxcIiBlbGVtZW50LlxuICogXG4gKiBSZXR1cm5zIHRoZSBgdXNlUmVmZXJlbmNlZElkUHJvcHNgIGhvb2tzIGlmIHlvdSBuZWVkIHRvIGFsc28gYWRkIG90aGVyIElELXJlZmVyZW5jZXIgYXR0cmlidXRlcywgbGlrZSBgZm9yYFxuICogXG4gKiBAc2VlIHVzZUlucHV0TGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxhYmVsPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGFiZWw6IHsgcHJlZml4SW5wdXQsIHByZWZpeExhYmVsLCB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9OiBVc2VMYWJlbFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIG5ldmVyPik6IFVzZUxhYmVsUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xuXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUxhYmVsQXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlTGFiZWxBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBsYWJlbElkLCBnZXRVc2VkSWQ6IGdldExhYmVsSWQgfSB9ID0gdXNlUmFuZG9tSWQ8TGFiZWxFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogcHJlZml4TGFiZWwgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUlucHV0QXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlSW5wdXRBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBpbnB1dElkLCBnZXRVc2VkSWQ6IGdldElucHV0SWQgfSB9ID0gdXNlUmFuZG9tSWQ8SW5wdXRFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogcHJlZml4SW5wdXQgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlTGFiZWxBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUxhYmVsQXNTb3VyY2VJZCgpO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUlucHV0QXNTb3VyY2VJZFByb3BzIH0gPSB1c2VJbnB1dEFzU291cmNlSWQoKTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzIH0gPSB1c2VMYWJlbEFzUmVmZXJlbmNlcklkPElucHV0RWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUlucHV0QXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZDxMYWJlbEVsZW1lbnQ+KFwiZm9yXCIpO1xuXG4gICAgY29uc3QgaXNTeW50aGV0aWNMYWJlbCA9ICh0YWdJbnB1dCAhPSBcImlucHV0XCIgfHwgdGFnTGFiZWwgIT0gXCJsYWJlbFwiKTtcblxuICAgIGNvbnN0IHVzZUxhYmVsTGFiZWw6ICgoKSA9PiB7IHVzZUxhYmVsTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9KSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxhYmVsTGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzV2l0aG91dEZvciA9IHVzZUxhYmVsQXNTb3VyY2VJZFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhGb3IgPSB1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMocHJvcHNXaXRob3V0Rm9yKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnTGFiZWwgPT0gXCJsYWJlbFwiICYmIHRhZ0lucHV0ID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aEZvcjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhvdXRGb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbaXNTeW50aGV0aWNMYWJlbF0pO1xuXG4gICAgY29uc3QgdXNlTGFiZWxJbnB1dCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxhYmVsSW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VMYWJlbElucHV0UHJvcHM6ICh7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZGJ5LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIWFyaWFMYWJlbGxlZGJ5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5ID0gdXNlSW5wdXRBc1NvdXJjZUlkUHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTeW50aGV0aWNMYWJlbCAmJiAhcHJvcHNbXCJhcmlhLWxhYmVsXCJdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRoQXJpYUxhYmVsbGVkQnk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtpc1N5bnRoZXRpY0xhYmVsXSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxhYmVsSW5wdXQsXG4gICAgICAgIHVzZUxhYmVsTGFiZWwsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBsYWJlbElkLFxuICAgICAgICAgICAgaW5wdXRJZCxcbiAgICAgICAgICAgIGdldExhYmVsSWQsXG4gICAgICAgICAgICBnZXRJbnB1dElkXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5cblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hDaGVja2VkVHlwZSA9IGJvb2xlYW4gfCBcIm1peGVkXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbGFiZWw6IFVzZUxhYmVsUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgXCJwcmVmaXhMYWJlbFwiIHwgXCJwcmVmaXhJbnB1dFwiPltcImxhYmVsXCJdO1xuICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XG4gICAgICAgIC8qKiBUaGUgcm9sZSBhdHRyaWJ1dGUgdG8gdXNlLCB3aGVuIGFwcGxpY2FibGUgKi9cbiAgICAgICAgcm9sZTogc3RyaW5nO1xuICAgICAgICBkaXNhYmxlZDogYm9vbGVhbjtcbiAgICAgICAgY2hlY2tlZDogQ2hlY2tib3hDaGVja2VkVHlwZTtcbiAgICAgICAgb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik6IHZvaWQ7XG4gICAgICAgIG9uSW5wdXQ/KGV2ZW50OiBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pOiB2b2lkO1xuICAgIH1cbn1cblxuY29uc3QgaGFuZGxlc0lucHV0ID0gPEUgZXh0ZW5kcyBFbGVtZW50Pih0YWc6IEVsZW1lbnRUb1RhZzxFPiwgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiLCB3aGljaDogXCJpbnB1dC1lbGVtZW50XCIgfCBcImxhYmVsLWVsZW1lbnRcIikgPT4ge1xuICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSBcInNlcGFyYXRlXCIpIHtcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIGlmICh3aGljaCA9PT0gXCJsYWJlbC1lbGVtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gdGFnICE9IFwiaW5wdXRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh3aGljaCA9PSBcImxhYmVsLWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHtcbiAgICBnZXRJbnB1dEVsZW1lbnQ6ICgpID0+IElucHV0VHlwZSB8IG51bGw7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50PExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcbiAgICBjaGVja2JveExpa2U6IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0TGFiZWxFbGVtZW50OiAoKSA9PiBMYWJlbFR5cGUgfCBudWxsO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRJbnB1dEVsZW1lbnQ6ICgpID0+IElucHV0VHlwZSB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIC8qKiAqTm90YWJseSB1bnN0YWJsZSogKi9cbiAgICB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ6IFVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDxJbnB1dFR5cGU+O1xuICAgIC8qKiAqTm90YWJseSB1bnN0YWJsZSogKi9cbiAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQ6ICgpID0+IHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT47IH07XG59XG5cbi8qKlxuICogSGFuZGxlcyBsYWJlbCB0eXBlICh3cmFwcGluZyBvciBzZXBhcmF0ZSkgZm9yIGNoZWNrYm94ZXMsIHJhZGlvcywgc3dpdGNoZXMsIGV0Yy5cbiAqIFxuICogSWYgaXQncyBhIHRvZ2dsZWFibGUgY2xpY2stdGhpbmcgd2l0aCBhIGxhYmVsICh0aGF0IGNhbiBhbHNvIGJlIGNsaWNrZWQpLCB0aGVuIGl0J3MgYSBjaGVja2JveC1saWtlLlxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCByb2xlLCBvbklucHV0IH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9IH06IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KTogVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuXG4gICAgY29uc3Qgc3RhYmxlT25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4gfCBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBvbklucHV0Py4oZSBhcyBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4pOyB9KTtcblxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dDogdXNlSUxJbnB1dCwgdXNlTGFiZWxMYWJlbDogdXNlSUxMYWJlbCwgbGFiZWwgfSA9IHVzZUxhYmVsPElucHV0VHlwZSwgTGFiZWxUeXBlPih7IGxhYmVsOiB7IHByZWZpeExhYmVsOiBcImFyaWEtY2hlY2tib3gtbGFiZWwtXCIsIHByZWZpeElucHV0OiBcImFyaWEtY2hlY2tib3gtaW5wdXQtXCIsIHRhZ0lucHV0OiB0YWdJbnB1dCwgdGFnTGFiZWw6IHRhZ0xhYmVsIH0gfSk7XG5cblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0TGFiZWxFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUxhYmVsUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PExhYmVsVHlwZT4oKTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldElucHV0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxJbnB1dFR5cGU+KCk7XG5cbiAgICBjb25zdCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ6IFVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDxJbnB1dFR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0lucHV0O1xuICAgICAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wczogdXNlSUxJbnB1dFByb3BzIH0gPSB1c2VJTElucHV0KCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PElucHV0VHlwZT4oe30pO1xuXG4gICAgICAgIC8vIG9uQ2xpY2sgYW5kIG9uQ2hhbmdlIGFyZSBhIGJpdCBtZXNzeSwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyAqYWx3YXlzKiBtYWtlIHN1cmUgdGhhdCB0aGUgdmlzaWJsZSBzdGF0ZSBpcyBjb3JyZWN0XG4gICAgICAgIC8vIGFmdGVyIGFsbCB0aGUgZXZlbnQgZHVzdCBzZXR0bGVzLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMjc0NSxcbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE4OTkjaXNzdWVjb21tZW50LTUyNTY5MDE5NFxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRhZyA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmluZGV0ZXJtaW5hdGUgPSAoY2hlY2tlZCA9PT0gXCJtaXhlZFwiKTtcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RhZywgY2hlY2tlZF0pXG5cbiAgICAgICAgcmV0dXJuIHsgZ2V0SW5wdXRFbGVtZW50OiBnZXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9O1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiB7XG5cbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgQ2hyb21lIHdvbid0IGZpcmUgb25JbnB1dCBldmVudHMgZm9yIHJhZGlvIGJ1dHRvbnMgdGhhdCBhcmUgdGFiSW5kZXg9LTE/P1xuICAgICAgICAgICAgLy8gTmVlZHMgaW52ZXN0aWdhdGluZywgYnV0IG9uSW5wdXQgd29ya3MgZmluZSBpbiBGaXJlZm94XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICBsZXQgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4gPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8SW5wdXRUeXBlPihkaXNhYmxlZCB8fCAhaGFuZGxlc0lucHV0KHRhZywgbGFiZWxQb3NpdGlvbiwgXCJpbnB1dC1lbGVtZW50XCIpID8gdW5kZWZpbmVkIDogc3RhYmxlT25JbnB1dCwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgcHJvcHMub25JbnB1dCA9IChlOiBFdmVudCkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBwcm9wcyA9IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VJTElucHV0UHJvcHMocHJvcHMpKTtcblxuXG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSB3cmFwcGVkIGxhYmVsIGhhbmRsZXMgYWxsIGludGVyYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdCdzIGFuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcHJvcHMuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWhpZGRlblwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBfID0+IChnZXRMYWJlbEVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQgPT09IFwibWl4ZWRcIiA/IFwibWl4ZWRcIiA6IGNoZWNrZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gZGlzYWJsZWQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXG4gICAgICAgICAgICBwcm9wcy5vbkNsaWNrID0gZGlzYWJsZWQgPyAoKGUpID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0pIDogcHJvcHMub25DbGljaztcblxuICAgICAgICAgICAgcmV0dXJuIHVzZUlucHV0UmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPElucHV0VHlwZT4ocDAsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlSUxJbnB1dCwgcm9sZSwgbGFiZWxQb3NpdGlvbiwgZGlzYWJsZWQsIGNoZWNrZWQsIHRhZ0lucHV0XSk7XG5cbiAgICBjb25zdCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTGFiZWw7XG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzOiB1c2VJTExhYmVsUHJvcHMgfSA9IHVzZUlMTGFiZWwoKTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+IHtcblxuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4gPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8TGFiZWxUeXBlPihkaXNhYmxlZCB8fCAhaGFuZGxlc0lucHV0KHRhZywgbGFiZWxQb3NpdGlvbiwgXCJsYWJlbC1lbGVtZW50XCIpID8gdW5kZWZpbmVkIDogc3RhYmxlT25JbnB1dCwgdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAwLnRhYkluZGV4ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocDAucm9sZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBjYXNlIHdoZXJlIHRoZXJlJ3MgYWxtb3N0IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBub3JtYWwgY2FzZSB3aGVyZSBldmVyeXRoaW5nIGFjdHMgYWNjb3JkaW5nIG5vcm1hbCBIVE1MIG1lY2hhbmljcy5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKdXN0IG1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBuZXdQcm9wcy5vbkNsaWNrO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlTGFiZWxSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8TGFiZWxUeXBlPihuZXdQcm9wcywgdXNlSUxMYWJlbFByb3BzKHAwKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfTtcblxuICAgIH0sIFt1c2VJTExhYmVsLCBkaXNhYmxlZCwgY2hlY2tlZCwgcm9sZSwgbGFiZWxQb3NpdGlvbiwgdGFnTGFiZWxdKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LFxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXG4gICAgICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICAgICAgZ2V0TGFiZWxFbGVtZW50LFxuICAgICAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFxuICAgIH07XG5cblxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQ2hlY2tib3hMaWtlLCBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzLCBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG5cblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hDaGFuZ2VFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudD4gPSBFdmVudFR5cGUgJiB7IFtFdmVudERldGFpbF06IHsgY2hlY2tlZDogYm9vbGVhbiB9IH07XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94SW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+OyB9XG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExhYmVsRWxlbWVudDxMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjsgfVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBjaGVja2JveExpa2U6IE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJLCBMPltcImNoZWNrYm94TGlrZVwiXSwgXCJvbklucHV0XCIgfCBcInJvbGVcIj47XG4gICAgbGFiZWw6IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTD5bXCJsYWJlbFwiXTtcbiAgICBjaGVja2JveDoge1xuICAgICAgICBvbklucHV0PyhldmVudDogQ2hlY2tib3hDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEk+Pik6IHZvaWQ7XG4gICAgICAgIG9uSW5wdXQ/KGV2ZW50OiBDaGVja2JveENoYW5nZUV2ZW50PGguSlNYLlRhcmdldGVkRXZlbnQ8TD4+KTogdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZUluZm88SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIC8vY2hlY2tib3hMaWtlOiBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlPElucHV0VHlwZSwgTGFiZWxUeXBlPltcImNoZWNrYm94TGlrZVwiXTtcbiAgICAvL2xhYmVsOiBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlPElucHV0VHlwZSwgTGFiZWxUeXBlPltcImxhYmVsXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFDaGVja2JveFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIC8qKiAqKk5vdGFibHkgdW5zdGFibGUqKiAqL1xuICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50OiBVc2VDaGVja2JveElucHV0RWxlbWVudDxJbnB1dFR5cGU+O1xuICAgIC8qKiAqKk5vdGFibHkgdW5zdGFibGUqKiAqL1xuICAgIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50OiBVc2VDaGVja2JveExhYmVsRWxlbWVudDxMYWJlbFR5cGU+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUNoZWNrYm94PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlLCBsYWJlbCwgY2hlY2tib3ggfTogVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pOiBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgZGVidWdMb2coXCJ1c2VBcmlhQ2hlY2tib3hcIik7XG5cbiAgICBjb25zdCB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCBjaGVja2VkIH0gPSBjaGVja2JveExpa2U7XG4gICAgY29uc3QgeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSA9IGxhYmVsO1xuICAgIGNvbnN0IHsgb25JbnB1dCB9ID0gY2hlY2tib3g7XG5cbiAgICBjb25zdCBvbklucHV0RW5oYW5jZWQgPSAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGUgfCBMYWJlbFR5cGUsIEV2ZW50PikgPT4gb25JbnB1dD8uKGVuaGFuY2VFdmVudChlIGFzIGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlLCBFdmVudD4sIHsgY2hlY2tlZDogIWNoZWNrZWQgfSkpO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsIC4uLmNoZWNrYm94TGlrZVJlc3QgfSA9IHVzZUNoZWNrYm94TGlrZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4oeyBjaGVja2JveExpa2U6IHsgcm9sZTogXCJjaGVja2JveFwiLCBjaGVja2VkLCBvbklucHV0OiBvbklucHV0RW5oYW5jZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCAgfSwgbGFiZWwgfSk7XG5cbiAgICBjb25zdCB1c2VDaGVja2JveElucHV0RWxlbWVudDogVXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMocDApO1xuICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA/Pz0gISFjaGVja2VkO1xuXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJjaGVja2JveFwiO1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCBjaGVja2VkLCBsYWJlbFBvc2l0aW9uLCBkaXNhYmxlZCwgdGFnSW5wdXRdKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9O1xuICAgIH0sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbF0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VDaGVja2JveElucHV0RWxlbWVudCxcbiAgICAgICAgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQsXG4gICAgICAgIC4uLmNoZWNrYm94TGlrZVJlc3RcbiAgICB9O1xuXG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbywgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IENoZWNrYm94Q2hlY2tlZFR5cGUgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IENoZWNrYm94Q2hhbmdlRXZlbnQsIHVzZUFyaWFDaGVja2JveCwgVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVycywgVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hlY2tib3hcIjtcblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hHcm91cENoYW5nZUV2ZW50PEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50PiA9IEV2ZW50VHlwZSAmIHsgW0V2ZW50RGV0YWlsXTogeyBjaGlsZHJlbkNoZWNrZWQ6IGJvb2xlYW4gfCBNYXA8bnVtYmVyLCBib29sZWFuIHwgXCJtaXhlZFwiPiB9IH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBhcmVudCBjaGVja2JveCBpcyBjaGFuZ2VkIGFuZCBhbiB1cGRhdGUgb2ZcbiAgICAgKiBhbGwgdGhlIGNoaWxkcmVuIG5lZWRzIHRvIG9jY3VyLlxuICAgICAqIFxuICAgICAqIGBldmVudFtFdmVudERldGFpbF0uY2hpbGRyZW5DaGVja2VkYCB3aWxsIGJlIFxuICAgICAqICogdHJ1ZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSBjaGVja2VkXG4gICAgICogKiBmYWxzZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSB1bmNoZWNrZWRcbiAgICAgKiAqIEEgYE1hcDxpbmRleCxjaGVja2VkPmAgb2YgZWFjaCBjaGlsZCdzIHN0YXR1cyB3aGVuIHJldmVydGluZyB0byBcIm1peGVkXCIuXG4gICAgICogXG4gICAgICogQmVjYXVzZSB3ZSdyZSBkZWFsaW5nIHdpdGggY29udHJvbGxlZCBjb21wb25lbnRzIGhlcmUsIGFuZCB0aGUgZGF0YSBmb3JcbiAgICAgKiB3aGF0IGNoZWNrYm94ZXMgYXJlIGNoZWNrZWQgbGl2ZSAqb3V0c2lkZSogb2YgYW55IG9mIHRoZXNlIGhvb2tzLFxuICAgICAqIGl0J3MgeW91IHdobydzIHJlc3BvbnNpYmxlIGZvciBsaXN0ZW5pbmcgZm9yIHRoaXMgZXZlbnQsIG1vZGlmeWluZyB0aGVcbiAgICAgKiBkYXRhLCBhbmQgcmUtcmVuZGVyaW5nIGFwcHJvcHJpYXRlbHkuXG4gICAgICogXG4gICAgICogSGlnaGx5IHJlY29tbWVuZGVkIHRvLCBmb3IgZXhhbXBsZSwgYWRkIGVhY2ggY2hpbGQncyBgb25JbnB1dGAgZXZlbnQgaGFuZGxlclxuICAgICAqIGF2YWlsYWJsZSBpbiB0aGUgY2hpbGQgaW5mbyB0aGUgcGFyZW50IGdldHMgc28gaXQgY2FuIGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgKiByZW1vdGVseSBmcm9tIGBtYW5hZ2VkQ2hlY2tib3hlc2AuXG4gICAgICogQHBhcmFtIGV2ZW50IFxuICAgICAqL1xuICAgIC8vY2hlY2tib3hHcm91cDoge31cbiAgICAvL29uVXBkYXRlQ2hpbGRyZW4oZXZlbnQ6IENoZWNrYm94R3JvdXBDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+Pik6IHZvaWQ7XG59XG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7XG4vKipcbiAqIFRoZSBpZCBhdHRyaWJ1dGUgdXNlZCBmb3IgdGhlIGNoaWxkLlxuICovXG4vL2lkOiBzdHJpbmc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgY2hlY2tlZCBzdGF0ZSBvZiB0aGlzIGNoaWxkLlxuICogXG4gKiBUaGlzIGlzIHVzZWQgYnkgdGhlIHBhcmVudCB3aGVuZXZlciBpdCdzIGludGVyYWN0ZWQgd2l0aCBcbiAqIGFuZCBhYm91dCB0byBmb3JjZSBldmVyeSBvbmUgdG8gYmUgc29tZXRoaW5nIGRpZmZlcmVudCAtLSBcbiAqIGl0IHdpbGwgc2F2ZSB0aGUgc3RhdGUgb2YgYWxsIGNoaWxkIGNoZWNrYm94ZXMgZm9yIGxhdGVyXG4gKiBieSBhc2tpbmcgZWFjaCBvbmUgd2hhdCBpdHMgY3VycmVudCBzdGF0ZSBpcyBpbmRpdmlkdWFsbHlcbiAqIGF0IHRoYXQgbW9tZW50LlxuICogXG4gKiBBbGwgdGhlIGNoZWNrYm94J3Mgc3RhdGVzIGFyZSBjYXB0dXJlZCB3aGVuIHRoZSBwYXJlbnRcbiAqIGlzIGluIHRoZSBcIm1peGVkXCIgc3RhdGUgYW5kIGlzIGNsaWNrZWQuIEl0IGtlZXBzIHRoZW1cbiAqIHRoYXQgd2F5IHVudGlsIHRoZSBzYW1lIGNvbmRpdGlvbnMgYXJpc2UgYWdhaW4uXG4gKi9cbi8vICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuLy8gICAgb25JbnB1dDogVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxhbnksIGFueT5bXCJvbklucHV0XCJdO1xuLy99XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ0JHIHtcbiAgICBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIG9uSW5wdXQ6IFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8YW55LCBhbnk+W1wiY2hlY2tib3hcIl1bXCJvbklucHV0XCJdO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgYXNDaGVja2JveDogVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD47XG4gICAgYXNDaGVja2JveEdyb3VwQ2hpbGQ6IHtcbiAgICAgICAgbWFuYWdlZENoaWxkOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQkcsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJtYW5hZ2VkQ2hpbGRcIl07XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENCRywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcImxpc3ROYXZpZ2F0aW9uXCJdLCBcInN1YkluZm9cIj47XG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQkcsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJyb3ZpbmdUYWJJbmRleFwiXTtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSA9PiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiAvKntcbiAgICAvL3RhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcbiAgICBjaGVja2JveExpa2U6IFVzZUFyaWFDaGVja2JveFJldHVyblR5cGU8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wiY2hlY2tib3hMaWtlXCJdO1xuICAgIGxhYmVsOiBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImxhYmVsXCJdO1xuICAgIHJvdmluZ1RhYkluZGV4OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQ+W1wicm92aW5nVGFiSW5kZXhcIl07XG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG59Ki9cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9MYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBDQkcsIG5ldmVyPiB7XG4gICAgY2hlY2tib3hHcm91cDoge1xuICAgICAgICBwYXJlbnRJc0NoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCI7XG4gICAgICAgIHBhcmVudFBlcmNlbnRDaGVja2VkOiBudW1iZXI7XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xuICAgIC8qKiAqKlNUQUJMRSAqKiAqL1xuICAgIC8vY2hlY2tib3hlczogTWFuYWdlZENoaWxkcmVuPEk+O1xuICAgIC8qKlxuICAgICAqIEVhY2ggY2hpbGQgY2hlY2tib3ggbXVzdCBjYWxsIHRoaXMgaG9vaywgKmluIGFkZGl0aW9uIHRvKiBgdXNlQXJpYUNoZWNrYm94YFxuICAgICAqL1xuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZDogVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNoZWNrYm94IG11c3QgdXNlIHRoaXMgaG9va1xuICAgICAqIFxuICAgICAqICoqTm90YWJseSB1bnN0YWJsZSEqKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBgYXJpYUNvbnRyb2xzYCwgcG9wdWxhdGVkIGJ5IGFsbCBjaGlsZCBjaGVja2JveGVzXG4gICAgICovXG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0OiBVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgY2hlY2tib3g6IE9taXQ8VXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJjaGVja2JveFwiXSwgXCJvbklucHV0XCI+O1xuICAgIGxhYmVsOiBVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImxhYmVsXCJdO1xuICAgIGNoZWNrYm94TGlrZTogT21pdDxVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94TGlrZVwiXSwgXCJjaGVja2VkXCI+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGE6IFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PikgPT4ge1xuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pjtcbn07XG5cblxuLyoqXG4gKiBcbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hHcm91cDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzKTogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFDaGVja2JveEdyb3VwXCIpO1xuICAgIC8vY29uc3Qgb25VcGRhdGVDaGlsZHJlbiA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uVXBkYXRlQ2hpbGRyZW5VbnN0YWJsZSA/PyAoKCkgPT4ge30pKTtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3RSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPElucHV0RWxlbWVudCwgSW5wdXRFbGVtZW50LCBDQkcsIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBsaXN0UmV0dXJuVHlwZTtcblxuICAgIC8vY29uc3QgW3VuY2hlY2tlZENvdW50LCBzZXRVbmhlY2tlZENvdW50XSA9IHVzZVN0YXRlKDApO1xuXG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBjaGlsZCBJRHMsIGFuZCBhbnkgdGltZSBhbnkgb2YgdGhlbSBjaGFuZ2UsIFxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHN0cmluZyB3aXRoIGFsbCBvZiB0aGVtIGNvbmNhdGVuYXRlZCB0b2dldGhlclxuICAgIC8vIChidXQgb25seSBvbmNlIHBlciByZW5kZXIpO1xuICAgIGNvbnN0IGFsbElkcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oKSk7XG4gICAgY29uc3QgW2FyaWFDb250cm9scywgc2V0QXJpYUNvbnRyb2xzXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFt1cGRhdGVJbmRleCwgc2V0SWRVcGRhdGVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcblxuXG4gICAgY29uc3QgW2NoZWNrZWRDb3VudCwgc2V0Q2hlY2tlZENvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGNoZWNrZWRJbmRpY2VzID0gdXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcbiAgICAvL2NvbnN0IFtzZWxmSXNDaGVja2VkLCBzZXRTZWxmSXNDaGVja2VkLCBnZXRTZWxmSXNDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KGZhbHNlKTtcblxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGNoZWNrZWRDb3VudCAvIChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICByZXR1cm4gcGVyY2VudGFnZSA8PSAwID8gZmFsc2UgOiBwZXJjZW50YWdlID49IDEgPyB0cnVlIDogXCJtaXhlZFwiO1xuICAgIH0sIFtjaGVja2VkQ291bnRdKTtcblxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWRTdGFibGUgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUpO1xuICAgIGNvbnN0IFtzZXRQYXJlbnRDaGVja2JveENoZWNrZWQsIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZF0gPSB1c2VTdGF0ZTxTdGF0ZVVwZGF0ZXI8Q2hlY2tib3hDaGVja2VkVHlwZT4gfCBudWxsPihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRQYXJlbnRDaGVja2JveENoZWNrZWQ/LihjaGVja2VkQ291bnQgPT0gMCA/IGZhbHNlIDogY2hlY2tlZENvdW50ID09IChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpID8gdHJ1ZSA6IFwibWl4ZWRcIik7XG4gICAgfSwgW3NldFBhcmVudENoZWNrYm94Q2hlY2tlZCwgY2hlY2tlZENvdW50XSlcblxuICAgIC8vIElmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBwYXJlbnQgY2hlY2tib3gncyB2YWx1ZSwgdGhlbiB0aGlzIHJlZiBob2xkcyBhIG1lbW9yeSBvZiB3aGF0IHZhbHVlcyB3ZXJlIGhlbGQgYmVmb3JlLlxuICAgIC8vIE90aGVyd2lzZSwgaXQncyBudWxsIHdoZW4gdGhlIGxhc3QgaW5wdXQgd2FzIGZyb20gYSBjaGlsZCBjaGVja2JveC4gXG4gICAgLy9jb25zdCBzYXZlZENoZWNrZWRWYWx1ZXMgPSB1c2VSZWY8TWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQgPSB1c2VDYWxsYmFjazxVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pj4oKHsgY2hlY2tib3gsIGNoZWNrYm94TGlrZSwgbGFiZWwgfSkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFDaGVja2JveEdyb3VwUGFyZW50XCIpO1xuICAgICAgICBjb25zdCB7IC4uLl92b2lkIH0gPSBjaGVja2JveDtcbiAgICAgICAgY29uc3QgeyBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9ID0gY2hlY2tib3hMaWtlO1xuICAgICAgICBjb25zdCB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9ID0gbGFiZWw7XG5cbiAgICAgICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGU8Q2hlY2tib3hDaGVja2VkVHlwZT4oZmFsc2UpO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkKCgpID0+IHNldENoZWNrZWQpO1xuICAgICAgICB9LCBbXSlcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oeyBjaGVja2JveExpa2U6IHsgbGFiZWxQb3NpdGlvbiwgY2hlY2tlZCwgZGlzYWJsZWQsIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9LCBjaGVja2JveDogeyBvbklucHV0OiBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgYXMgYW55LCB9IH0pO1xuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scywgb25JbnB1dDogdGFnSW5wdXQgPT0gXCJpbnB1dFwiID8gKGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKSA6IHVuZGVmaW5lZCB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pLCBwcm9wcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiID8gcmV0IDogcHJvcHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxMYWJlbEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPExhYmVsRWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scyB9IGFzIGFueSkgYXMgYW55LCBwcm9wcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiID8gcmV0IDogcHJvcHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7XG5cbiAgICBjb25zdCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgPSB1c2VDYWxsYmFjaygoZTogQ2hlY2tib3hDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0RWxlbWVudCwgRXZlbnQ+PikgPT4ge1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBzZWxmSXNDaGVja2VkID0gZ2V0U2VsZklzQ2hlY2tlZFN0YWJsZSgpO1xuICAgICAgICBjb25zdCBuZXh0Q2hlY2tlZCA9IChzZWxmSXNDaGVja2VkID09PSBmYWxzZSA/IFwibWl4ZWRcIiA6IHNlbGZJc0NoZWNrZWQgPT09IFwibWl4ZWRcIiA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgIGxldCB3aWxsQ2hhbmdlQW55ID0gZmFsc2U7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gd2lsbENoYW5nZUFueSB8fD0gKGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmNoZWNrZWQgIT0gY2hpbGQuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0TGFzdFVzZXJDaGVja2VkKCkpKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBsZXQgY2hlY2tlZDogYm9vbGVhbjtcbiAgICAgICAgICAgIGlmIChuZXh0Q2hlY2tlZCA9PSBcIm1peGVkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAod2lsbENoYW5nZUFueSkgXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSAoY2hpbGQuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0TGFzdFVzZXJDaGVja2VkKCkgYXMgYm9vbGVhbik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBuZXh0Q2hlY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLm9uSW5wdXQ/LihlbmhhbmNlRXZlbnQoZSwgeyBjaGVja2VkIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qaWYgKHNlbGZJc0NoZWNrZWQgPT09IHRydWUgfHwgKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlICYmIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IGZhbHNlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxmSXNDaGVja2VkID09PSBcIm1peGVkXCIpIHtcblxuICAgICAgICAgICAgc2F2ZWRDaGVja2VkVmFsdWVzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCEuc2V0KGNoaWxkLmluZGV4LCBjaGlsZC5nZXRMYXN0VXNlckNoZWNrZWQoKSk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9uVXBkYXRlQ2hpbGRyZW4oZW5oYW5jZUV2ZW50KGUsIHsgY2hpbGRyZW5DaGVja2VkOiBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA/PyB0cnVlIH0pKTtcbiAgICAgICAgfSovXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBub3RpZnlDaGVja2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBudW1iZXIsIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCIpID0+IHtcbiAgICAgICAgaWYgKGNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2hlY2tlZENvdW50KGMgPT4gKGMgKyAxKSk7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGljZXMuY3VycmVudC5hZGQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHNldENoZWNrZWRDb3VudChjID0+IChjIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSBjaGVja2VkQ291bnQgLyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBzZXRTZWxmSXNDaGVja2VkKHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIilcbiAgICB9LCBbc2V0U2VsZklzQ2hlY2tlZCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgY2hlY2tlZENvdW50XSk7Ki9cblxuICAgIC8qY29uc3QgdXNlQ2hlY2tib3hHcm91cFBhcmVudFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIHJldHVybiBcbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7Ki9cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldEFyaWFDb250cm9scyhBcnJheS5mcm9tKGFsbElkcy5jdXJyZW50KS5qb2luKFwiIFwiKSk7XG4gICAgfSwgW3VwZGF0ZUluZGV4XSlcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94R3JvdXBDaGlsZDogVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiA9IHVzZUNhbGxiYWNrPFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4+KGZ1bmN0aW9uICh7IGFzQ2hlY2tib3gsIGFzQ2hlY2tib3hHcm91cENoaWxkIH0pIHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhQ2hlY2tib3hHcm91cENoaWxkXCIsIGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZC5pbmRleCwgYXNDaGVja2JveC5jaGVja2JveExpa2UuY2hlY2tlZCk7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tib3g6IHsgb25JbnB1dCB9LCBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSwgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfSA9IGFzQ2hlY2tib3g7XG4gICAgICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkOiB7IGluZGV4IH0gfSA9IGFzQ2hlY2tib3hHcm91cENoaWxkO1xuICAgICAgICAvL2xhYmVsUG9zaXRpb24gPz89IFwic2VwYXJhdGVcIjtcbiAgICAgICAgY29uc3QgW2dldExhc3RVc2VyQ2hlY2tlZCwgc2V0TGFzdFVzZXJDaGVja2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuIHwgXCJtaXhlZFwiPihudWxsLCByZXR1cm5GYWxzZSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LFxuICAgICAgICAgICAgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQsXG4gICAgICAgICAgICAuLi5jaGVja2JveFJldHVyblR5cGVcbiAgICAgICAgfSA9IHVzZUFyaWFDaGVja2JveDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICAgICAgY2hlY2tib3g6IHtcbiAgICAgICAgICAgICAgICBvbklucHV0OiB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25JbnB1dD4+KGUgPT4geyBzZXRMYXN0VXNlckNoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCk7IG9uSW5wdXQ/LihlIGFzIGFueSk7IH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHRhZ0lucHV0LFxuICAgICAgICAgICAgICAgIHRhZ0xhYmVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgbGFiZWw6IHsgaW5wdXRJZCwgbGFiZWxJZCB9IH0gPSBjaGVja2JveFJldHVyblR5cGU7XG5cbiAgICAgICAgLy9jb25zdCBnZXRDaGVja2VkID0gdXNlU3RhYmxlR2V0dGVyKGNoZWNrZWQpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzSWQgPSAobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBpbnB1dElkIDogbGFiZWxJZCkhO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBhbGxJZHMuY3VycmVudC5hZGQoY29udHJvbHNJZCk7XG4gICAgICAgICAgICBzZXRJZFVwZGF0ZUluZGV4KGkgPT4gKytpKTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBhbGxJZHMuY3VycmVudC5kZWxldGUoY29udHJvbHNJZCk7XG4gICAgICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtjb250cm9sc0lkXSk7XG5cblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XG4gICAgICAgIH0sIFtpbmRleCwgY2hlY2tlZF0pO1xuXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2aWdhdGlvblJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgc3ViSW5mbzogeyBnZXRMYXN0VXNlckNoZWNrZWQsIG9uSW5wdXQsIGNoZWNrZWQgfSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzQ2hlY2tib3hHcm91cENoaWxkLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBhc0NoZWNrYm94R3JvdXBDaGlsZC5yb3ZpbmdUYWJJbmRleFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiBjaGVja2JveFJldHVyblR5cGUuY2hlY2tib3hMaWtlLFxuICAgICAgICAgICAgbGFiZWw6IGNoZWNrYm94UmV0dXJuVHlwZS5sYWJlbCxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0TmF2aWdhdGlvblJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHJldCkgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IHJldDIgOiByZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldDIgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyhyZXQgYXMgYW55KSBhcyBhbnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyByZXQyIDogcmV0KSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZCxcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbGlzdFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogbGlzdFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIGNoZWNrYm94R3JvdXA6IHtcbiAgICAgICAgICAgIHBhcmVudElzQ2hlY2tlZDogZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlKCkgYXMgYm9vbGVhbiB8IFwibWl4ZWRcIixcbiAgICAgICAgICAgIHBhcmVudFBlcmNlbnRDaGVja2VkOiAoY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSkpLFxuICAgICAgICB9XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBPblRhYmJhYmxlSW5kZXhDaGFuZ2UsIHVzZU1lcmdlZFByb3BzLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcbmltcG9ydCB7IHVzZUxhYmVsLCBVc2VMYWJlbFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5cbmV4cG9ydCB0eXBlIExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgbGlzdGJveFNpbmdsZToge1xuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI7XG4gICAgICAgIG9uU2VsZWN0PyhldmVudDogTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEVsZW1lbnQ+KTogdm9pZDtcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgICAgICB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPHt9LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4ge1xuICAgIGxpc3Rib3hTaW5nbGVJdGVtOiB7IGRpc2FibGVkPzogYm9vbGVhbjsgfVxufVxuXG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzKSA9PiBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVXaXRoSG9va3M8TGlzdEl0ZW1FbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50LCB7fSwgbmV2ZXI+LCBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW06IFVzZUxpc3Rib3hTaW5nbGVJdGVtPExpc3RJdGVtRWxlbWVudD47XG4gICAgdXNlTGlzdGJveFNpbmdsZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+O1xuICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbDogKCkgPT4geyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBsaXN0Ym94U2luZ2xlOiB7IHNlbGVjdGlvbk1vZGUsIHRhZ0xhYmVsLCB0YWdMaXN0LCBvblNlbGVjdCwgLi4uX2xicyB9LFxuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCAuLi5zcyB9LFxuICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxuICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgLi4ucnRpIH0sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9XG59OiBVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50Pik6IFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4ge1xuICAgIGRlYnVnTG9nKFwidXNlQXJpYUxpc3Rib3hTaW5nbGVcIiwgc2VsZWN0ZWRJbmRleCk7XG5cbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwsIC4uLmxhYmVsUmV0dXJuVHlwZSB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgcHJlZml4TGFiZWw6IFwiYXJpYS1saXN0Ym94LWxhYmVsLVwiLFxuICAgICAgICAgICAgcHJlZml4SW5wdXQ6IFwiYXJpYS1saXN0Ym94LVwiLFxuICAgICAgICAgICAgdGFnSW5wdXQ6IHRhZ0xpc3QsXG4gICAgICAgICAgICB0YWdMYWJlbDogdGFnTGFiZWxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLCAuLi5saXN0UmV0dXJuVHlwZSB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwge30sIG5ldmVyPih7XG5cbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyAuLi5sbiB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgIC4uLnJ0aSxcbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25UYWJiYWJsZUluZGV4Q2hhbmdlPigoaSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT8uKGkpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoY2hpbGRyZW4uZ2V0QXQoaSEpPy5zdWJJbmZvLmdldEVsZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD8uKHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaSEgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IC4uLnNzLCBzZWxlY3RlZEluZGV4IH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXG4gICAgfSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbGlzdFJldHVyblR5cGU7XG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKTtcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ID8/ICgoKSA9PiB7IH0pKTtcblxuXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUl0ZW0gPSB1c2VDYWxsYmFjazxVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9LCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCB9KSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYUxpc3Rib3hTaW5nbGVJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsIHNpbmdsZVNlbGVjdGlvbjogc3NfcmV0LCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgIHN1YkluZm86IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgcnRpX3JldC50YWJiYWJsZSAmJiBzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3J0aV9yZXQudGFiYmFibGUsIHNlbGVjdGlvbk1vZGUsIGluZGV4XSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc3NfcmV0XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50Pj4ocHJvcHM6IFApIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPExpc3RJdGVtRWxlbWVudD4oZGlzYWJsZWQgPyBudWxsIDogKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcnRpX3JldC5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSB9KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgLy9wcm9wc1tcImFyaWEtcG9zaW5zZXRcIl0gPSAoaW5mby5pbmRleCArIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSAoc3NfcmV0LnNlbGVjdGVkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzPExpc3RJdGVtRWxlbWVudD4obmV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgc2VsZWN0aW9uTW9kZV0pO1xuXG5cbiAgICBjb25zdCB1c2VMaXN0Ym94U2luZ2xlTGFiZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlTGFiZWwoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wcyB9ID0gdXNlTGFiZWxMYWJlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyB9O1xuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtLFxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHMsXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcbiAgICAgICAgLi4ubGlzdFJldHVyblR5cGUsXG4gICAgICAgIC4uLmxhYmVsUmV0dXJuVHlwZVxuICAgICAgICAvKmxhYmVsOiBsYWJlbFJldHVyblR5cGUubGFiZWwsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbiovXG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pIHtcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh1c2VMYWJlbElucHV0UHJvcHMocHJvcHMpKTtcbiAgICB9XG59XG5cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgT25UYWJiYWJsZUluZGV4Q2hhbmdlLCByZXR1cm5GYWxzZSwgdXNlTGF5b3V0RWZmZWN0LCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEVsZW1lbnRUb1RhZywgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUHJlc3NFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgdXNlTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuZXhwb3J0IHR5cGUgTGlzdGJveE11bHRpU2VsZWN0RXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZDogYm9vbGVhbiB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xuICAgIGxpc3Rib3hNdWx0aToge1xuICAgICAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XG4gICAgICAgIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD5cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEluZm8sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7XG4gICAgbGlzdGJveE11bHRpSXRlbTogeyBkaXNhYmxlZD86IGJvb2xlYW47IH0gJiBJbmZvO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveE11bHRpSXRlbTxFIGV4dGVuZHMgRWxlbWVudD4gPSAoaW5mbzogVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMpID0+IFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPEU+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge1xuICAgIGxpc3Rib3hNdWx0aUl0ZW06IHtcbiAgICAgICAgdGFiYmFibGU6IGJvb2xlYW47XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0Ym94TXVsdGlJdGVtUmV0dXJuVHlwZUluZm88RT4ge1xuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbDogKCkgPT4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH1cbn1cblxuXG5pbnRlcmZhY2UgSW5mbyB7XG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgb25TZWxlY3Q/KGV2ZW50OiAoTGlzdGJveE11bHRpU2VsZWN0RXZlbnQ8RWxlbWVudD4pKTogdm9pZDtcbn1cblxuXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwge30sIG5ldmVyPiwgXCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXCIgfCBcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIj4ge1xuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbDogKCkgPT4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH1cbn0qL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTGlzdGJveE11bHRpPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGxpc3Rib3hNdWx0aTogeyB0YWdMYWJlbCwgdGFnTGlzdCB9LFxuICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxuICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgLi4ucnRpIH0sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9XG59OiBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+KTogVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+IHtcblxuICAgIGRlYnVnTG9nKFwidXNlQXJpYUxpc3Rib3hNdWx0aVwiKTtcblxuICAgIC8vY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzPExpc3RFbGVtZW50Pih7fSk7XG5cbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwgfSA9IHVzZUxhYmVsPExpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHByZWZpeExhYmVsOiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIixcbiAgICAgICAgICAgIHByZWZpeElucHV0OiBcImFyaWEtbGlzdGJveC1cIixcbiAgICAgICAgICAgIHRhZ0xhYmVsOiB0YWdMYWJlbCxcbiAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdMaXN0XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGxpc3RSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+KHtcblxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgLi4ucnRpLFxuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPblRhYmJhYmxlSW5kZXhDaGFuZ2U+KChpKSA9PiB7XG4gICAgICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPy4oaSk7XG4gICAgICAgICAgICAgICAgLyppZiAoc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGNoaWxkcmVuLmdldEF0KGkhKT8uc3ViSW5mby5nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q/Lih7IHRhcmdldCwgY3VycmVudFRhcmdldDogdGFyZ2V0LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGkhIH0gfSk7XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG5cbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9XG4gICAgfSA9IGxpc3RSZXR1cm5UeXBlXG5cbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wcyB9ID0gdXNlTGFiZWxJbnB1dCgpO1xuXG4gICAgY29uc3QgW2dldFNoaWZ0SGVsZCwgc2V0U2hpZnRIZWxkXSA9IHVzZVBhc3NpdmVTdGF0ZShudWxsLCByZXR1cm5GYWxzZSk7XG5cbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlJdGVtID0gdXNlQ2FsbGJhY2s8VXNlTGlzdGJveE11bHRpSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94TXVsdGlJdGVtOiB7IHNlbGVjdGVkLCBkaXNhYmxlZCwgb25TZWxlY3QgfSwgbWFuYWdlZENoaWxkLCBsaXN0TmF2aWdhdGlvbjogbHMsIHJvdmluZ1RhYkluZGV4OiBydGkgfSkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFMaXN0Ym94TXVsdGlJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCwgc2VsZWN0ZWQpO1xuICAgICAgICB0eXBlIEUgPSBMaXN0SXRlbUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGdldFNlbGVjdGVkID0gdXNlU3RhYmxlR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xuICAgICAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ID8/ICgoKSA9PiB7IH0pKTtcblxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgbGlzdE5hdmlnYXRpb246IGxzLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4OiBydGksIHN1YkluZm86IHsgc2VsZWN0ZWQsIG9uU2VsZWN0IH0gfSk7XG5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBnZXRTaGlmdEhlbGQoKSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6IHRydWUgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3J0aTJfcmV0LnRhYmJhYmxlXSk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCBsaXN0Ym94TXVsdGlJdGVtOiB7IGdldFNlbGVjdGVkLCB0YWJiYWJsZTogcnRpMl9yZXQudGFiYmFibGUgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH07XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpSXRlbVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxFPihkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNdWx0aSAke21hbmFnZWRDaGlsZC5pbmRleH0gaXMgJHtnZXRTZWxlY3RlZCgpLnRvU3RyaW5nKCl9IGFuZCBjaGFuZ2luZyB0byAkeyghZ2V0U2VsZWN0ZWQoKSkudG9TdHJpbmcoKX1gKVxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IC4uLmUsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6ICFnZXRTZWxlY3RlZCgpIH0gfSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRDb3VudCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXBvc2luc2V0XCJdID0gKGluZm8uaW5kZXggKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHJ0aTJfcmV0LnRhYmJhYmxlID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VNZXJnZWRQcm9wczxFPihuZXdQcm9wcywgcHJvcHMpKSk7XG4gICAgICAgIH1cblxuICAgIH0sIFt1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXSk7XG5cbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsKCkge1xuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wcyB9ID0gdXNlTGFiZWxMYWJlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzIH07XG4gICAgfSwgW3VzZUxhYmVsTGFiZWxdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW0sXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzLFxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogbGlzdFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbGlzdFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuXG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB7XG4gICAgICAgIHByb3BzLnJvbGUgPSBcImxpc3Rib3hcIjtcbiAgICAgICAgcHJvcHNbXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VMYWJlbElucHV0UHJvcHModXNlTWVyZ2VkUHJvcHM8TGlzdEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbktleVVwLCBvbmZvY3Vzb3V0OiBvbkZvY3VzT3V0IH0sIHByb3BzKSkpO1xuICAgIH1cblxuXG5cbiAgICBmdW5jdGlvbiBvbktleURvd24oZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQodHJ1ZSk7IH1cbiAgICBmdW5jdGlvbiBvbktleVVwKGU6IEtleWJvYXJkRXZlbnQpIHsgaWYgKGUua2V5ID09IFwiU2hpZnRcIikgc2V0U2hpZnRIZWxkKGZhbHNlKTsgfVxuICAgIGZ1bmN0aW9uIG9uRm9jdXNPdXQoXzogRm9jdXNFdmVudCkgeyBzZXRTaGlmdEhlbGQoZmFsc2UpOyB9XG5cbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciwgdXNlSGFzRm9jdXMsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJhbmRvbUlkLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuZXhwb3J0IHR5cGUgVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4gfTtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFBhcmFtZXRlcnMgeyBtb3VzZW92ZXJEZWxheT86IG51bWJlciwgbW91c2VvdXREZWxheT86IG51bWJlciwgZm9jdXNEZWxheT86IG51bWJlciB9XG5leHBvcnQgdHlwZSBVc2VUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBUb29sdGlwVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRvb2x0aXBQYXJhbWV0ZXJzKSA9PiBVc2VUb29sdGlwUmV0dXJuVHlwZVdpdGhIb29rczxUcmlnZ2VyVHlwZSwgVG9vbHRpcFR5cGU+O1xuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8ge1xuICAgIGlzT3BlbjogYm9vbGVhbjtcbiAgICBnZXRJc09wZW46ICgpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGVXaXRoSG9va3M8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBUb29sdGlwVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIHtcbiAgICB1c2VUb29sdGlwOiAoKSA9PiB7XG4gICAgICAgIHVzZVRvb2x0aXBQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT47XG4gICAgfTtcbiAgICB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+O1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhVG9vbHRpcDxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBtb3VzZW92ZXJEZWxheSwgbW91c2VvdXREZWxheSwgZm9jdXNEZWxheSB9OiBVc2VUb29sdGlwUGFyYW1ldGVycyk6IFVzZVRvb2x0aXBSZXR1cm5UeXBlV2l0aEhvb2tzPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT4ge1xuICAgIGRlYnVnTG9nKFwidXNlQXJpYVRvb2x0aXBcIik7XG5cbiAgICBtb3VzZW92ZXJEZWxheSA/Pz0gNDAwO1xuICAgIG1vdXNlb3V0RGVsYXkgPz89IDQwO1xuICAgIGZvY3VzRGVsYXkgPz89IDE7XG5cbiAgICAvLyBUaGUgZXNjYXBlIGtleSBzaG91bGQgY2xvc2UgdG9vbHRpcHMsIGJ1dCBkbyBub3RoaW5nIGVsc2UuXG4gICAgLy8gKGkuZS4gY2xvc2luZyBhIHRvb2x0aXAgaW4gYSBkaWFsb2cgTVVTVCBOT1QgY2xvc2UgdGhlIGRpYWxvZyB0b28pXG4gICAgLy8gVE9ETzogVG9vbHRpcHMgYXJlLCBlZmZlY3RpdmVseSwgYWx3YXlzIHRoZSB0b3Btb3N0IGNvbXBvbmVudCxcbiAgICAvLyBzbyB3ZSBjYW4ganVzdCBoYXZlIHRoZW0gbGlzdGVuIHRvIGFuZCBzd2FsbG93IGFsbCBcIkVzY2FwZVwiXG4gICAgLy8ga2V5IHByZXNzZXMgYmVmb3JlIGFueW9uZSBlbHNlLiBGb3IgYSBtb3JlIGdlbmVyYWwgcG9wdXAsXG4gICAgLy8gb3IgYSB0b29sdGlwIGluIGEgdG9vbHRpcCAoISEpIGEgZGlmZmVyZW50IHNvbHV0aW9uIHdvdWxkIGJlIG5lZWRlZC5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcImtleWRvd25cIiwgKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGdldE9wZW4oKSAmJiBlLmtleSA9PT0gXCJFc2NhcGVcIiAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW4sIGdldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsLy86IHVzZVRvb2x0aXBJZFByb3BzLCBcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwvLzogdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyBcbiAgICB9ID0gdXNlUmFuZG9tSWQ8VG9vbHRpcFR5cGU+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtdG9vbHRpcC1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcblxuICAgIGNvbnN0IFssIHNldFRyaWdnZXJGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IFssIHNldFRvb2x0aXBGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgWywgc2V0VHJpZ2dlckhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoaG92ZXJpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBob3ZlcmluZyA/IG1vdXNlb3ZlckRlbGF5IDogbW91c2VvdXREZWxheTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkKGhvdmVyaW5nKSwgZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwSG92ZXJdID0gdXNlUGFzc2l2ZVN0YXRlKHVzZVN0YWJsZUNhbGxiYWNrKChob3ZlcmluZzogYm9vbGVhbikgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IGhvdmVyaW5nID8gbW91c2VvdmVyRGVsYXkgOiBtb3VzZW91dERlbGF5O1xuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkZWxheSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQoaG92ZXJpbmcpLCBkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkLCBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Rvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkLCBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRPcGVuKHRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCk7XG4gICAgfSwgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZF0pXG5cbiAgICBjb25zdCB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXIoKSB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYVRvb2x0aXBUcmlnZ2VyXCIpO1xuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VHJpZ2dlckhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XG4gICAgICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgICAgICBmdW5jdGlvbiBvblRvdWNoRW5kKGU6IFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgIChlLnRhcmdldCBhcyBhbnkpLmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzPFRyaWdnZXJUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogc2V0VHJpZ2dlckZvY3VzZWQgfSlcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ8VHJpZ2dlclR5cGU+KFwiYXJpYS1kZXNjcmliZWRieVwiIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFRob3VnaCBpdCdzIGltcG9ydGFudCB0byBtYWtlIHN1cmUgdGhhdCBmb2N1c2luZyBhY3RpdmF0ZXMgYSB0b29sdGlwLFxuICAgICAgICAgICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXG4gICAgICAgICAgICAvLyBub3QgdGhpcyBvbmUsIHNvIHdlIGRvbid0IHNldCB0YWJJbmRleD0wXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA/Pz0gLTE7XG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKFxuICAgICAgICAgICAgICAgIHVzZUhhc0ZvY3VzUHJvcHMoXG4gICAgICAgICAgICAgICAgICAgIHVzZU1lcmdlZFByb3BzPFRyaWdnZXJUeXBlPih7IG9uVG91Y2hFbmQgfSwgKHByb3BzIGFzIGFueSkgYXMgdW5rbm93biBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfTtcblxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVRvb2x0aXAgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwKCkge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUb29sdGlwVG9vbHRpcFwiKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXM8VG9vbHRpcFR5cGU+KHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRUb29sdGlwRm9jdXNlZCB9KVxuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XG4gICAgICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzKHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHM8VG9vbHRpcFR5cGU+KHt9LCBwcm9wcykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBQcm9wcyB9O1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVRvb2x0aXAsXG4gICAgICAgIHVzZVRvb2x0aXBUcmlnZ2VyLFxuICAgICAgICBpc09wZW46IG9wZW4sXG4gICAgICAgIGdldElzT3BlbjogZ2V0T3BlblxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRyZW4sIHJldHVybk51bGwsIHVzZUdyaWROYXZpZ2F0aW9uLCBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZUxheW91dEVmZmVjdCwgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvLCB1c2VQYXNzaXZlU3RhdGUsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbywgdXNlU29ydGFibGVDaGlsZHJlbiwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm8sIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ncmlkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IENvbXBhcmUsIEdldEluZGV4LCBHZXRWYWx1ZSwgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2cgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5leHBvcnQgdHlwZSBUYWJsZVZhbHVlVHlwZSA9IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCBib29sZWFuIHwgRGF0ZTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUJvZHlQYXJhbWV0ZXJzIHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgbmV2ZXIsIG5ldmVyLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwge30+LCBcInN1YkluZm9cIj4ge1xuICAgIHRhYmxlUm93OiBQaWNrPFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBcImxvY2F0aW9uXCI+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycyBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8VXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8sIG5ldmVyLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBVc2VBcmlhVGFibGVDZWxsU3ViSW5mbz4geyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBsb2NhdGlvbjogXCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiO1xuICAgIGdldENlbGxzKCk6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDZWxsRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZUFyaWFUYWJsZUNlbGxTdWJJbmZvPj4sIFwidGFiYmFibGVcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8ge1xuICAgIGxvY2F0aW9uOiBcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI7XG4gICAgdmFsdWU6IFRhYmxlVmFsdWVUeXBlO1xufVxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+IHsgdGFibGVIZWFkZXJDZWxsOiB7IHNvcnQoKTogdm9pZCB9IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VBcmlhVGFibGVDZWxsU3ViSW5mbywgbmV2ZXI+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+LCBuZXZlciwgW10+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgVXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIG5ldmVyPiB7IH1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVDZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD47IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQ2VsbDogVXNlQXJpYVRhYmxlQ2VsbDxDZWxsRWxlbWVudD47IHVzZVRhYmxlUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+OyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gfVxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcbiAgICB1c2VUYWJsZVJvdzogVXNlQXJpYVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcbiAgICB1c2VUYWJsZUJvZHk6IFVzZUFyaWFUYWJsZUJvZHk8Qm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XG4gICAgdXNlVGFibGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VBcmlhVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMpID0+IFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PjtcbmV4cG9ydCB0eXBlIFVzZUFyaWFUYWJsZVJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PikgPT4gVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XG5leHBvcnQgdHlwZSBVc2VBcmlhVGFibGVCb2R5PEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZUFyaWFUYWJsZUJvZHlQYXJhbWV0ZXJzKSA9PiBVc2VBcmlhVGFibGVCb2R5UmV0dXJuVHlwZVdpdGhIb29rczxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUYWJsZTxcbiAgICBUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50XG4+KHsgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbiwgcm92aW5nVGFiSW5kZXgsIHR5cGVhaGVhZE5hdmlnYXRpb24gfTogVXNlQXJpYVRhYmxlUGFyYW1ldGVycyk6IFVzZUFyaWFUYWJsZVJldHVyblR5cGVXaXRoSG9va3M8VGFibGVFbGVtZW50LCBCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgZGVidWdMb2coXCJ1c2VBcmlhVGFibGVcIik7XG5cbiAgICBjb25zdCBbZ2V0Q3VycmVudFNvcnRDb2x1bW4sIHNldEN1cnJlbnRTb3J0Q29sdW1uXSA9IHVzZVBhc3NpdmVTdGF0ZTx7IGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiIH0gfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBib2R5U29ydCA9IHVzZVJlZjxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3csXG4gICAgICAgIC4uLmdyaWROYXZSZXQxXG4gICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uPFRhYmxlRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBVc2VBcmlhVGFibGVDZWxsU3ViSW5mbywgbmV2ZXIsIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcm93cyB9IH0gPSBncmlkTmF2UmV0MTtcblxuICAgIGNvbnN0IHVzZVRhYmxlUm93ID0gdXNlQ2FsbGJhY2s8VXNlQXJpYVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4oKHsgYXNDaGlsZFJvd09mU2VjdGlvbiwgYXNQYXJlbnRSb3dPZkNlbGxzLCB0YWJsZVJvdzogeyBsb2NhdGlvbiB9IH06IFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+KTogVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUYWJsZVJvd1wiLCBhc0NoaWxkUm93T2ZTZWN0aW9uLm1hbmFnZWRDaGlsZC5pbmRleCk7XG5cbiAgICAgICAgY29uc3QgZ2V0Q2VsbHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMsXG4gICAgICAgICAgICAuLi5ncmlkTmF2UmV0MlxuICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7IC4uLmFzQ2hpbGRSb3dPZlNlY3Rpb24sIHN1YkluZm86IHsgZ2V0Q2VsbHMsIGxvY2F0aW9uIH0gfSwgYXNQYXJlbnRSb3dPZkNlbGxzIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgYXNQYXJlbnRPZkNlbGxzOiB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogY2VsbHMgfSB9IH0gPSBncmlkTmF2UmV0MjtcblxuICAgICAgICBjb25zdCB1c2VUYWJsZUNlbGwgPSB1c2VDYWxsYmFjazxVc2VBcmlhVGFibGVDZWxsPENlbGxFbGVtZW50Pj4oKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm8gfSkgPT4ge1xuICAgICAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhVGFibGVDZWxsXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMsXG4gICAgICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDNcbiAgICAgICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNlbGwoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbyB9KTtcblxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0SW5mbyA9IGdldEN1cnJlbnRTb3J0Q29sdW1uKCkgPz8geyBpbmRleDogLTEsIGRpcmVjdGlvbjogJ2FzY2VuZGluZycgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBtYW5hZ2VkQ2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRJbmZvLmluZGV4ICE9IGNlbGxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydEluZm8uZGlyZWN0aW9uWzBdID09ICdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbmZvLmRpcmVjdGlvbiA9ICdkZXNjZW5kaW5nJztcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uZGlyZWN0aW9uID0gJ2FzY2VuZGluZyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc29ydEluZm8uaW5kZXggPSBtYW5hZ2VkQ2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFNvcnRDb2x1bW4oc29ydEluZm8pO1xuXG4gICAgICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCEoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB1c2VUYWJsZUNlbGxQcm9wczogdHlwZW9mIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzID0gKHByb3BzKSA9PiBwcm9wcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsOiB7IHNvcnQgfSxcbiAgICAgICAgICAgICAgICB1c2VUYWJsZUNlbGxQcm9wcyxcbiAgICAgICAgICAgICAgICAuLi5ncmlkTmF2UmV0M1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCB1c2VUYWJsZVJvd1Byb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyA9IChwcm9wcykgPT4gcHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVRhYmxlQ2VsbCxcbiAgICAgICAgICAgIHVzZVRhYmxlUm93UHJvcHMsXG4gICAgICAgICAgICAuLi5ncmlkTmF2UmV0MlxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlVGFibGVCb2R5ID0gdXNlQ2FsbGJhY2s8VXNlQXJpYVRhYmxlQm9keTxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4oKCkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUYWJsZUJvZHlcIik7XG4gICAgICAgIHR5cGUgQyA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PjtcbiAgICAgICAgdHlwZSBWID0ge2xvY2F0aW9uOiBcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCIsIHZhbHVlOiBUYWJsZVZhbHVlVHlwZX07XG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlQ2FsbGJhY2s8R2V0SW5kZXg8QywgbmV2ZXI+PigoaSkgPT4gaS5pbmRleCwgW10pO1xuICAgICAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPEdldFZhbHVlPEMsIG5ldmVyLCBbXSwgVj4+KChpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IGkuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0Q2VsbHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxscy5nZXRBdChnZXRDdXJyZW50U29ydENvbHVtbigpPy5pbmRleCA/PyAwKTtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBjZWxsPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5sb2NhdGlvbiA/PyBcImhlYWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8udmFsdWUgPz8gLTFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9yZXR1cm4gY2VsbHMuZ2V0QXQoZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uaW5kZXggPz8gMCk/LnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLnZhbHVlID8/IG51bGw7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCBjb21wYXJlOiBDb21wYXJlPFY+ID0gKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09PSByaHMubG9jYXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuICsobGhzLnZhbHVlID8/IC1JbmZpbml0eSkgLSArKHJocy52YWx1ZSA/PyAtSW5maW5pdHkpO1xuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PSAnaGVhZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PSAnYm9keScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocy5sb2NhdGlvbiA9PSAnaGVhZCc/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XG4gICAgICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPEJvZHlTZWN0aW9uRWxlbWVudCwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+LCBuZXZlciwgW10sIFY+KHtcbiAgICAgICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgICAgIGdldEluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgICAgIGNvbXBhcmUsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyBzb3J0YWJsZUNoaWxkcmVuOiB7IHNvcnQgfSB9ID0gc29ydGFibGVSZXQ7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBib2R5U29ydC5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvcnQocm93cywgZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uZGlyZWN0aW9uID8/ICdhc2NlbmRpbmcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtzb3J0XSlcblxuICAgICAgICBjb25zdCB1c2VUYWJsZUJvZHlQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlU29ydGFibGVQcm9wcyhwcm9wcyBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+ICYgeyBjaGlsZHJlbjogYW55IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVRhYmxlQm9keVByb3BzLFxuICAgICAgICAgICAgLi4uc29ydGFibGVSZXRcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVRhYmxlUHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblByb3BzID0gdXNlR3JpZE5hdmlnYXRpb25Qcm9wcztcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVRhYmxlUHJvcHMsXG4gICAgICAgIHVzZVRhYmxlQm9keSxcbiAgICAgICAgdXNlVGFibGVSb3csXG4gICAgICAgIC4uLmdyaWROYXZSZXQxXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnMgfSBmcm9tIFwidXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgdXNlQXJpYUFjY29yZGlvbiwgVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMsIFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlSW5mbywgVXNlQXJpYUFjY29yZGlvblNlY3Rpb24sIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVycywgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtYWNjb3JkaW9uXCI7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSBcIi4vaGVhZGluZ1wiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyaWFBY2NvcmRpb25Qcm9wcyBleHRlbmRzXG4gICAgR2V0PFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzLCBcImFjY29yZGlvblwiPixcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+IHtcbiAgICBleHBhbmRlZEluZGV4PzogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuO1xuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVJbmZvLCBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFyaWFBY2NvcmRpb25TZWN0aW9uUHJvcHM8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwiYWNjb3JkaW9uU2VjdGlvblwiPixcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBPbWl0PFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcInByZXNzZWRcIiB8IFwib25QcmVzc1wiPiB7XG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBoZWFkZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4sIGJvZHlQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuXG5jb25zdCBBY2NvcmRpb25TZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb248YW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgZnVuY3Rpb24gQXJpYUFjY29yZGlvbih7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgZXhwYW5kZWRJbmRleCwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmVuZGVyLCBjaGlsZHJlbiB9OiBBcmlhQWNjb3JkaW9uUHJvcHMpIHtcbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uLCAuLi5wcm92aWRlciB9ID0gdXNlQXJpYUFjY29yZGlvbih7XG4gICAgICAgIGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXggfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH1cbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IHByb3ZpZGVyLmFjY29yZGlvbi5jaGFuZ2VFeHBhbmRlZEluZGV4KGV4cGFuZGVkSW5kZXghID8/IG51bGwpOyB9LCBbZXhwYW5kZWRJbmRleF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbn0+eyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlckFjY29yZGlvbikocHJvdmlkZXIsIGNoaWxkcmVuKX08L0FjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckFjY29yZGlvbihpbmZvOiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZUluZm8sIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbik6IFZOb2RlPGFueT4ge1xuICAgIHJldHVybiAoPD57Y2hpbGRyZW59PC8+KVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyU2VjdGlvbihpbmZvOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBoZWFkaW5nUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGJvZHlQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPXs8ZGl2IHsuLi5oZWFkaW5nUHJvcHN9IC8+fT5cbiAgICAgICAgICAgICAgICA8ZGl2IHsuLi5ib2R5UHJvcHN9IC8+XG4gICAgICAgICAgICA8L0hlYWRpbmc+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZnVuY3Rpb24gQXJpYUFjY29yZGlvblNlY3Rpb25VPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgb3BlbiwgaW5kZXgsIHRhZywgZGlzYWJsZWQsIHJlbmRlciwgLi4udW5rbm93blByb3BzIH06IEFyaWFBY2NvcmRpb25TZWN0aW9uUHJvcHM8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+LCByZWY6IFJlZjxIZWFkZXJFbGVtZW50Pikge1xuICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uID0gdXNlQ29udGV4dChBY2NvcmRpb25TZWN0aW9uQ29udGV4dCk7XG4gICAgY29uc3QgeyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcywgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uKHsgYnV0dG9uOiB7IHRhZywgZGlzYWJsZWQgfSwgYWNjb3JkaW9uU2VjdGlvbjogeyBvcGVuIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBpbmRleCB9IH0pO1xuXG4gICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclNlY3Rpb24pKHNlY3Rpb25JbmZvLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgLi4udW5rbm93blByb3BzLCByZWYgfSksIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHt9KSk7XG59XG5cbmV4cG9ydCBjb25zdCBBcmlhQWNjb3JkaW9uU2VjdGlvbiA9IGZvcndhcmRSZWYoQXJpYUFjY29yZGlvblNlY3Rpb25VKSBhcyB0eXBlb2YgQXJpYUFjY29yZGlvblNlY3Rpb25VO1xuXG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSwgQ29tcG9uZW50Q2hpbGRyZW4gfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBcmlhQ2hlY2tib3gsIFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnMsIFVzZUFyaWFDaGVja2JveFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1jaGVja2JveFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyaWFDaGVja2JveFByb3BzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4sIFwiY2hlY2tib3hMaWtlXCI+LFxuICAgIEdldDxVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+LCBcImNoZWNrYm94XCI+LFxuICAgIEdldDxVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+LCBcImxhYmVsXCI+IHtcbiAgICAvL3Byb3BzSW5wdXQoKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST47XG4gICAvLyBwcm9wc0xhYmVsKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+O1xuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZUluZm88SSwgTD4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPiwgbGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+KTogVk5vZGU8YW55PjtcblxuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgY292ZXJlZCBieSBgcmVuZGVyYCwgYnV0IGl0J3MgaGVyZSBmb3IgY29udmVuaWVuY2UuXG4gICAgY2hpbGRyZW4/OiBDb21wb25lbnRDaGlsZHJlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJTZXBhcmF0ZShpbnB1dFRhZzogc3RyaW5nLCBpbnB1dExhYmVsOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IHVua25vd24sIGlucHV0UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGxhYmVsUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBjcmVhdGVFbGVtZW50KGlucHV0VGFnLCBpbnB1dFByb3BzKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KGlucHV0TGFiZWwsIGxhYmVsUHJvcHMpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtpbnB1dH1cbiAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJXcmFwcGluZyhpbnB1dFRhZzogc3RyaW5nLCBpbnB1dExhYmVsOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IHVua25vd24sIGlucHV0UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIHtjaGlsZHJlbiwgLi4ubGFiZWxQcm9wc306IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBjcmVhdGVFbGVtZW50KGlucHV0VGFnLCBpbnB1dFByb3BzKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KGlucHV0TGFiZWwsIHsgLi4ubGFiZWxQcm9wcywgY2hpbGRyZW46IDw+e2lucHV0fXtjaGlsZHJlbn08Lz4gfSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBcmlhQ2hlY2tib3g8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgY2hlY2tlZCwgZGlzYWJsZWQsIHRhZ0xhYmVsLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgb25JbnB1dCwgcmVuZGVyLCBjaGlsZHJlbiB9OiBBcmlhQ2hlY2tib3hQcm9wczxJLCBMPikge1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50LCAuLi5jaGVja2JveEluZm8gfSA9IHVzZUFyaWFDaGVja2JveCh7IGNoZWNrYm94OiB7IG9uSW5wdXQgfSwgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XG5cbiAgICBjb25zdCBpbnB1dCA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoe30pO1xuICAgIGNvbnN0IGxhYmVsID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7IGNoaWxkcmVuIH0pO1xuICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xuICAgICAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyU2VwYXJhdGUodGFnSW5wdXQsIHRhZ0xhYmVsKSkoY2hlY2tib3hJbmZvLCBpbnB1dCwgbGFiZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlcldyYXBwaW5nKHRhZ0lucHV0LCB0YWdMYWJlbCkpKGNoZWNrYm94SW5mbywgaW5wdXQsIGxhYmVsKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgaCwgUmVuZGVyYWJsZVByb3BzLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJXcmFwcGluZywgZGVmYXVsdFJlbmRlclNlcGFyYXRlIH0gZnJvbSBcIi4vY2hlY2tib3hcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgUmVuZGVyYWJsZVByb3BzPHt9PixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGVja2JveFwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImNoZWNrYm94TGlrZVwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxhYmVsXCI+IHtcbiAgICAvKnBhcmVudERpc2FibGVkPzogYm9vbGVhbjtcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPElucHV0VHlwZT47XG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbFR5cGU+O1xuICAgIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiB8IFwid3JhcHBpbmdcIjsqL1xuICAgIC8vcHJvcHNJbnB1dCgpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuICAgIC8vcHJvcHNMYWJlbCgpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuICAgIHJlbmRlcj8oaW5mbzogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgaW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4pOiBWTm9kZTxhbnk+O1xuICAgIGxhYmVsQ2hpbGRyZW4/OiBDb21wb25lbnRDaGlsZHJlbjsgIC8vIEZvciBjb252ZW5pZW5jZSwgc2luY2Ugb3RoZXJ3aXNlIGl0J3MgbmVjZXNzYXJ5IHRvIG92ZXJyaWRlIGByZW5kZXJgIGluc3RlYWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hcIj4sXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94XCIsIFwibGFiZWxcIj4sXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hMaWtlXCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImFzQ2hlY2tib3hHcm91cENoaWxkXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94R3JvdXBDaGlsZFwiLCBcIm1hbmFnZWRDaGlsZFwiPiB7XG4gICAgLy9sYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIgfCBcIndyYXBwaW5nXCI7XG4gICAgLy9wcm9wc0lucHV0KCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47XG4gICAgLy9wcm9wc0xhYmVsKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT47XG4gICAgcmVuZGVyPyhpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT47XG4gICAgY2hpbGRyZW4/OiBDb21wb25lbnRDaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoaWxkU2VwYXJhdGUoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlclNlcGFyYXRlKGlucHV0VGFnLCBpbnB1dExhYmVsKShpbmZvLCBpbnB1dCwgbGFiZWwpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoaWxkV3JhcHBpbmcoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlcldyYXBwaW5nKGlucHV0VGFnLCBpbnB1dExhYmVsKShpbmZvLCBpbnB1dCwgbGFiZWwpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyb3VwU2VwYXJhdGUoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88YW55LCBhbnk+LCBpbnB1dDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlclNlcGFyYXRlKGlucHV0VGFnLCBpbnB1dExhYmVsKShpbmZvLCBpbnB1dCwgbGFiZWwpfVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JvdXBXcmFwcGluZyhpbnB1dFRhZzogc3RyaW5nLCBpbnB1dExhYmVsOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuKTogVk5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyV3JhcHBpbmcoaW5wdXRUYWcsIGlucHV0TGFiZWwpKGluZm8sIGlucHV0LCBsYWJlbCl9XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmNvbnN0IFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUNoZWNrYm94R3JvdXBDaGlsZDxhbnksIGFueT4+KG51bGwhKTtcbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveEdyb3VwPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xuICAgIGNoaWxkcmVuLFxuICAgIGRpc2FibGVkOiBwYXJlbnREaXNhYmxlZCxcbiAgICB0YWdJbnB1dCxcbiAgICB0YWdMYWJlbCxcbiAgICByZW5kZXIsXG4gICAgbGFiZWxQb3NpdGlvbixcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIG9uVGFiYmVkSW5UbyxcbiAgICBvblRhYmJlZE91dE9mLFxuICAgIGxhYmVsQ2hpbGRyZW5cbn06IENoZWNrYm94R3JvdXBQcm9wczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZCxcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0LFxuICAgICAgICAuLi5jaGVja2JveEdyb3VwUGFyZW50SW5mb1xuICAgIH0gPSB1c2VDaGVja2JveEdyb3VwPElucHV0VHlwZSwgTGFiZWxUeXBlPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB7IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyB9ID0gdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0KHsgY2hlY2tib3g6IHt9LCBjaGVja2JveExpa2U6IHsgZGlzYWJsZWQ6IHBhcmVudERpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9IH0pO1xuXG4gICAgY29uc3QgaW5wdXRQcm9wcyA9IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzKHt9KTtcbiAgICBjb25zdCBsYWJlbFByb3BzID0gdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMoeyBjaGlsZHJlbjogbGFiZWxDaGlsZHJlbiB9KTtcbiAgICBsZXQgd3JhcHBpbmc6IFZOb2RlPGFueT47XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIHdyYXBwaW5nID0gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyR3JvdXBTZXBhcmF0ZSh0YWdJbnB1dCwgdGFnTGFiZWwpKShjaGVja2JveEdyb3VwUGFyZW50SW5mbywgaW5wdXRQcm9wcywgbGFiZWxQcm9wcywgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3JhcHBpbmcgPSAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJHcm91cFdyYXBwaW5nKHRhZ0lucHV0LCB0YWdMYWJlbCkpKGNoZWNrYm94R3JvdXBQYXJlbnRJbmZvLCBpbnB1dFByb3BzLCBsYWJlbFByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUNoZWNrYm94R3JvdXBDaGlsZH0+e3dyYXBwaW5nfTwvVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveEdyb3VwQ2hlY2tib3g8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgY2hlY2tlZCxcbiAgICBkaXNhYmxlZCxcbiAgICBpbmRleCxcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIHRhZ0lucHV0LFxuICAgIHRhZ0xhYmVsLFxuICAgIHRleHQsXG4gICAgYmx1clNlbGYsXG4gICAgZmxhZ3MsXG4gICAgZm9jdXNTZWxmLFxuICAgIGhpZGRlbixcbiAgICBvbklucHV0LFxuICAgIGNoaWxkcmVuLFxuICAgIHJlbmRlclxufTogQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzLCAuLi5jaGVja2JveEdyb3VwQ2hpbGRJbmZvIH0gPSB1c2VDb250ZXh0KFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQpKHtcbiAgICAgICAgYXNDaGVja2JveDoge1xuICAgICAgICAgICAgY2hlY2tib3g6IHsgb25JbnB1dCB9LFxuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sXG4gICAgICAgICAgICBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfVxuICAgICAgICB9LFxuICAgICAgICBhc0NoZWNrYm94R3JvdXBDaGlsZDoge1xuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGJsdXJTZWxmLFxuICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgICAgICBoaWRkZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRQcm9wcyA9IHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMoe30pO1xuICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzKHsgY2hpbGRyZW4gfSk7XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJDaGlsZFNlcGFyYXRlKHRhZ0lucHV0LCB0YWdMYWJlbCkpKGNoZWNrYm94R3JvdXBDaGlsZEluZm8sIGlucHV0UHJvcHMsIGxhYmVsUHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlckNoaWxkV3JhcHBpbmcodGFnSW5wdXQsIHRhZ0xhYmVsKSkoY2hlY2tib3hHcm91cENoaWxkSW5mbywgaW5wdXRQcm9wcywgbGFiZWxQcm9wcyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VBcmlhTGlzdGJveE11bHRpLCBVc2VMaXN0Ym94TXVsdGlJdGVtLCBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycywgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvLCBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1tdWx0aVwiO1xuXG5cblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94TXVsdGlQcm9wczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpc3Rib3hNdWx0aVwiPiB7XG4gICAgLy90YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XG4gICAgcmVuZGVyPyhpbmZvOiBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbGlzdDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcbiAgICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuO1xufVxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94TXVsdGlJdGVtUHJvcHM8TGlzdGJveEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgT21pdDxHZXQ8VXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sIFwic3ViSW5mb1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzLCBcImxpc3Rib3hNdWx0aUl0ZW1cIj4ge1xuICAgIHJlbmRlcj8oaW5mbzogVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPExpc3Rib3hJdGVtRWxlbWVudD4sIGxpc3RJdGVtUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3Rib3hJdGVtRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xuICAgIGNoaWxkcmVuPzogQ29tcG9uZW50Q2hpbGRyZW47XG59XG5cbmNvbnN0IExpc3Rib3hNdWx0aUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUxpc3Rib3hNdWx0aUl0ZW08YW55Pj4obnVsbCEpO1xuXG5mdW5jdGlvbiBMaXN0Ym94TXVsdGlVPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgcmVuZGVyLFxuICAgIHRhZ0xhYmVsLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIG9uVGFiYmVkSW5UbyxcbiAgICBvblRhYmJlZE91dE9mLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgdGFnTGlzdCxcbiAgICBjaGlsZHJlbjogdm5vZGVDaGlsZHJlblxufTogTGlzdGJveE11bHRpUHJvcHM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50PiwgcmVmOiBSZWY8TGlzdEVsZW1lbnQ+KSB7XG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0Ym94TXVsdGlJdGVtLFxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbCxcbiAgICAgICAgdXNlTGlzdGJveE11bHRpUHJvcHMsXG4gICAgICAgIC4uLmxpc3Rib3hSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUFyaWFMaXN0Ym94TXVsdGk8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3Rib3hNdWx0aTogeyB0YWdMYWJlbCwgdGFnTGlzdCB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wcyB9ID0gdXNlTGlzdGJveE11bHRpTGFiZWwoKTtcblxuICAgIGNvbnN0IHAxID0gIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMoe30pO1xuICAgIGNvbnN0IHAyID0gdXNlTGlzdGJveE11bHRpUHJvcHMoeyBjaGlsZHJlbjogdm5vZGVDaGlsZHJlbiwgcmVmIH0pO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxMaXN0Ym94TXVsdGlDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VMaXN0Ym94TXVsdGlJdGVtfT5cbiAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRMaXN0UmVuZGVyKShsaXN0Ym94UmV0dXJuVHlwZSwgcDEsIHAyKX1cbiAgICAgICAgPC9MaXN0Ym94TXVsdGlDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuZnVuY3Rpb24gZGVmYXVsdExpc3RSZW5kZXIoaW5mbzogVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88YW55PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGlzdFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XG4gICAgY29uc3QgbGFiZWwgPSA8ZGl2IHsuLi5sYWJlbFByb3BzfSAvPjtcbiAgICBjb25zdCBsaXN0ID0gPHVsIHsuLi5saXN0UHJvcHN9IC8+O1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+e2xhYmVsfXtsaXN0fTwvPlxuICAgIClcbn1cblxuZnVuY3Rpb24gZGVmYXVsdExpc3RJdGVtUmVuZGVyKGluZm86IFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxhbnk+LCBsaXN0SXRlbVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XG4gICAgY29uc3QgbGlzdEl0ZW0gPSA8bGkgey4uLmxpc3RJdGVtUHJvcHN9IC8+O1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+e2xpc3RJdGVtfTwvPlxuICAgIClcbn1cblxuZnVuY3Rpb24gTGlzdGJveE11bHRpSXRlbVU8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgYmx1clNlbGYsIGRpc2FibGVkLCBmbGFncywgZm9jdXNTZWxmLCByZW5kZXIsIHRleHQsIGhpZGRlbiwgc2VsZWN0ZWQsIG9uU2VsZWN0LCBjaGlsZHJlbiB9OiBMaXN0Ym94TXVsdGlJdGVtUHJvcHM8TGlzdEl0ZW1FbGVtZW50PiwgcmVmOiBSZWY8TGlzdEl0ZW1FbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCAuLi5pdGVtUmV0dXJuIH0gPSB1c2VDb250ZXh0KExpc3Rib3hNdWx0aUNvbnRleHQpKHsgXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9LCBcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBcbiAgICAgICAgbGlzdGJveE11bHRpSXRlbTogeyBkaXNhYmxlZCwgc2VsZWN0ZWQsIG9uU2VsZWN0fVxuICAgIH0pO1xuICAgIC8vY29uc3QgbGlzdEl0ZW0gPSBjcmVhdGVFbGVtZW50KHRhZ0xpc3RJdGVtLCB1c2VMaXN0Ym94TXVsdGlJdGVtUHJvcHMoeyByZWYgfSkgYXMgYW55KTtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PnsocmVuZGVyID8/IGRlZmF1bHRMaXN0SXRlbVJlbmRlcikoaXRlbVJldHVybiwgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzKHsgcmVmLCBjaGlsZHJlbiB9KSl9PC8+XG4gICAgKVxufVxuXG5leHBvcnQgY29uc3QgTGlzdGJveE11bHRpID0gZm9yd2FyZFJlZihMaXN0Ym94TXVsdGlVKSBhcyB0eXBlb2YgTGlzdGJveE11bHRpVTtcbmV4cG9ydCBjb25zdCBMaXN0Ym94TXVsdGlJdGVtID0gZm9yd2FyZFJlZihMaXN0Ym94TXVsdGlJdGVtVSkgYXMgdHlwZW9mIExpc3Rib3hNdWx0aUl0ZW1VO1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG4vL2ltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hTaW5nbGUsIFVzZUxpc3Rib3hTaW5nbGVJdGVtLCBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm8sIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWxpc3Rib3gtc2luZ2xlXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGJveFNpbmdsZVByb3BzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJzaW5nbGVTZWxlY3Rpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJsaXN0Ym94U2luZ2xlXCI+IHtcbiAgICAvL3RhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcbiAgICByZW5kZXI/KGluZm86IFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+LCBsYWJlbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBsaXN0UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xufVxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBPbWl0PEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sIFwic3ViSW5mb1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFwibGlzdGJveFNpbmdsZUl0ZW1cIj4ge1xuICAgIC8vdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xuICAgIHJlbmRlcj8oaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBsaXN0SXRlbVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0Ym94SXRlbUVsZW1lbnQ+KTogVk5vZGU8YW55PjtcbiAgICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuO1xufVxuXG5jb25zdCBMaXN0Ym94U2luZ2xlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08YW55Pj4obnVsbCEpO1xuXG5mdW5jdGlvbiBMaXN0Ym94U2luZ2xlVTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xuICAgIHJlbmRlcixcblxuICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgdGFnTGFiZWwsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXIsXG4gICAgb25UYWJiZWRJblRvLFxuICAgIG9uVGFiYmVkT3V0T2YsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIHRhZ0xpc3QsXG4gICAgb25TZWxlY3QsXG4gICAgY2hpbGRyZW46IHZub2RlQ2hpbGRyZW5cbn06IExpc3Rib3hTaW5nbGVQcm9wczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+LCByZWY6IFJlZjxMaXN0RWxlbWVudD4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtLFxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyxcbiAgICAgICAgLi4ubGlzdGJveFJldHVyblR5cGVcbiAgICB9ID0gdXNlQXJpYUxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3Rib3hTaW5nbGU6IHsgc2VsZWN0aW9uTW9kZSwgdGFnTGFiZWwsIHRhZ0xpc3QsIG9uU2VsZWN0IH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyB9ID0gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCk7XG4gICAgLy9jb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHt9KSBhcyBhbnkpO1xuICAgIC8vY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCwgdXNlTGlzdGJveFNpbmdsZVByb3BzKHsgY2hpbGRyZW46IHZub2RlQ2hpbGRyZW4sIHJlZiB9KSBhcyBhbnkpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdGJveFNpbmdsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hTaW5nbGVJdGVtfT5cbiAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRMaXN0UmVuZGVyKSh7IC4uLmxpc3Rib3hSZXR1cm5UeXBlIH0sIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHt9KSwgdXNlTGlzdGJveFNpbmdsZVByb3BzKHsgY2hpbGRyZW46IHZub2RlQ2hpbGRyZW4sIHJlZiB9KSl9XG4gICAgICAgIDwvTGlzdGJveFNpbmdsZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TGlzdFJlbmRlcihpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88YW55PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGlzdFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD48bGFiZWwgey4uLmxhYmVsUHJvcHN9IC8+PHVsIHsuLi5saXN0UHJvcHN9IC8+PC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TGlzdEl0ZW1SZW5kZXIoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxhbnk+LCBsaXN0SXRlbVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGxpIHsuLi5saXN0SXRlbVByb3BzfSAvPlxuICAgIClcbn1cblxuXG5cbmZ1bmN0aW9uIExpc3Rib3hTaW5nbGVJdGVtVTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBibHVyU2VsZiwgZGlzYWJsZWQsIGZsYWdzLCBmb2N1c1NlbGYsIHJlbmRlciwgdGV4dCwgaGlkZGVuLCBjaGlsZHJlbiB9OiBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3RJdGVtRWxlbWVudD4sIHJlZjogUmVmPExpc3RJdGVtRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMsIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24gfSA9IHVzZUNvbnRleHQoTGlzdGJveFNpbmdsZUNvbnRleHQpKHtcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD57KHJlbmRlciA/PyBkZWZhdWx0TGlzdEl0ZW1SZW5kZXIpKHsgcm92aW5nVGFiSW5kZXgsIHNpbmdsZVNlbGVjdGlvbiB9LCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzKHsgY2hpbGRyZW4sIHJlZiB9KSl9PC8+XG4gICAgKVxufVxuXG5leHBvcnQgY29uc3QgTGlzdGJveFNpbmdsZSA9IGZvcndhcmRSZWYoTGlzdGJveFNpbmdsZVUpIGFzIHR5cGVvZiBMaXN0Ym94U2luZ2xlVTtcbmV4cG9ydCBjb25zdCBMaXN0Ym94U2luZ2xlSXRlbSA9IGZvcndhcmRSZWYoTGlzdGJveFNpbmdsZUl0ZW1VKSBhcyB0eXBlb2YgTGlzdGJveFNpbmdsZUl0ZW1VO1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQXJpYU1lbnUsIFVzZUFyaWFNZW51SXRlbVBhcmFtZXRlcnMsIFVzZUFyaWFNZW51SXRlbVJldHVyblR5cGVJbmZvLCBVc2VBcmlhTWVudVBhcmFtZXRlcnMsIFVzZUFyaWFNZW51UmV0dXJuVHlwZUluZm8sIFVzZU1lbnVJdGVtIH0gZnJvbSBcIi4uL3VzZS1tZW51XCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVudVByb3BzPE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIC8vT21pdDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8RSwgSywgST4sIFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFwiIHwgXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIiB8IFwib25UYWJiYWJsZUluZGV4Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVSZW5kZXJcIiB8IFwib25UYWJiZWRJblRvXCIgfCBcIm9uVGFiYmVkT3V0T2ZcIj4gJiB7XG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxuZXZlcj4sIFwibWVudVwiPixcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPG5ldmVyPiwgXCJtZW51U3VyZmFjZVwiPixcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPG5ldmVyPiwgXCJzb2Z0RGlzbWlzc1wiPixcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPG5ldmVyPiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8bmV2ZXI+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8bmV2ZXI+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8bmV2ZXI+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxuZXZlcj4sIFwibWFuYWdlZENoaWxkcmVuXCI+XG5cbntcbiAgICAvL3Byb3BzTWVudUJ1dHRvbjogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcbiAgICAvL3Byb3BzTWVudVNlbnRpbmVsOiAod2hpY2g6IFwidG9wXCIgfCBcImJvdHRvbVwiKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuICAgIC8vcHJvcHNNZW51OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuXG4gICAgLy90YWdNZW51QnV0dG9uOiBhbnk7XG4gICAgLy90YWdNZW51OiBhbnk7XG4gICAgLy90YWdTZW50aW5lbDogYW55O1xuXG5cbiAgICByZW5kZXI/KG1lbnVJbmZvOiBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiwgbWVudUJ1dHRvblByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51QnV0dG9uRWxlbWVudD4sIG1lbnU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PiwgZmlyc3RTZW50aW5lbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGFzdFNlbnRpbmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFxuR2V0PFVzZUFyaWFNZW51SXRlbVBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkXCI+LFxuR2V0PFVzZUFyaWFNZW51SXRlbVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG5HZXQ8VXNlQXJpYU1lbnVJdGVtUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPiB7XG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+LCBsaXN0SXRlbTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlO1xuICAgIC8vdGFnTWVudUl0ZW06IGFueTtcbiAgICAvL3Byb3BzTWVudUl0ZW06ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT5cbn1cblxuY29uc3QgTWVudUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VNZW51SXRlbTxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBmdW5jdGlvbiBNZW51PFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluaXRpYWxJbmRleCxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgb25PcGVuLFxuICAgIG9uQ2xvc2UsXG4gICAgb3BlbixcblxuICAgIG9wZW5EaXJlY3Rpb24sXG4gICAgc2VuZEZvY3VzVG9NZW51LFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIG9uVGFiYmVkSW5UbyxcbiAgICBvblRhYmJlZE91dE9mLFxuXG4gICAgcmVuZGVyXG5cbn06IE1lbnVQcm9wczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KSB7XG4gICAgY29uc3Qge1xuICAgICAgICB1c2VNZW51QnV0dG9uUHJvcHMsXG4gICAgICAgIHVzZU1lbnVJdGVtLFxuICAgICAgICB1c2VNZW51UHJvcHMsXG4gICAgICAgIHVzZU1lbnVTZW50aW5lbCxcbiAgICAgICAgLi4ubWVudVJldHVyblxuICAgIH0gPSB1c2VBcmlhTWVudTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgbWVudTogeyBvbk9wZW4sIG9wZW5EaXJlY3Rpb24gfSxcbiAgICAgICAgbWVudVN1cmZhY2U6IHsgc2VuZEZvY3VzVG9NZW51LCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQ2xvc2UsIG9wZW4gfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1lbnVCdXR0b25Qcm9wcyA9IHVzZU1lbnVCdXR0b25Qcm9wcyh7fSk7XG4gICAgY29uc3QgbWVudVByb3BzID0gdXNlTWVudVByb3BzKHt9KTtcbiAgICBjb25zdCB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiB1c2VGaXJzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbCgpO1xuICAgIGNvbnN0IHsgdXNlTWVudVNlbnRpbmVsUHJvcHM6IHVzZUxhc3RTZW50aW5lbFByb3BzIH0gPSB1c2VNZW51U2VudGluZWwoKTtcbiAgICBjb25zdCBmaXJzdFNlbnRpbmVsUHJvcHMgPSB1c2VGaXJzdFNlbnRpbmVsUHJvcHMoe30pO1xuICAgIGNvbnN0IGxhc3RTZW50aW5lbFByb3BzID0gdXNlTGFzdFNlbnRpbmVsUHJvcHMoe30pO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxNZW51SXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZU1lbnVJdGVtfT5cbiAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRNZW51UmVuZGVyKShtZW51UmV0dXJuLCBtZW51QnV0dG9uUHJvcHMsIG1lbnVQcm9wcywgZmlyc3RTZW50aW5lbFByb3BzLCBsYXN0U2VudGluZWxQcm9wcyl9XG4gICAgICAgIDwvTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIGluZGV4LCB0ZXh0LCBoaWRkZW4sIGJsdXJTZWxmLCBmbGFncywgZm9jdXNTZWxmIH06IE1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlTWVudUl0ZW1Qcm9wcywgLi4ucmVzdCB9ID0gdXNlQ29udGV4dChNZW51SXRlbUNvbnRleHQpKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9XG4gICAgfSk7XG4gICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdE1lbnVJdGVtUmVuZGVyKShyZXN0LCB1c2VNZW51SXRlbVByb3BzKHt9KSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRNZW51UmVuZGVyKG1lbnVJbmZvOiBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvPGFueSwgYW55LCBhbnk+LCBtZW51QnV0dG9uUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIG1lbnVQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgZmlyc3RTZW50aW5lbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYXN0U2VudGluZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIGNvbnN0IGZpcnN0U2VudGluZWwgPSA8ZGl2IHsuLi5maXJzdFNlbnRpbmVsUHJvcHN9IC8+O1xuICAgIGNvbnN0IGxhc3RTZW50aW5lbCA9IDxkaXYgey4uLmxhc3RTZW50aW5lbFByb3BzfSAvPjtcbiAgICBjb25zdCBtZW51ID0gPD57Zmlyc3RTZW50aW5lbH17bWVudVByb3BzLmNoaWxkcmVufXtsYXN0U2VudGluZWx9PC8+O1xuICAgIGNvbnN0IG1lbnVCdXR0b24gPSA8ZGl2IHsuLi5tZW51QnV0dG9uUHJvcHN9IC8+XG4gICAgLy9tZW51LnByb3BzLmNoaWxkcmVuID0gPD57Zmlyc3RTZW50aW5lbH17bWVudS5wcm9wcy5jaGlsZHJlbn17bGFzdFNlbnRpbmVsfTwvPlxuICAgIHJldHVybiAoXG4gICAgICAgIDw+e21lbnVCdXR0b259e21lbnV9PC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0TWVudUl0ZW1SZW5kZXI8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oaW5mbzogVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiwgbWVudUl0ZW1Qcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIHJldHVybiAoPGRpdiB7Li4ubWVudUl0ZW1Qcm9wc30gLz4pO1xufSIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUFyaWFSYWRpb0dyb3VwLCBVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnMsIFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFSYWRpb1BhcmFtZXRlcnMsIFVzZVJhZGlvLCBVc2VSYWRpb1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1yYWRpby1ncm91cFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBQcm9wczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwicmFkaW9Hcm91cFwiPixcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+IHtcbiAgICAvL3Byb3BzR3JvdXBMYWJlbDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBMYWJlbEVsZW1lbnQ+O1xuICAgIC8vcHJvcHNHcm91cDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBFbGVtZW50PjtcbiAgICByZW5kZXI/KGluZm86IFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiwgbGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwTGFiZWxFbGVtZW50PiwgZ3JvdXA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvUHJvcHM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyYWRpb1wiPixcbiAgICBHZXQ8VXNlQXJpYVJhZGlvUGFyYW1ldGVyczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUFyaWFSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0PFVzZUFyaWFSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+IHtcbiAgICAvLyBwcm9wc0xhYmVsOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuICAgIC8vcHJvcHNJbnB1dDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICByZW5kZXI/KGluZm86IFVzZVJhZGlvUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiwgaW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4sIGxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdyb3VwUmVuZGVyKGluZm86IFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88YW55PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgZ3JvdXBQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIGNvbnN0IGxhYmVsID0gPGRpdiB7Li4ubGFiZWxQcm9wc30gLz47XG4gICAgY29uc3QgZ3JvdXAgPSA8ZGl2IHsuLi5ncm91cFByb3BzfSAvPjtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAge2dyb3VwfVxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmNvbnN0IFJhZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlUmFkaW88YW55LCBhbnksIGFueT4+KG51bGwhKTtcbmV4cG9ydCBmdW5jdGlvbiBSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICByZW5kZXIsXG4gICAgdGFnR3JvdXAsXG4gICAgdGFnR3JvdXBMYWJlbCxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbmFtZSxcbiAgICBvbklucHV0LFxuICAgIHNlbGVjdGVkVmFsdWUsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIG9uVGFiYmVkSW5UbyxcbiAgICBvblRhYmJlZE91dE9mXG59OiBSYWRpb0dyb3VwUHJvcHM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSB7XG4gICAgY29uc3Qge1xuICAgICAgICB1c2VSYWRpbyxcbiAgICAgICAgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMsXG4gICAgICAgIHVzZVJhZGlvR3JvdXBQcm9wcyxcbiAgICAgICAgLi4ucmFkaW9Hcm91cFJldHVyblxuICAgIH0gPSB1c2VBcmlhUmFkaW9Hcm91cDxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICByYWRpb0dyb3VwOiB7IG5hbWUsIG9uSW5wdXQsIHNlbGVjdGVkVmFsdWUsIHRhZ0dyb3VwLCB0YWdHcm91cExhYmVsIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFJhZGlvQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlUmFkaW99PlxuICAgICAgICAgICAgeyhyZW5kZXIgPz8gZGVmYXVsdEdyb3VwUmVuZGVyKShyYWRpb0dyb3VwUmV0dXJuLCB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyh7fSksIHVzZVJhZGlvR3JvdXBQcm9wcyh7fSkpfVxuICAgICAgICA8L1JhZGlvQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJTZXBhcmF0ZShpbnB1dFRhZzogc3RyaW5nLCBpbnB1dExhYmVsOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVJhZGlvUmV0dXJuVHlwZUluZm88YW55PiwgaW5wdXRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQoaW5wdXRUYWcsIGlucHV0UHJvcHMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQoaW5wdXRMYWJlbCwgbGFiZWxQcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2lucHV0fVxuICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ29tYmluZWQoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VSYWRpb1JldHVyblR5cGVJbmZvPGFueT4sIGlucHV0UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIHsgY2hpbGRyZW4sIC4uLmxhYmVsUHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQoaW5wdXRUYWcsIGlucHV0UHJvcHMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQoaW5wdXRMYWJlbCwgeyAuLi5sYWJlbFByb3BzLCBjaGlsZHJlbjogPD57aW5wdXR9e2NoaWxkcmVufTwvPiB9KTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSYWRpbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGRpc2FibGVkLCBpbmRleCwgdGV4dCwgaGlkZGVuLCB0YWdJbnB1dCwgbGFiZWxQb3NpdGlvbiwgdGFnTGFiZWwsIHZhbHVlLCByZW5kZXIsIGZsYWdzLCBibHVyU2VsZiwgZm9jdXNTZWxmIH06IFJhZGlvUHJvcHM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0LCB1c2VSYWRpb0xhYmVsLCAuLi5yYWRpb1JldHVybiB9ID0gdXNlQ29udGV4dChSYWRpb0NvbnRleHQpKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgIHJhZGlvOiB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIHZhbHVlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgZm9jdXNTZWxmLCBibHVyU2VsZiB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXRQcm9wcyB9ID0gdXNlUmFkaW9JbnB1dCh7IHRhZzogdGFnSW5wdXQgfSk7XG4gICAgY29uc3QgeyB1c2VSYWRpb0xhYmVsUHJvcHMgfSA9IHVzZVJhZGlvTGFiZWwoeyB0YWc6IHRhZ0xhYmVsIH0pO1xuXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJTZXBhcmF0ZSh0YWdJbnB1dCwgdGFnTGFiZWwpKShyYWRpb1JldHVybiwgdXNlUmFkaW9JbnB1dFByb3BzKHt9KSwgdXNlUmFkaW9MYWJlbFByb3BzKHt9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyQ29tYmluZWQodGFnSW5wdXQsIHRhZ0xhYmVsKSkocmFkaW9SZXR1cm4sIHVzZVJhZGlvSW5wdXRQcm9wcyh7fSksIHVzZVJhZGlvTGFiZWxQcm9wcyh7fSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQXJpYVNsaWRlciwgVXNlQXJpYVNsaWRlclBhcmFtZXRlcnMsIFVzZUFyaWFTbGlkZXJUaHVtYiwgVXNlQXJpYVNsaWRlclRodW1iUGFyYW1ldGVycywgVXNlQXJpYVNsaWRlclRodW1iUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXNsaWRlclwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclByb3BzIGV4dGVuZHMgR2V0PFVzZUFyaWFTbGlkZXJQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPiwgR2V0PFVzZUFyaWFTbGlkZXJQYXJhbWV0ZXJzLCBcInNsaWRlclwiPiB7XG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xuICAgIC8vcmVuZGVyPyhpbmZvOiBVc2VBcmlhU2xpZGVyUmV0dXJuVHlwZUluZm8sKTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGh1bWJQcm9wczxUaHVtYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdldDxVc2VBcmlhU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudD4sIFwibWFuYWdlZENoaWxkXCI+LCBHZXQ8VXNlQXJpYVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQ+LCBcInNsaWRlclRodW1iXCI+IHtcbiAgICByZW5kZXI/KGluZm86IFVzZUFyaWFTbGlkZXJUaHVtYlJldHVyblR5cGVJbmZvLCB0aHVtYlByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaHVtYkVsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmNvbnN0IFNsaWRlclRodW1iQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVNsaWRlclRodW1iPGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFNsaWRlcih7IG1heCwgbWluLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgY2hpbGRyZW4gfTogU2xpZGVyUHJvcHMpIHtcbiAgICBjb25zdCB7IHVzZUFyaWFTbGlkZXJUaHVtYiwgLi4uX3NsaWRlckluZm8gfSA9IHVzZUFyaWFTbGlkZXIoe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgc2xpZGVyOiB7IG1heCwgbWluIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTbGlkZXJUaHVtYkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUFyaWFTbGlkZXJUaHVtYn0+e2NoaWxkcmVufTwvU2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIFNsaWRlclRodW1iVTxUaHVtYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgaW5kZXgsIGZsYWdzLCByZW5kZXIsIHZhbHVlVGV4dCB9OiBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudD4sIHJlZjogUmVmPFRodW1iRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZUFyaWFTbGlkZXJUaHVtYlByb3BzLCAuLi5zbGlkZXJJbmZvIH0gPSB1c2VDb250ZXh0KFNsaWRlclRodW1iQ29udGV4dCkoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHNsaWRlclRodW1iOiB7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgdmFsdWVUZXh0IH0gfSk7XG5cbiAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyVGh1bWIpKHNsaWRlckluZm8sIHVzZUFyaWFTbGlkZXJUaHVtYlByb3BzKHtyZWZ9KSlcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRodW1iKGluZm86IFVzZUFyaWFTbGlkZXJUaHVtYlJldHVyblR5cGVJbmZvLCB0aHVtYlByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XG4gICAgcmV0dXJuIDxpbnB1dCB7Li4udGh1bWJQcm9wc30gLz5cbn1cblxuZXhwb3J0IGNvbnN0IFNsaWRlclRodW1iID0gZm9yd2FyZFJlZihTbGlkZXJUaHVtYlUpIGFzIHR5cGVvZiBTbGlkZXJUaHVtYlU7XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQXJpYVRhYmxlLCBVc2VBcmlhVGFibGVCb2R5LCBVc2VBcmlhVGFibGVCb2R5UGFyYW1ldGVycywgVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvLCBVc2VBcmlhVGFibGVDZWxsLCBVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycywgVXNlQXJpYVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvLCBVc2VBcmlhVGFibGVQYXJhbWV0ZXJzLCBVc2VBcmlhVGFibGVSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYmxlUm93LCBVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzLCBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtdGFibGVcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUHJvcHM8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VBcmlhVGFibGVQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUFyaWFUYWJsZVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUFyaWFUYWJsZVBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VBcmlhVGFibGVQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VBcmlhVGFibGVQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIC8vdGFnVGFibGU6IEVsZW1lbnRUb1RhZzxUYWJsZUVsZW1lbnQ+O1xuICAgIC8vcHJvcHNUYWJsZSgpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+O1xuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCB0YWJsZVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVCb2R5UHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZUJvZHlQYXJhbWV0ZXJzIHtcbiAgICByZW5kZXI/KGluZm86IFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIHRhYmxlQm9keVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxTZWN0aW9uRWxlbWVudD4pOiBWTm9kZTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVIZWFkUHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcmVuZGVyPyh0YWJsZUhlYWRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8U2VjdGlvbkVsZW1lbnQ+KTogVk5vZGU7XG59XG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlRm9vdFByb3BzPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJlbmRlcj8odGFibGVGb290UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFNlY3Rpb25FbGVtZW50Pik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJhc1BhcmVudFJvd09mQ2VsbHNcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPiB7XG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIHRhYmxlUm93UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDZWxsUHJvcHM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUFyaWFUYWJsZUNlbGxQYXJhbWV0ZXJzLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0PFVzZUFyaWFUYWJsZUNlbGxQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgT21pdDxHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFwic3ViSW5mb1wiPiwgXCJsb2NhdGlvblwiPiB7XG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+LCB0YWJsZVJvd1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4pOiBWTm9kZTtcbn1cblxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI+KG51bGwhKTtcblxuY29uc3QgVGFibGVCb2R5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVRhYmxlQm9keTxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuY29uc3QgVGFibGVSb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFibGVSb3c8YW55LCBhbnk+PihudWxsISk7XG5jb25zdCBUYWJsZUNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFibGVDZWxsPGFueT4+KG51bGwhKTtcblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlKGluZm86IFVzZUFyaWFUYWJsZVJldHVyblR5cGVJbmZvPGFueSwgYW55PiwgdGFibGVQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIHJldHVybiA8dGFibGUgey4uLnRhYmxlUHJvcHN9IC8+XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUJvZHkoaW5mbzogVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvPGFueSwgYW55PiwgYm9keVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XG4gICAgcmV0dXJuIDx0Ym9keSB7Li4uYm9keVByb3BzfSAvPlxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVIZWFkKGhlYWRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIHJldHVybiA8dGhlYWQgey4uLmhlYWRQcm9wc30gLz5cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlRm9vdChmb290UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcbiAgICByZXR1cm4gPHRmb290IHsuLi5mb290UHJvcHN9IC8+XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZVJvdyhpbmZvOiBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIHJvd1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XG4gICAgcmV0dXJuIDx0ciB7Li4ucm93UHJvcHN9IC8+XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUNlbGwoaW5mbzogVXNlQXJpYVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPGFueT4sIGNlbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIHJldHVybiA8dGQgey4uLmNlbGxQcm9wc30gLz5cbn1cblxuZnVuY3Rpb24gVGFibGVVPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICBvblRhYmJlZEluVG8sXG4gICAgb25UYWJiZWRPdXRPZixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJlbmRlclxufTogVGFibGVQcm9wczxUYWJsZUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIHJlZjogUmVmPFRhYmxlRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keSwgdXNlVGFibGVQcm9wcywgdXNlVGFibGVSb3csIC4uLnRhYmxlSW5mbyB9ID0gdXNlQXJpYVRhYmxlPFRhYmxlRWxlbWVudCwgU2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjoge30sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJsZUJvZHlDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZUJvZHl9PlxuICAgICAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxuICAgICAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZSkodGFibGVJbmZvLCB1c2VUYWJsZVByb3BzKHsgcmVmIH0pKX1cbiAgICAgICAgICAgIDwvVGFibGVSb3dDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1RhYmxlQm9keUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBUYWJsZUJvZHlVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICByZW5kZXJcbn06IFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxTZWN0aW9uRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keVByb3BzLCAuLi5zZWN0aW9uSW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZUJvZHlDb250ZXh0KSh7fSk7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJib2R5XCI+eyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlQm9keSkoc2VjdGlvbkluZm8sIHVzZVRhYmxlQm9keVByb3BzKHsgcmVmIH0pKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbn1cblxuZnVuY3Rpb24gVGFibGVIZWFkVTxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyIH06IFRhYmxlSGVhZFByb3BzPFNlY3Rpb25FbGVtZW50PiwgcmVmOiBSZWY8U2VjdGlvbkVsZW1lbnQ+KSB7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJoZWFkXCI+eyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlSGVhZCkoeyByZWYgfSl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG59XG5cbmZ1bmN0aW9uIFRhYmxlRm9vdFU8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciB9OiBUYWJsZUZvb3RQcm9wczxTZWN0aW9uRWxlbWVudD4sIHJlZjogUmVmPFNlY3Rpb25FbGVtZW50Pikge1xuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiZm9vdFwiPnsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZUZvb3QpKHsgcmVmIH0pfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxufVxuXG5mdW5jdGlvbiBUYWJsZVJvd1U8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBpbmRleCxcbiAgICB0ZXh0LFxuICAgIGJsdXJTZWxmLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGZsYWdzLFxuICAgIGZvY3VzU2VsZixcbiAgICBoaWRkZW4sXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBub1R5cGVhaGVhZCxcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIG9uVGFiYmVkSW5UbyxcbiAgICBvblRhYmJlZE91dE9mLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgcmVuZGVyXG59OiBUYWJsZVJvd1Byb3BzPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIHJlZjogUmVmPFJvd0VsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGwsIHVzZVRhYmxlUm93UHJvcHMsIC4uLnJvd0luZm8gfSA9IHVzZUNvbnRleHQoVGFibGVSb3dDb250ZXh0KSh7XG4gICAgICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IHtcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9LFxuICAgICAgICAgICAgc3ViSW5mbzoge31cbiAgICAgICAgfSxcbiAgICAgICAgYXNQYXJlbnRSb3dPZkNlbGxzOiB7XG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlUm93OiB7IGxvY2F0aW9uOiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgfVxuICAgIH0pO1xuICAgIHJldHVybiA8VGFibGVDZWxsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVDZWxsfT57KHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyVGFibGVSb3cpKHJvd0luZm8sIHVzZVRhYmxlUm93UHJvcHMoeyByZWYgfSkpfTwvVGFibGVDZWxsQ29udGV4dC5Qcm92aWRlcj5cbn1cblxuZnVuY3Rpb24gVGFibGVDZWxsVTxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgaW5kZXgsIHRleHQsIGJsdXJTZWxmLCBmbGFncywgZm9jdXNTZWxmLCBoaWRkZW4sIHZhbHVlLCByZW5kZXIgfTogVGFibGVDZWxsUHJvcHM8Q2VsbEVsZW1lbnQ+LCByZWY6IFJlZjxDZWxsRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbFByb3BzLCAuLi5jZWxsSW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZUNlbGxDb250ZXh0KSh7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSxcbiAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgbG9jYXRpb246IHVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZUNlbGwpKGNlbGxJbmZvLCB1c2VUYWJsZUNlbGxQcm9wcyh7IHJlZiB9KSk7XG59XG5cbmV4cG9ydCBjb25zdCBUYWJsZSA9IGZvcndhcmRSZWYoVGFibGVVKSBhcyB0eXBlb2YgVGFibGVVO1xuZXhwb3J0IGNvbnN0IFRhYmxlQm9keSA9IGZvcndhcmRSZWYoVGFibGVCb2R5VSkgYXMgdHlwZW9mIFRhYmxlQm9keVU7XG5leHBvcnQgY29uc3QgVGFibGVIZWFkID0gZm9yd2FyZFJlZihUYWJsZUhlYWRVKSBhcyB0eXBlb2YgVGFibGVIZWFkVTtcbmV4cG9ydCBjb25zdCBUYWJsZUZvb3QgPSBmb3J3YXJkUmVmKFRhYmxlRm9vdFUpIGFzIHR5cGVvZiBUYWJsZUZvb3RVO1xuZXhwb3J0IGNvbnN0IFRhYmxlUm93ID0gZm9yd2FyZFJlZihUYWJsZVJvd1UpIGFzIHR5cGVvZiBUYWJsZVJvd1U7XG5leHBvcnQgY29uc3QgVGFibGVDZWxsID0gZm9yd2FyZFJlZihUYWJsZUNlbGxVKSBhcyB0eXBlb2YgVGFibGVDZWxsVTtcblxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVXNlQXJpYVRhYiwgVXNlQXJpYVRhYkxpc3RSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYlBhbmVsLCBVc2VBcmlhVGFiUGFyYW1ldGVycywgVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvLCB1c2VBcmlhVGFicywgVXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBVc2VBcmlhVGFic1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS10YWJzXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWJzUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQyPFVzZUFyaWFUYWJzUGFyYW1ldGVycywgXCJ0YWJMaXN0XCIsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQyPFVzZUFyaWFUYWJzUGFyYW1ldGVycywgXCJ0YWJMaXN0XCIsIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYlBhbmVsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XG4gICAgcmVuZGVyPyh0YWJzSW5mbzogVXNlQXJpYVRhYnNSZXR1cm5UeXBlSW5mbyAmIFVzZUFyaWFUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIGxhYmVsUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIHRhYkxpc3RQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJQcm9wczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlQXJpYVRhYlBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUFyaWFUYWJQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBHZXQ8VXNlQXJpYVRhYlBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4ge1xuICAgIC8vIHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdGJveEl0ZW1FbGVtZW50PjtcbiAgICAvLyBwcm9wc0xpc3RJdGVtOiAoYXJnczogQXJpYUxpc3Rib3hTaW5nbGVQcm9wc0Rlcml2ZWRGcm9tKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBsaXN0SXRlbTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5jb25zdCBUYWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFiPGFueT4+KG51bGwhKTtcbmNvbnN0IFRhYlBhbmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVRhYlBhbmVsPGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFRhYnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXIsXG4gICAgb25UYWJiZWRJblRvLFxuICAgIG9uVGFiYmVkT3V0T2YsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICByZW5kZXJcbn06IFRhYnNQcm9wczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBUYWJFbGVtZW50Pikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlQXJpYVRhYkxpc3QsXG4gICAgICAgIHVzZUFyaWFUYWJMaXN0TGFiZWwsXG4gICAgICAgIHVzZUFyaWFUYWJQYW5lbCxcbiAgICAgICAgLi4udGFic0luZm9cbiAgICB9ID0gdXNlQXJpYVRhYnM8TGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XG4gICAgICAgIHRhYkxpc3Q6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfSxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYlBhbmVsczoge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VBcmlhVGFiLCB1c2VBcmlhVGFiTGlzdFByb3BzLCAuLi50YWJsaXN0SW5mbyB9ID0gdXNlQXJpYVRhYkxpc3Qoe30pO1xuICAgIGNvbnN0IHsgdXNlQXJpYVRhYkxpc3RMYWJlbFByb3BzIH0gPSB1c2VBcmlhVGFiTGlzdExhYmVsKHt9KVxuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VGFiQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQXJpYVRhYn0+XG4gICAgICAgICAgICA8VGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBcmlhVGFiUGFuZWx9PlxuICAgICAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRUYWJzUmVuZGVyKSh7IC4uLnRhYnNJbmZvLCAuLi50YWJsaXN0SW5mbyB9LCB1c2VBcmlhVGFiTGlzdExhYmVsUHJvcHMoe30pLCB1c2VBcmlhVGFiTGlzdFByb3BzKHt9KSl9XG4gICAgICAgICAgICA8L1RhYlBhbmVsQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9UYWJDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgcmVuZGVyIH06IFRhYlByb3BzPFRhYkVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VBcmlhVGFiUHJvcHMsIC4uLnRhYkluZm8gfSA9IHVzZUNvbnRleHQoVGFiQ29udGV4dCkoeyBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0gfSk7XG5cbiAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0VGFiUmVuZGVyKSh0YWJJbmZvLCB1c2VBcmlhVGFiUHJvcHMoe30pKVxuXG5cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRhYnNSZW5kZXIodGFic0luZm86IFVzZUFyaWFUYWJzUmV0dXJuVHlwZUluZm8gJiBVc2VBcmlhVGFiTGlzdFJldHVyblR5cGVJbmZvPGFueT4sIGxhYmVsUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGxpc3RQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIGNvbnN0IGxhYmVsID0gPGRpdiB7Li4ubGFiZWxQcm9wc30gLz47XG4gICAgY29uc3QgbGlzdCA9IDxkaXYgey4uLmxpc3RQcm9wc30gLz47XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD57bGFiZWx9e2xpc3R9PC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0VGFiUmVuZGVyKHRhYkluZm86IFVzZUFyaWFUYWJSZXR1cm5UeXBlSW5mbzxhbnk+LCB0YWJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIGNvbnN0IHRhYiA9IDxkaXYgey4uLnRhYlByb3BzfSAvPjtcbiAgICByZXR1cm4gKHRhYilcbn1cbiIsImltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VBcmlhVG9vbHRpcCwgVXNlVG9vbHRpcFBhcmFtZXRlcnMsIFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtdG9vbHRpcFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBQcm9wczxUVCBleHRlbmRzIEVsZW1lbnQsIFRUVCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFBhcmFtZXRlcnMge1xuICAgIHJlbmRlcj86IChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8sIHRyaWdnZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VFQ+LCB0b29sdGlwUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRUVD4pID0+IFZOb2RlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbywgdHJpZ2dlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCB0b29sdGlwUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiB7Li4udHJpZ2dlclByb3BzfSAvPlxuICAgICAgICAgICAgPGRpdiB7Li4udG9vbHRpcFByb3BzfSAvPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmZ1bmN0aW9uIFRvb2x0aXBVPFRUIGV4dGVuZHMgRWxlbWVudCwgVFRUIGV4dGVuZHMgRWxlbWVudD4oeyBmb2N1c0RlbGF5LCBtb3VzZW91dERlbGF5LCBtb3VzZW92ZXJEZWxheSwgcmVuZGVyIH06IFRvb2x0aXBQcm9wczxUVCwgVFRUPikge1xuICAgIGNvbnN0IHsgdXNlVG9vbHRpcCwgdXNlVG9vbHRpcFRyaWdnZXIsIC4uLmluZm8gfSA9IHVzZUFyaWFUb29sdGlwPFRULCBUVFQ+KHsgZm9jdXNEZWxheSwgbW91c2VvdXREZWxheSwgbW91c2VvdmVyRGVsYXkgfSk7XG4gICAgY29uc3QgeyB1c2VUb29sdGlwVHJpZ2dlclByb3BzIH0gPSB1c2VUb29sdGlwVHJpZ2dlcigpO1xuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFByb3BzIH0gPSB1c2VUb29sdGlwKCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXIpKGluZm8sIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoe30pLCB1c2VUb29sdGlwUHJvcHMoe30pIGFzIGFueSl9XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGNvbnN0IFRvb2x0aXAgPSBmb3J3YXJkUmVmKFRvb2x0aXBVKSBhcyB1bmtub3duIGFzIHR5cGVvZiBUb29sdGlwVTtcbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEFyaWFBY2NvcmRpb24sIEFyaWFBY2NvcmRpb25TZWN0aW9uLCBIZWFkaW5nIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIERlbW9BY2NvcmRpb24ocHJvcHM6IFJlbmRlcmFibGVQcm9wczx7fT4pIHtcbiAgICByZXR1cm4gPEFyaWFBY2NvcmRpb24gey4uLnByb3BzfSByZW5kZXI9eyhpbmZvLCBjaGlsZHJlbikgPT4geyByZXR1cm4gPGRpdiBpZD1cImFjY29yZGlvbi1kZW1vXCI+e2NoaWxkcmVufTwvZGl2PiB9fSAvPlxufVxuXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uU2VjdGlvbih7IGluZGV4LCBib2R5LCBoZWFkaW5nLCBkaXNhYmxlZCwgb3BlbiB9OiB7IG9wZW4/OiBib29sZWFuLCBkaXNhYmxlZDogYm9vbGVhbiwgaW5kZXg6IG51bWJlciwgaGVhZGluZzogQ29tcG9uZW50Q2hpbGRyZW4sIGJvZHk6IENvbXBvbmVudENoaWxkcmVuIH0pIHtcbiAgICByZXR1cm4gPEFyaWFBY2NvcmRpb25TZWN0aW9uPEhUTUxEaXZFbGVtZW50LCBIVE1MRGl2RWxlbWVudD4gaW5kZXg9e2luZGV4fSBvcGVuPXtvcGVufSBkaXNhYmxlZD17ZGlzYWJsZWR9IHJlbmRlcj17KGluZm8sIGhlYWRlclByb3BzLCBib2R5UHJvcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz17PGRpdiB7Li4uaGVhZGVyUHJvcHN9PntoZWFkaW5nfSAoeyFpbmZvLmFjY29yZGlvblNlY3Rpb24uZXhwYW5kZWQgJiYgXCJub3QgXCJ9IG9wZW4pLCAoeyFpbmZvLmFjY29yZGlvblNlY3Rpb24uZm9jdXNlZCAmJiBcIm5vdCBcIn0gZm9jdXNlZCk8L2Rpdj59PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi5ib2R5UHJvcHN9Pntib2R5fTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfX0+PC9BcmlhQWNjb3JkaW9uU2VjdGlvbj5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9hY2NvcmRpb24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIEFjY29yZGlvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5FYWNoIHNlY3Rpb24ncyBoZWFkZXIgYW5kIGJvZHkgYXJlIGxpbmtlZCB2aWEgSUQ7IHRoZSBib2R5IGlzIDxjb2RlPmxhYmVsbGVkLWJ5PC9jb2RlPiB0aGUgaGVhZGVyIGFuZCB0aGUgaGVhZGVyIDxjb2RlPmNvbnRyb2w8L2NvZGU+cyB0aGUgYm9keS48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgaGVhZGVyIGlzIGEgYnV0dG9uIGFuZCByZXNwb25kcyB0byBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBldGMuIGV2ZW50cywgcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCB1c2VkLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPklmIHRoZSBoZWFkZXIgZWxlbWVudCBpcyBub3QgYSA8Y29kZT4mbHQ7YnV0dG9uJmd0OzwvY29kZT4gZWxlbWVudCwgaXQgaXMgZ2l2ZW4gdGhhdCA8Y29kZT5yb2xlPC9jb2RlPi48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5VcC9kb3duICZhbXA7IEhvbWUvRW5kIGtleXMgbmF2aWdhdGUgdGhyb3VnaCB0aGUgbGlzdCwgYXMgZG9lcyBUYWIgYW5kIFNoaWZ0K1RhYjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgPGNvZGU+cmVuZGVyPC9jb2RlPiBwcm9wIGVhY2ggPGNvZGU+QWNjb3JkaW9uU2VjdGlvbjwvY29kZT4gdGFrZXMgbXVzdCB3cmFwIHRoZSBoZWFkZXIgYnV0dG9uIHdpdGggYSA8YSBocmVmPVwiaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2FyaWEvI2hlYWRpbmdcIj5oZWFkaW5nPC9hPiAoZS5nLiA8Y29kZT5oMzwvY29kZT4sIG9yIDxjb2RlPiZsdDtIZWFkaW5nJmd0OzwvY29kZT4pLiBTZWUgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIGFuIGV4YW1wbGUuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YDxBcmlhQWNjb3JkaW9uIHJlbmRlcj17Li4ufT5cbiAgICA8QXJpYUFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezB9IHJlbmRlcj17Li4ufSAvPlxuICAgIDxBcmlhQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MX0gcmVuZGVyPXsuLi59IC8+XG4gICAgPEFyaWFBY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSByZW5kZXI9ey4uLn0gLz5cbjwvQXJpYUFjY29yZGlvbj5gfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uPlxuICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MH0gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICMwXCIgYm9keT1cIkJvZHkgY29udGVudCAjMFwiIGRpc2FibGVkPXtmYWxzZX0gLz5cbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzFcIiBkaXNhYmxlZD17ZmFsc2V9IC8+XG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzIgKGRpc2FibGVkKVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzJcIiBkaXNhYmxlZD17dHJ1ZX0gLz5cbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezN9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMyAoZm9yY2VkIG9wZW4pXCIgYm9keT1cIkJvZHkgY29udGVudCAjM1wiIGRpc2FibGVkPXtmYWxzZX0gb3Blbj17dHJ1ZX0gLz5cbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezR9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjNCAoZm9yY2VkIGNsb3NlZClcIiBib2R5PVwiQm9keSBjb250ZW50ICM0XCIgZGlzYWJsZWQ9e2ZhbHNlfSBvcGVuPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIDwvRGVtb0FjY29yZGlvbj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IEFyaWFCdXR0b24sIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xuICAgIHJldHVybiA8QXJpYUJ1dHRvbiBkaXNhYmxlZD17ZGlzYWJsZWR9IG9uUHJlc3M9e29uUHJlc3N9IHByZXNzZWQ9e30gey4uLnByb3BzfSB0YWc9e3RhZyBhcyBhbnl9ICAgLz5cbn0qL1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9idXR0b24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIEJ1dHRvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5XaGV0aGVyIHVzaW5nIGFuIGFjdHVhbCA8Y29kZT4mbHQ7YnV0dG9uJmd0OzwvY29kZT4sIG9yIHNvbWV0aGluZyBlbHNlIGxpa2UgYSA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT4sIHRoZSBwcm9wZXIgcm9sZXMgYW5kIGV2ZW50IGhhbmRsZXJzIHdpbGwgYmUgYXBwbGllZC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5CdXR0b25zIGNhbiBiZSB0b2dnbGVkIChwcmVzc2VkIG9yIHVucHJlc3NlZCkuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGJ1dHRvbiByZXNwb25kcyB0byBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBldGMuIGV2ZW50cywgcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCB1c2VkLlxuICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+RG91YmxlLWNsaWNrcyBkbyBub3Qgc2VsZWN0IHRleHQsIGJ1dCB0ZXh0IGlzIHN0aWxsIHNlbGVjdGFibGUgd2l0aG91dCBpdCBjb3VudGluZyBhcyBhIHByZXNzL2NsaWNrPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5XaGVuIEVudGVyIGlzIHByZXNzZWQsIHRoZSBidXR0b24gaXMgaW1tZWRpYXRlbHkgYWN0aXZhdGVkPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5XaGVuIFNwYWNlIGlzIHByZXNzZWQsIHRoZSBidXR0b24gaXMgYWN0aXZhdGVkIG9uY2UgcmVsZWFzZWQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmlPUyBTYWZhcmkgcHJvcGVybHkgZm9jdXNlcyB0aGUgYnV0dG9uPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBidXR0b24gY29udGFpbnMgb25seSBhbiBpY29uIChvciBvdGhlciBub24tZGVzY3JpcHRpdmUgY29udGVudCwgZXRjLiksIHlvdSBtdXN0IHByb3ZpZGUgYW4gPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gbWFudWFsbHkgc3RhdGluZyB3aGF0IGhhcHBlbnMgd2hlbiB0aGUgYnV0dG9uIGlzIHByZXNzZWQuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YDxBcmlhQnV0dG9uIHRhZz1cImJ1dHRvblwiPkJ1dHRvbjwvQXJpYUJ1dHRvbj5cbiAgICA8QXJpYUJ1dHRvbiB0YWc9XCJkaXZcIj5EaXY8L0FyaWFCdXR0b24+YH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcblxuICAgIGNvbnN0IG9uUHJlc3MgPSAoKSA9PiB7IGFsZXJ0KFwiQnV0dG9uIGNsaWNrZWRcIikgfVxuICAgIGNvbnN0IFtwcmVzc2VkLCBzZXRQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbjtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2ZhbHNlfSBvblByZXNzPXtvblByZXNzfSB0YWc9XCJidXR0b25cIj5CdXR0b248L0FyaWFCdXR0b24+XG4gICAgICAgICAgICA8QXJpYUJ1dHRvbiBkaXNhYmxlZD1cInNvZnRcIiBvblByZXNzPXtvblByZXNzfSB0YWc9XCJidXR0b25cIj5CdXR0b24sIGRpc2FibGVkIChzb2Z0KTwvQXJpYUJ1dHRvbj5cbiAgICAgICAgICAgIDxBcmlhQnV0dG9uIGRpc2FibGVkPVwiaGFyZFwiIG9uUHJlc3M9e29uUHJlc3N9IHRhZz1cImJ1dHRvblwiPkJ1dHRvbiwgZGlzYWJsZWQgKGhhcmQpPC9BcmlhQnV0dG9uPlxuICAgICAgICAgICAgPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2ZhbHNlfSBvblByZXNzPXtvblByZXNzfSB0YWc9XCJkaXZcIj5EaXY8L0FyaWFCdXR0b24+XG4gICAgICAgICAgICA8QXJpYUJ1dHRvbiBkaXNhYmxlZD1cInNvZnRcIiBvblByZXNzPXtvblByZXNzfSB0YWc9XCJkaXZcIj5EaXYsIGRpc2FibGVkIChzb2Z0KTwvQXJpYUJ1dHRvbj5cbiAgICAgICAgICAgIDxBcmlhQnV0dG9uIGRpc2FibGVkPVwiaGFyZFwiIG9uUHJlc3M9e29uUHJlc3N9IHRhZz1cImRpdlwiPkRpdiwgZGlzYWJsZWQgKGhhcmQpPC9BcmlhQnV0dG9uPlxuICAgICAgICAgICAgPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2ZhbHNlfSB0YWc9XCJidXR0b25cIiBwcmVzc2VkPXtwcmVzc2VkfSBvblByZXNzPXtlID0+IHNldFByZXNzZWQoZVtFdmVudERldGFpbF0ucHJlc3NlZCA/PyBmYWxzZSl9PkJ1dHRvbiAoe3ByZXNzZWQ/IFwicHJlc3NlZFwiIDogXCJ1bnByZXNzZWRcIn0pPC9BcmlhQnV0dG9uPlxuICAgICAgICA8Lz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgaCwgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgQXJpYUJ1dHRvbiwgQXJpYUNoZWNrYm94LCBFdmVudERldGFpbCB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG4vKmZ1bmN0aW9uIERlbW9CdXR0b24oeyB0YWcsIC4uLnByb3BzIH06IHsgdGFnOiBzdHJpbmcgfSAmIFJlbmRlcmFibGVQcm9wczx7fT4pIHtcbiAgICByZXR1cm4gPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2Rpc2FibGVkfSBvblByZXNzPXtvblByZXNzfSBwcmVzc2VkPXt9IHsuLi5wcm9wc30gdGFnPXt0YWcgYXMgYW55fSAgIC8+XG59Ki9cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvY2hlY2tib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIENoZWNrYm94IHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPlRvZ2dsZXMgYmV0d2VlbiBjaGVja2VkIGFuZCB1bmNoZWNrZWQgd2hlbiBwcmVzc2VkIChjbGlja2VkLCBFbnRlciBwcmVzc2VkLCBTcGFjZSByZWxlYXNlZCwgZXRjLik8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5DYW4gYmUgPGNvZGU+bWl4ZWQ8L2NvZGU+IGluc3RlYWQsIHRob3VnaCA8Y29kZT5vbklucHV0PC9jb2RlPiB3aWxsIG9ubHkgZXZlciBiZSBjYWxsZWQgd2l0aCA8Y29kZT50cnVlPC9jb2RlPiBvciA8Y29kZT5mYWxzZTwvY29kZT48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5TdXBwb3J0cyB1c2luZyA8Y29kZT4mbHQ7aW5wdXQmZ3Q7PC9jb2RlPnMgYW5kIDxjb2RlPiZsdDtsYWJlbCZndDs8L2NvZGU+cywgYXMgd2VsbCBhcyBqdXN0IHBsYWluIG9sJyA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT5zIG9uIGVpdGhlci9ib3RoPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoZWNrYm94IGFuZCBsYWJlbCBjYW4gYmUgc2libGluZyBlbGVtZW50cywgbGlrZSBub3JtYWwsIG9yIHRoZSBsYWJlbCBjYW4gd3JhcCB0aGUgaW5wdXQgZm9yIGEgbGFyZ2VyIGhpdCBhcmVhLiBJbiBhbGwgY2FzZXMsIHRoZSBhcHByb3ByaWF0ZSByb2xlcy9ldmVudCBoYW5kbGVycyB3aWxsIGJlIGFwcGxpZWQgdG8gZWFjaCBlbGVtZW50LjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkNoZWNrYm94IGdyb3VwcyAod2l0aCBhIHRyaS1zdGF0ZSBwYXJlbnQpIGFyZSBhIHNlcGFyYXRlIGNvbXBvbmVudC9ob29rPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPklmIHlvdXIgY2hlY2tib3ggZG9lcyBub3QgaGF2ZSBhIHZpc2libGUgbGFiZWwgKGFjaGlldmFibGUgYnkgYnkgb3ZlcnJpZGluZyB0aGUgPGNvZGU+cmVuZGVyPC9jb2RlPiBwcm9wIGFuZCBzZXR0aW5nIDxjb2RlPmxhYmVsUG9zaXRpb248L2NvZGU+IHRvIGJlIFwic2VwYXJhdGVcIiksIHlvdSBtdXN0IHBhc3MgPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gYXMgYSBwcm9wIHRvIHRoZSBjaGVja2JveCBtYW51YWxseS48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgPEFyaWFDaGVja2JveCBjaGVja2VkPXt0cnVlfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJsYWJlbFwiPkxhYmVsIHRleHQ8L0FyaWFDaGVja2JveD5gfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuXG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxBcmlhQnV0dG9uIHRhZz1cImJ1dHRvblwiIG9uUHJlc3M9eygpID0+IHsgc2V0Q2hlY2tlZChcIm1peGVkXCIgYXMgYW55KTsgfX0+Q2hhbmdlIHRvIG1peGVkPC9BcmlhQnV0dG9uPlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e2JvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIn19PjxBcmlhQ2hlY2tib3ggbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgY2hlY2tlZD17Y2hlY2tlZH0gb25JbnB1dD17ZSA9PiBzZXRDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpfSBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCI+U2VwYXJhdGUsIGlucHV0ICZhbXA7IGxhYmVsPC9BcmlhQ2hlY2tib3g+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Ym9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wifX0+PEFyaWFDaGVja2JveCBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBjaGVja2VkPXtjaGVja2VkfSBvbklucHV0PXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIj5XcmFwcGluZywgaW5wdXQgJmFtcDsgbGFiZWw8L0FyaWFDaGVja2JveD48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3tib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCJ9fT48QXJpYUNoZWNrYm94IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGNoZWNrZWQ9e2NoZWNrZWR9IG9uSW5wdXQ9e2UgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX0gZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImRpdlwiIHRhZ0xhYmVsPVwibGFiZWxcIj5TZXBhcmF0ZSwgZGl2ICZhbXA7IGxhYmVsPC9BcmlhQ2hlY2tib3g+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Ym9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wifX0+PEFyaWFDaGVja2JveCBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBjaGVja2VkPXtjaGVja2VkfSBvbklucHV0PXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImxhYmVsXCI+V3JhcHBpbmcsIGRpdiAmYW1wOyBsYWJlbDwvQXJpYUNoZWNrYm94PjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e2JvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIn19PjxBcmlhQ2hlY2tib3ggbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgY2hlY2tlZD17Y2hlY2tlZH0gb25JbnB1dD17ZSA9PiBzZXRDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpfSBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImRpdlwiPlNlcGFyYXRlLCBpbnB1dCAmYW1wOyBkaXY8L0FyaWFDaGVja2JveD48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3tib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCJ9fT48QXJpYUNoZWNrYm94IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGNoZWNrZWQ9e2NoZWNrZWR9IG9uSW5wdXQ9e2UgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX0gZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJkaXZcIj5XcmFwcGluZywgaW5wdXQgJmFtcDsgZGl2PC9BcmlhQ2hlY2tib3g+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Ym9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wifX0+PEFyaWFDaGVja2JveCBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiBjaGVja2VkPXtjaGVja2VkfSBvbklucHV0PXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImRpdlwiPlNlcGFyYXRlLCBkaXYgJmFtcDsgZGl2PC9BcmlhQ2hlY2tib3g+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Ym9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wifX0+PEFyaWFDaGVja2JveCBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBjaGVja2VkPXtjaGVja2VkfSBvbklucHV0PXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImRpdlwiPldyYXBwaW5nLCBkaXYgJmFtcDsgZGl2PC9BcmlhQ2hlY2tib3g+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7Ym9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wifX0+PEFyaWFDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PiBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiBjaGVja2VkPXtjaGVja2VkfSBvbklucHV0PXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiByZW5kZXI9eyhpbmZvLCBpbnB1dCwgbGFiZWwpID0+IHsgcmV0dXJuIDxpbnB1dCB7Li4uaW5wdXR9IGFyaWEtbGFiZWw9XCJIaWRkZW4gbGFiZWwgKHRlY2huaWNhbGx5IHNlcGFyYXRlKSwgaW5wdXQgJmFtcDsgbGFiZWxcIiAvPiB9fT5UaGlzIHRleHQgd2lsbCBub3QgYmUgcmVuZGVyZWQuPC9BcmlhQ2hlY2tib3g+PC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBoLCBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBBcmlhQnV0dG9uLCBBcmlhQ2hlY2tib3gsIENoZWNrYm94R3JvdXAsIENoZWNrYm94R3JvdXBDaGVja2JveCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcblxuLypmdW5jdGlvbiBEZW1vQnV0dG9uKHsgdGFnLCAuLi5wcm9wcyB9OiB7IHRhZzogc3RyaW5nIH0gJiBSZW5kZXJhYmxlUHJvcHM8e30+KSB7XG4gICAgcmV0dXJuIDxBcmlhQnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxufSovXG5cbmZ1bmN0aW9uIERlbW9DaGVja2JveCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBDaGVja2JveCAjJHtpbmRleH1gXG4gICAgcmV0dXJuIChcblxuICAgICAgICA8Q2hlY2tib3hHcm91cENoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IGluZGV4PXtpbmRleH0gZGlzYWJsZWQ9e2ZhbHNlfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiB0ZXh0PXtsYWJlbFRleHR9IHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgb25JbnB1dD17ZSA9PiBzZXRDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpfT57bGFiZWxUZXh0fTwvQ2hlY2tib3hHcm91cENoZWNrYm94PlxuICAgIClcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+Q2hlY2tib3ggZ3JvdXBzIGFyZSBhbiBhbHRlcm5hdGl2ZSB0byBtdWx0aS1zZWxlY3QgbGlzdHMuIFRoZXJlIGlzIG5vIHJvbGUgb2YgPGNvZGU+Y2hlY2tib3hncm91cDwvY29kZT4sIGJ1dCB0aGlzIGFpbXMgdG8gYmUgYW4gQVJJQS1jb21wbGlhbnQgaW1wbGVtZW50YXRpb24gb2YgYSBjaGVja2JveCBncm91cC48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkFsbCBub3JtYWwgPGNvZGU+QXJpYUNoZWNrYm94PC9jb2RlPiBmdW5jdGlvbmFsaXR5IGlzIHN1cHBvcnRlZCBvbiBlYWNoIGluZGl2aWR1YWwgY2hlY2tib3guPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCBzd2l0Y2hlcyBiZXR3ZWVuIDMgc3RhdGVzLCByZW1lbWJlcmluZyB0aGUgbGFzdCBzdGF0ZSB0aGF0IGNhdXNlZCBpdCB0byBiZSBcIm1peGVkXCIuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCByZWFjdHMgdG8gZWFjaCBjaGlsZCdzIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AgYW5kIHVwZGF0ZXMgaXRzIG93biBpbnRlcm5hbCA8Y29kZT5jaGVja2VkPC9jb2RlPiBhdHRyaWJ1dGUgKGJlIGF3YXJlIG9mIHRoaXMgaWYgdGhleSdyZSBhc3luY3Jvbm91cywgYXMgeW91J2xsIHdhbnQgdG8gZW5zdXJlIHRoZXkgYWxsIHJlc29sdmUgb24gdGhlIHNhbWUgdGljayB3aXRoIDxjb2RlPlByb21pc2UuYWxsPC9jb2RlPiB0byBub3QgY2xvYmJlciB0aGUgdXNlcidzIGlucHV0cykuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBhcmVudCBjaGVja2JveCBwcm92aWRlcyBzdWZmaWNpZW50IGxhYmVsbGluZyBmb3IgYWxsIHRoZSBjaGlsZHJlbiwgd2hpY2ggaG93IHRoZSBkZW1vIGV4YW1wbGUgaWRlbnRpZmllcyB0aGVzZSBlbGVtZW50cy4gSWYgeW91IGhhdmUgYSBzZXBhcmF0ZSBsYWJlbCwgeW91IHdpbGwgbmVlZCB0byB3cmFwIHRoZSBjaGlsZHJlbiBpbiBhIDxjb2RlPnJvbGU9Z3JvdXA8L2NvZGU+IHRoYXQgcmVmZXJlbmNlcyB0aGF0IGxhYmVsIGJ5IG92ZXJyaWRpbmcgPGNvZGU+cmVuZGVyPC9jb2RlPi48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5TZWUgdGhlIGNhdmVhdCBhYm92ZSBmb3Igd2hlbiBlYWNoIGNoaWxkJ3MgPGNvZGU+b25JbnB1dDwvY29kZT4gdGFrZXMgYSB2YXJpYWJsZSBhbW91bnQgb2YgdGltZSB0byBhY3R1YWxseSB1cGRhdGUgdGhlIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AsIGFzIGl0IGNhbiBjbG9iYmVyIHRoZSB1c2VyJ3MgbGFzdCBpbnB1dCB3aGVuIGNsaWNraW5nIG9uIHRoZSBwYXJlbnQ8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGNoZWNrYm94ZXM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8Q2hlY2tib3hHcm91cCBkaXNhYmxlZD17ZmFsc2V9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgbGFiZWxDaGlsZHJlbj1cIlBhcmVudCBjaGVja2JveFwiPlxuICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9DaGVja2JveCBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpKX1cbiAgICAgICAgICAgICAgICA8L0NoZWNrYm94R3JvdXA+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IEFyaWFCdXR0b24sIEFyaWFDaGVja2JveCwgTGlzdGJveE11bHRpLCBMaXN0Ym94TXVsdGlJdGVtLCBFdmVudERldGFpbCB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG4vKmZ1bmN0aW9uIERlbW9CdXR0b24oeyB0YWcsIC4uLnByb3BzIH06IHsgdGFnOiBzdHJpbmcgfSAmIFJlbmRlcmFibGVQcm9wczx7fT4pIHtcbiAgICByZXR1cm4gPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2Rpc2FibGVkfSBvblByZXNzPXtvblByZXNzfSBwcmVzc2VkPXt9IHsuLi5wcm9wc30gdGFnPXt0YWcgYXMgYW55fSAgIC8+XG59Ki9cblxuZnVuY3Rpb24gRGVtb0xpc3RJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zb2xlLmxvZyhgUmVuZGVyaW5nIExpc3RJdGVtICMke2luZGV4fSwgJHtzZWxlY3RlZC50b1N0cmluZygpfWApO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBMaXN0IGl0ZW0gIyR7aW5kZXh9JHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9YFxuICAgIHJldHVybiAoXG5cbiAgICAgICAgPExpc3Rib3hNdWx0aUl0ZW0gc2VsZWN0ZWQ9e3NlbGVjdGVkfSBpbmRleD17aW5kZXh9IGRpc2FibGVkPXtmYWxzZX0gdGV4dD17bGFiZWxUZXh0fSBvblNlbGVjdD17ZSA9PiB7ICgoKSA9PiB7IGNvbnNvbGUubG9nKGBDaGFuZ2luZyBzdGF0ZSB0byAke2VbRXZlbnREZXRhaWxdLnNlbGVjdGVkLnRvU3RyaW5nKCl9YCk7IHNldFNlbGVjdGVkKGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkKSB9KSB9fT4ge2xhYmVsVGV4dH08L0xpc3Rib3hNdWx0aUl0ZW0gPlxuICAgIClcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+Q2hlY2tib3ggZ3JvdXBzIGFyZSBhbiBhbHRlcm5hdGl2ZSB0byBtdWx0aS1zZWxlY3QgbGlzdHMuIFRoZXJlIGlzIG5vIHJvbGUgb2YgPGNvZGU+Y2hlY2tib3hncm91cDwvY29kZT4sIGJ1dCB0aGlzIGFpbXMgdG8gYmUgYW4gQVJJQS1jb21wbGlhbnQgaW1wbGVtZW50YXRpb24gb2YgYSBjaGVja2JveCBncm91cC48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkFsbCBub3JtYWwgPGNvZGU+QXJpYUNoZWNrYm94PC9jb2RlPiBmdW5jdGlvbmFsaXR5IGlzIHN1cHBvcnRlZCBvbiBlYWNoIGluZGl2aWR1YWwgY2hlY2tib3guPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCBzd2l0Y2hlcyBiZXR3ZWVuIDMgc3RhdGVzLCByZW1lbWJlcmluZyB0aGUgbGFzdCBzdGF0ZSB0aGF0IGNhdXNlZCBpdCB0byBiZSBcIm1peGVkXCIuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCByZWFjdHMgdG8gZWFjaCBjaGlsZCdzIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AgYW5kIHVwZGF0ZXMgaXRzIG93biBpbnRlcm5hbCA8Y29kZT5jaGVja2VkPC9jb2RlPiBhdHRyaWJ1dGUgKGJlIGF3YXJlIG9mIHRoaXMgaWYgdGhleSdyZSBhc3luY3Jvbm91cywgYXMgeW91J2xsIHdhbnQgdG8gZW5zdXJlIHRoZXkgYWxsIHJlc29sdmUgb24gdGhlIHNhbWUgdGljayB3aXRoIDxjb2RlPlByb21pc2UuYWxsPC9jb2RlPiB0byBub3QgY2xvYmJlciB0aGUgdXNlcidzIGlucHV0cykuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBhcmVudCBjaGVja2JveCBwcm92aWRlcyBzdWZmaWNpZW50IGxhYmVsbGluZyBmb3IgYWxsIHRoZSBjaGlsZHJlbiwgd2hpY2ggaG93IHRoZSBkZW1vIGV4YW1wbGUgaWRlbnRpZmllcyB0aGVzZSBlbGVtZW50cy4gSWYgeW91IGhhdmUgYSBzZXBhcmF0ZSBsYWJlbCwgeW91IHdpbGwgbmVlZCB0byB3cmFwIHRoZSBjaGlsZHJlbiBpbiBhIDxjb2RlPnJvbGU9Z3JvdXA8L2NvZGU+IHRoYXQgcmVmZXJlbmNlcyB0aGF0IGxhYmVsIGJ5IG92ZXJyaWRpbmcgPGNvZGU+cmVuZGVyPC9jb2RlPi48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5TZWUgdGhlIGNhdmVhdCBhYm92ZSBmb3Igd2hlbiBlYWNoIGNoaWxkJ3MgPGNvZGU+b25JbnB1dDwvY29kZT4gdGFrZXMgYSB2YXJpYWJsZSBhbW91bnQgb2YgdGltZSB0byBhY3R1YWxseSB1cGRhdGUgdGhlIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AsIGFzIGl0IGNhbiBjbG9iYmVyIHRoZSB1c2VyJ3MgbGFzdCBpbnB1dCB3aGVuIGNsaWNraW5nIG9uIHRoZSBwYXJlbnQ8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8TGlzdGJveE11bHRpIHRhZ0xhYmVsPVwibGFiZWxcIiB0YWdMaXN0PVwidWxcIj5cbiAgICAgICAgICAgICAgICAgICAgey8qPC9MaXN0Ym94TXVsdGk+KkFycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8ZGl2PjxEZW1vTGlzdEl0ZW0gaW5kZXg9e2l9IGtleT17aX0gLz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKSkqL31cbiAgICAgICAgICAgICAgICAgICAgPERlbW9MaXN0SXRlbSBpbmRleD17MH0gLz5cbiAgICAgICAgICAgICAgICAgICAgPERlbW9MaXN0SXRlbSBpbmRleD17MX0gLz5cbiAgICAgICAgICAgICAgICAgICAgPERlbW9MaXN0SXRlbSBpbmRleD17Mn0gLz5cbiAgICAgICAgICAgICAgICAgICAgPERlbW9MaXN0SXRlbSBpbmRleD17M30gLz5cbiAgICAgICAgICAgICAgICAgICAgPERlbW9MaXN0SXRlbSBpbmRleD17NH0gLz5cbiAgICAgICAgICAgICAgICA8L0xpc3Rib3hNdWx0aT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyByZW5kZXIsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSBcIi4uL2NvbXBvbmVudC9oZWFkaW5nXCI7XG5pbXBvcnQgKiBhcyBBY2NvcmRpb24gZnJvbSBcIi4vZGVtb3MvYWNjb3JkaW9uXCJcbmltcG9ydCAqIGFzIEJ1dHRvbiBmcm9tIFwiLi9kZW1vcy9idXR0b25cIlxuaW1wb3J0ICogYXMgQ2hlY2tib3ggZnJvbSBcIi4vZGVtb3MvY2hlY2tib3hcIlxuaW1wb3J0ICogYXMgQ2hlY2tib3hHcm91cCBmcm9tIFwiLi9kZW1vcy9jaGVja2JveC1ncm91cFwiXG5pbXBvcnQgKiBhcyBMaXN0Ym94TXVsdGkgZnJvbSBcIi4vZGVtb3MvbGlzdGJveC1tdWx0aVwiXG5cbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG5vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcXVldWVNaWNyb3Rhc2s7XG5cbi8vY29uc3QgUmFuZG9tV29yZHMgPSBcIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIi5zcGxpdChcIiBcIik7XG5cblxuY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJEZW1vc1wiPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkFjY29yZGlvblwiPjxBY2NvcmRpb24uRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJCdXR0b25cIj48QnV0dG9uLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQ2hlY2tib3hcIj48Q2hlY2tib3guRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJDaGVja2JveCBHcm91cFwiPjxDaGVja2JveEdyb3VwLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiTXVsdGktc2VsZWN0IExpc3Rib3hcIj48TGlzdGJveE11bHRpLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICB7LypcbiAgICAgICBcbiAgICAgICAgPERlbW9UYWJsZSAvPlxuXG5cbiAgICAgICAgPERlbW9Vc2VGb2N1c1RyYXAgLz5cbiAgICAgICAgPERlbW9Vc2VEcm9wcGFibGUgLz5cbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cbiAgICAgICAgPGlucHV0IC8+Ki99XG4gICAgICAgIDwvSGVhZGluZz4pXG59XG5cbnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xufSlcbiJdLCJuYW1lcyI6WyJIZWFkaW5nTGV2ZWxDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImhlYWRpbmciLCJwcm9wcyIsImhlYWRpbmdMZXZlbEJlZm9yZVVzIiwidXNlQ29udGV4dCIsInRhZyIsIm5ld0hlYWRpbmdMZXZlbCIsIndhcm5Pbk92ZXJ3cml0ZSIsIl9qc3giLCJjaGlsZHJlbiIsIl9qc3hzIiwiSGVhZGluZ1Jlc2V0IiwibmV3TGV2ZWwiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsImxlbmd0aCIsImZvckVhY2giLCJ2YWx1ZSIsImluZGV4IiwiaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkiLCJ1c2VSZWYiLCJzaG93bkVycm9yIiwiY3VycmVudCIsImNvbnNvbGUiLCJlcnJvciIsInVzZVBhc3NpdmVTdGF0ZSIsIm9uQ2hhbmdlIiwiZ2V0SW5pdGlhbFZhbHVlIiwidmFsdWVSZWYiLCJVbnNldCIsIndhcm5pbmdSZWYiLCJjbGVhbnVwQ2FsbGJhY2tSZWYiLCJ1bmRlZmluZWQiLCJvblNob3VsZENsZWFuVXAiLCJ1c2VDYWxsYmFjayIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiZXgiLCJnZXRWYWx1ZSIsIndhcm4iLCJ1c2VMYXlvdXRFZmZlY3QiLCJyIiwibWljcm90YXNrUXVldWVkIiwiYXJnIiwicHJldkRlcCIsImRlYm91bmNlUmVuZGVyaW5nIiwiZGVwIiwiRnVuY3Rpb24iLCJ1c2VNZXJnZWRDaGlsZHJlbiIsImxocyIsInJocyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsImUiLCJ0IiwiZiIsIm4iLCJBcnJheSIsImlzQXJyYXkiLCJjbHN4IiwiYXJndW1lbnRzIiwidXNlTWVyZ2VkQ2xhc3NlcyIsImNsYXNzIiwibGhzQ2xhc3MiLCJjbGFzc05hbWUiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiU2V0IiwiZnJvbSIsImpvaW4iLCJwcm9jZXNzUmVmIiwiaW5zdGFuY2UiLCJyZWYiLCJhc3NlcnQiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJzdHlsZSIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwibWFwIiwic3RhdGVtZW50IiwidXNlTWVyZ2VkU3R5bGVzIiwibG9nIiwidXNlTWVyZ2VkUHJvcHMiLCJsaHNBbGwiLCJyaHNBbGwiLCJfbGhzQ2hpbGRyZW4iLCJfbGhzQ2xhc3NOYW1lIiwiX2xoc1N0eWxlIiwiX2xoc1JlZiIsImxoc01pc2MiLCJfcmhzQ2hpbGRyZW4iLCJfcmhzQ2xhc3MiLCJfcmhzQ2xhc3NOYW1lIiwiX3Joc1N0eWxlIiwiX3Joc1JlZiIsInJoc01pc2MiLCJyZXQiLCJ1c2VNZXJnZWRSZWZzIiwicmhzRW50cmllcyIsImVudHJpZXMiLCJyaHNLZXlVIiwicmhzVmFsdWUiLCJyaHNLZXkiLCJsaHNWYWx1ZSIsIm1lcmdlZCIsIm1lcmdlRnVuY3Rpb25zIiwidXNlUmVmRWxlbWVudCIsImFyZ3MiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwiaGFuZGxlciIsInByZXZWYWx1ZSIsImFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIk1hcCIsImxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJ3aW5kb3dGb2N1c2VkVXBkYXRlcnMiLCJ3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzIiwibWljcm90YXNrcyIsImZvckVhY2hVcGRhdGVyIiwid2luZG93IiwiaGFzIiwiYWRkIiwiZGVsZXRlIiwidXBkYXRlcnMiLCJnZXQiLCJ1cGRhdGVyIiwiZm9jdXNvdXQiLCJ0YXJnZXQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJyZWxhdGVkVGFyZ2V0IiwiZm9jdXNpbiIsImN1cnJlbnRseUZvY3VzZWRFbGVtZW50IiwiVGFibGUiLCJiYXNlNjQiLCJyYW5kb202Qml0cyIsImdlbmVyYXRlUmFuZG9tSWQiLCJwcmVmaXgiLCJyYW5kb202NEJpdHMiLCJwcmV2aW91c0lucHV0cyIsInRvUnVuIiwiY29tbWl0TmFtZSIsIm9yaWdpbmFsQ29tbWl0Iiwib3B0aW9ucyIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsImNsZWFyIiwiZWZmZWN0IiwiaW5wdXRzIiwiU3ltYm9sIiwidXNlU3RhYmxlR2V0dGVyIiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwiRXJyb3IiLCJmbiIsImN1cnJlbnRDYWxsYmFja0dldHRlciIsImlzT2JqZWN0IiwidHlwZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290Iiwib2JqZWN0UHJvdG8iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0UmF3VGFnIiwiaXNPd24iLCJjYWxsIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsInNldFN0YXRlUCIsInVzZVN0YXRlUCIsInNldFN0YXRlIiwiY2FsbGJhY2siLCJuZXh0VmFsdWUiLCJpbXBsIiwidXNlRWZmZWN0TmF0aXZlIiwicHJldklucHV0cyIsImVmZmVjdDIiLCJjaGFuZ2VzIiwiaSIsIk1hdGgiLCJtYXgiLCJ0byIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdE5hdGl2ZSIsInBhcmVudFBhcmFtZXRlcnMiLCJtYW5hZ2VkQ2hpbGRyZW4iLCJvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QiLCJvbkNoaWxkcmVuTW91bnRDaGFuZ2UiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiY2hpbGQiLCJmaWVsZCIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMiLCJyZW1vdGVVTEVDaGlsZENoYW5nZWQiLCJzaXplIiwicmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwibW91bnRlZCIsImhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50cyIsInVubW91bnRzIiwic2hhdmUiLCJzcGxpY2UiLCJ1c2VNYW5hZ2VkQ2hpbGQiLCJtYW5hZ2VkQ2hpbGQiLCJpbmZvIiwiZmxhZ3MiLCJzdWJJbmZvIiwiZmxhdCIsImFycmF5U2xpY2UiLCJnZXREb2N1bWVudCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImdsb2JhbFRoaXMiLCJmYWN0b3J5IiwidGhpcyIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jbGFzc0NhbGxDaGVjayIsIlR5cGVFcnJvciIsInNsaWNlIiwibWF0Y2hlcyIsIkVsZW1lbnQiLCJtc01hdGNoZXNTZWxlY3RvciIsIl9mb2N1c2FibGVFbGVtZW50c1N0cmluZyIsIkluZXJ0Um9vdCIsInJvb3RFbGVtZW50IiwiaW5lcnRNYW5hZ2VyIiwiX2luZXJ0TWFuYWdlciIsIl9yb290RWxlbWVudCIsIl9tYW5hZ2VkTm9kZXMiLCJoYXNBdHRyaWJ1dGUiLCJfc2F2ZWRBcmlhSGlkZGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUiLCJfb2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiX29uTXV0YXRpb24iLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiZGVzdHJ1Y3RvciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbmVydE5vZGUiLCJfdW5tYW5hZ2VOb2RlIiwibm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJjb250YWlucyIsIm5vZGVUeXBlIiwiTm9kZSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJwYXJlbnROb2RlIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiX2Fkb3B0SW5lcnRSb290IiwiX21hbmFnZU5vZGUiLCJyZWdpc3RlciIsImRlcmVnaXN0ZXIiLCJfdW5tYW5hZ2VTdWJ0cmVlIiwiX3RoaXMzIiwiaW5lcnRTdWJyb290IiwiZ2V0SW5lcnRSb290Iiwic2V0SW5lcnQiLCJtYW5hZ2VkTm9kZXMiLCJzYXZlZEluZXJ0Tm9kZSIsInJlY29yZHMiLCJyZWNvcmQiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwiYXR0cmlidXRlTmFtZSIsIm1hbmFnZWROb2RlIiwic2V0IiwiYXJpYUhpZGRlbiIsIkluZXJ0Tm9kZSIsImluZXJ0Um9vdCIsIl9ub2RlIiwiX292ZXJyb2RlRm9jdXNNZXRob2QiLCJfaW5lcnRSb290cyIsIl9zYXZlZFRhYkluZGV4IiwiX2Rlc3Ryb3llZCIsImVuc3VyZVVudGFiYmFibGUiLCJfdGhyb3dJZkRlc3Ryb3llZCIsImRlc3Ryb3llZCIsInRhYkluZGV4IiwiaGFzU2F2ZWRUYWJJbmRleCIsImFkZEluZXJ0Um9vdCIsInJlbW92ZUluZXJ0Um9vdCIsIkluZXJ0TWFuYWdlciIsIl9kb2N1bWVudCIsIl93YXRjaEZvckluZXJ0IiwiYWRkSW5lcnRTdHlsZSIsImhlYWQiLCJkb2N1bWVudEVsZW1lbnQiLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9vbkRvY3VtZW50TG9hZGVkIiwiaW5lcnQiLCJwYXJlbnQiLCJfaW5lcnRSb290IiwiaW5lcnRFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpbmVydEVsZW1lbnQiLCJfdGhpcyIsInVuc2hpZnQiLCJzaGFkb3dSb290QW5jZXN0b3IiLCJzaGFkb3dSb290IiwibG9jYWxOYW1lIiwiY29udGVudCIsImRpc3RyaWJ1dGVkTm9kZXMiLCJnZXREaXN0cmlidXRlZE5vZGVzIiwic2xvdCIsIl9kaXN0cmlidXRlZE5vZGVzIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJfaSIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwiSFRNTEVsZW1lbnQiLCJfYmxvY2tpbmdFbGVtZW50cyIsIl9hbHJlYWR5SW5lcnRFbGVtZW50cyIsIl90b3BFbFBhcmVudHMiLCJfc2libGluZ3NUb1Jlc3RvcmUiLCJfaW5lcnRTaWJsaW5ncyIsIl9nZXRQYXJlbnRzIiwiX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJfaGFuZGxlTXV0YXRpb25zIiwibnVsbGFibGUiLCJ0b3AiLCJlbGVtcyIsInB1c2giLCJpbmRleE9mIiwiX3RvcENoYW5nZWQiLCJwb3AiLCJyZW1vdmUiLCJfYSIsIl9iIiwiX2MiLCJuZXdUb3AiLCJ0b0tlZXBJbmVydCIsIm9sZFBhcmVudHMiLCJfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyIsIm5ld1BhcmVudHMiLCJ0b1NraXAiLCJqIiwiX3N3YXBJbmVydGVkU2libGluZyIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsImVsZW1lbnRzIiwibW8iLCJzaWJsaW5ncyIsInNpYmxpbmciLCJpbmVydGVkU2libGluZ3MiLCJfaXNJbmVydGFibGUiLCJwYXJlbnRUb09ic2VydmUiLCJtYXliZVNoYWR5Um9vdCIsIl9fc2hhZHkiLCJob3N0IiwibXV0YXRpb25zIiwicGFyZW50cyIsIm11dGF0aW9uIiwiaWR4IiwiaW5lcnRlZENoaWxkIiwidXNlRm9yY2VVcGRhdGUiLCJ1c2VMb2dpY2FsRGlyZWN0aW9uIiwib25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIiwiZ2V0Q29tcHV0ZWRTdHlsZXMiLCJzZXRDb21wdXRlZFN0eWxlcyIsInJldHVybk51bGwiLCJnZXRFbGVtZW50IiwidXNlUmVmRWxlbWVudFByb3BzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInVzZUVsZW1lbnRTaXplUHJvcHMiLCJ1c2VFbGVtZW50U2l6ZSIsIm9uU2l6ZUNoYW5nZSIsIl8iLCJnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyIsImNvbXB1dGVkU3R5bGVzIiwidyIsIndyaXRpbmdNb2RlIiwiZCIsImRpcmVjdGlvbiIsInRleHRPcmllbnRhdGlvbiIsIldyaXRpbmdNb2RlcyIsImNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiIsImVsZW1lbnRPcmllbnRhdGlvbiIsImNvbnZlcnRUb1BoeXNpY2FsU2lkZSIsInNpZGUiLCJNIiwiYmxvY2tEaXJlY3Rpb24iLCJpbmxpbmVEaXJlY3Rpb24iLCJpbmxpbmVPcmllbnRhdGlvbiIsImNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24iLCJibG9ja09yaWVudGF0aW9uIiwiY29udmVydEVsZW1lbnRTaXplIiwiZWxlbWVudFNpemUiLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwiY2FwaXRhbGl6ZSIsImNsaWVudEJsb2NrU2l6ZSIsIm9mZnNldElubGluZVNpemUiLCJvZmZzZXRCbG9ja1NpemUiLCJzY3JvbGxJbmxpbmVTaXplIiwic2Nyb2xsQmxvY2tTaXplIiwiZjEiLCJnZXRQaHlzaWNhbExlZnRUb3AiLCJmMiIsImdldFBoeXNpY2FsUmlnaHRCb3R0b20iLCJmMyIsImY0IiwiY2xpZW50SW5saW5lSW5zZXQiLCJzY3JvbGxJbmxpbmVJbnNldCIsIm9mZnNldElubGluZUluc2V0Iiwic2Nyb2xsQmxvY2tJbnNldCIsIm9mZnNldEJsb2NrSW5zZXQiLCJjbGllbnRCbG9ja0luc2V0IiwiZGlyIiwiYiIsImwiLCJ1c2VUaW1lb3V0IiwidGltZW91dCIsInRyaWdnZXJJbmRleCIsInN0YWJsZUNhbGxiYWNrIiwidXNlU3RhYmxlQ2FsbGJhY2siLCJzdGFydFRpbWVSZWYiLCJnZXRUaW1lb3V0IiwidGltZW91dElzTnVsbCIsInVzZUxpbmVhck5hdmlnYXRpb24iLCJsaW5lYXJOYXZpZ2F0aW9uIiwibmF2aWdhdGVUb0ZpcnN0IiwibnRmIiwibmF2aWdhdGVUb0xhc3QiLCJudGwiLCJuYXZpZ2F0ZVRvTmV4dCIsIm50biIsIm5hdmlnYXRlVG9QcmV2IiwibnRwIiwibmF2aWdhdGlvbkRpcmVjdGlvbiIsIm5kIiwiZGlzYWJsZUFycm93S2V5cyIsImRhayIsImRpc2FibGVIb21lRW5kS2V5cyIsImRoZWsiLCJ1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMiLCJnZXREaXNhYmxlSG9tZUVuZEtleXMiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMiLCJvbktleURvd24iLCJjdHJsS2V5IiwibWV0YUtleSIsImdldE5hdmlnYXRpb25EaXJlY3Rpb24iLCJnZXREaXNhYmxlQXJyb3dLZXlzIiwiYWxsb3dzSW5saW5lTmF2aWdhdGlvbiIsInByb3BOYW1lIiwiZGlyZWN0aW9uQWxsb3dlZCIsImFsbG93c0Jsb2NrTmF2aWdhdGlvbiIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbiIsInR5cGVhaGVhZE5hdmlnYXRpb24iLCJjb2xsYXRvciIsImdldEluZGV4IiwidHlwZWFoZWFkVGltZW91dCIsInNldEluZGV4Iiwibm9UeXBlYWhlYWQiLCJjdXJyZW50VHlwZWFoZWFkIiwiZ2V0Q3VycmVudFR5cGVhaGVhZCIsInNldEN1cnJlbnRUeXBlYWhlYWQiLCJzZXRJbnZhbGlkVHlwZWFoZWFkIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldEltZUFjdGl2ZSIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJzYWZlTGhzIiwiY29tcGFyZSIsIm5vcm1hbGl6ZSIsInNhZmVSaHMiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUNvbXBhcmUiLCJpbnNlcnRpbmdDb21wYXJhdG9yIiwidGV4dCIsImNvbXBhcmF0b3JTaGFyZWQiLCJzdWJzdHJpbmciLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJfZSIsImltZUFjdGl2ZSIsInJldmVyc2UiLCJ1c2VSb3ZpbmdUYWJJbmRleCIsImluaXRpYWxJbmRleCIsIm9uVGFiYmVkSW5UbyIsIm9uVGFiYmVkT3V0T2YiLCJvblRhYmJhYmxlUmVuZGVyIiwib25UYWJiYWJsZUluZGV4Q2hhbmdlIiwic2V0QW55Rm9jdXNlZCIsIm5ld0NvdW50Iiwib2xkQ291bnQiLCJyZXR1cm5aZXJvIiwic2V0VGFiYmFibGVJbmRleDIiLCJmcm9tVXNlckludGVyYWN0aW9uIiwicHJldkluZGV4IiwibmV4dEluZGV4IiwiY2hhbmdlSW5kZXgiLCJuZXh0Q2hpbGQiLCJwYXJlbnRSZXR1cm5UeXBlIiwiZ2V0QXQiLCJwcmV2Q2hpbGQiLCJmb2N1c1NlbGYiLCJjb3B5QXJyYXkiLCJzb3VyY2UiLCJhcnJheSIsIm5hdGl2ZUZsb29yIiwiZmxvb3IiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJiYXNlUmFuZG9tIiwibG93ZXIiLCJ1cHBlciIsInNodWZmbGVTZWxmIiwibGFzdEluZGV4IiwicmFuZCIsImFycmF5U2h1ZmZsZSIsImFycmF5TWFwIiwiaXRlcmF0ZWUiLCJiYXNlVmFsdWVzIiwib2JqZWN0IiwiYmFzZVRpbWVzIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsImlzTGVuZ3RoIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiZnVuYyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJyZXF1aXJlIiwiYmluZGluZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJuYXRpdmVLZXlzIiwia2V5cyIsImJhc2VLZXlzIiwiYXN5bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJpc0FycmF5TGlrZSIsImJhc2VTaHVmZmxlIiwiY29sbGVjdGlvbiIsInNodWZmbGUiLCJzZXRGb3JjZVVwZGF0ZSIsInJlYXJyYW5nZSIsInNvcnRlZFJvd3MiLCJpbmRleEFzU29ydGVkIiwiaW5kZXhBc1Vuc29ydGVkIiwibWFuZ2xlTWFwIiwiZGVtYW5nbGVNYXAiLCJ1c2VSZWFycmFuZ2VhYmxlUHJvcHMiLCJmb3JjZVVwZGF0ZSIsIl9wcmV2IiwibWFuZ2xlZEluZGV4IiwiaW5kZXhNYW5nbGVyIiwiZGVtYW5nbGVkSW5kZXgiLCJzb3J0IiwiaCIsInJlYXJyYW5nZWFibGVDaGlsZHJlbiIsImluZGV4RGVtYW5nbGVyIiwidXNlU29ydGFibGVDaGlsZHJlbiIsInNvcnRhYmxlQ2hpbGRyZW4iLCJ1c2VyQ29tcGFyZSIsImRlZmF1bHRDb21wYXJlIiwidXNlU29ydGFibGVQcm9wcyIsInJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUiLCJ1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbiIsIm1jIiwicm92aW5nVGFiSW5kZXgiLCJsaXN0TmF2aWdhdGlvbiIsImlkZW50aXR5IiwidXNlUm92aW5nVGFiSW5kZXhDaGlsZCIsImdldFRhYmJhYmxlSW5kZXgiLCJzZXRUYWJiYWJsZUluZGV4IiwidHJ5TmF2aWdhdGVUb0luZGV4IiwiZGVmYXVsdCIsInNlYXJjaERpcmVjdGlvbiIsInVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCIsImMiLCJuYXZpZ2F0ZVRvSW5kZXgiLCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzIiwidXNlTGlzdE5hdmlnYXRpb25DaGlsZCIsImJsdXJTZWxmIiwiaGlkZGVuIiwidXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzIiwidGFiYmFibGUiLCJnZXRUYWJiYWJsZSIsInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyIsInVzZUdyaWROYXZpZ2F0aW9uIiwicnRpIiwibHMiLCJsbiIsInRuIiwiY3VycmVudENvbHVtbiIsInNldEN1cnJlbnRDb2x1bW4iLCJnZXRDdXJyZW50Q29sdW1uIiwidXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQiLCJwYXJlbnRMc1JldHVyblR5cGUiLCJ1c2VHcmlkTmF2aWdhdGlvblJvdyIsImFzQ2hpbGRSb3dPZlNlY3Rpb24iLCJhc0NoaWxkIiwiYXNQYXJlbnRSb3dPZkNlbGxzIiwiYXNQYXJlbnQiLCJjMiIsInVzZVJhbmRvbUlkIiwicmFuZG9tSWQiLCJiYWNrdXBSYW5kb21JZCIsImdldEJhY2t1cFJhbmRvbUlkIiwidXNlZElkIiwic2V0VXNlZElkIiwiZ2V0VXNlZElkIiwibWlzbWF0Y2hFcnJvclJlZiIsImV4Y2x1ZGVzIiwiZXhjbHVkZSIsIm9uQ2xpY2tTeW5jIiwiYWN0aXZlIiwic2V0QWN0aXZlIiwiZ2V0QWN0aXZlIiwidGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJ1c2VHbG9iYWxIYW5kbGVyIiwicHJldiIsIm5vZGVTZWxlY3RlZFRleHRMZW5ndGgiLCJEYXRlIiwiYSIsImN1cnJlbnRUaW1lIiwidGltZURpZmZlcmVuY2UiLCJjaGFyYWN0ZXJzU2VsZWN0ZWQiLCJoYW5kbGVQcmVzcyIsInB1bHNlIiwib25Nb3VzZURvd24iLCJkZXRhaWwiLCJidXR0b24iLCJvbkFjdGl2ZVN0YXJ0Iiwib25Nb3VzZVVwIiwib25BY3RpdmVTdG9wIiwib25CbHVyIiwidXNlQXJpYUFjY29yZGlvbiIsImFjY29yZGlvbiIsIl9jdXJyZW50Rm9jdXNlZEluZGV4Iiwic2V0Q3VycmVudEZvY3VzZWRJbmRleCIsImdldEN1cnJlbnRGb2N1c2VkSW5kZXgiLCJtY1JldHVyblR5cGUiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJtIiwidSIsIm9jbWMyIiwiY2hhbmdlVGFiYmVkSW5kZXgiLCJsaW5lYXJSZXR1cm5UeXBlIiwiY2hhbmdlRXhwYW5kZWRJbmRleCIsImdldEN1cnJlbnRJbmRleCIsIl9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCIsInVzZUNoaWxkcmVuRmxhZyIsIl9nZXRUYWJiZWRJbmRleCIsInJlZXZhbHVhdGVDbG9zZXN0Rml0IiwiY2xvc2VzdEZpdCIsImRpc2FibGVkIiwiYWNjb3JkaW9uU2VjdGlvbiIsIm9wZW4iLCJvcGVuRnJvbVVzZXIiLCJvcGVuRnJvbVBhcmVudCIsInNldE9wZW5Gcm9tUGFyZW50IiwiZ2V0T3BlbkZyb21QYXJlbnQiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQiLCJ1c2VCb2R5QXNTb3VyY2VJZCIsInVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQiLCJ1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZCIsImJvZHlJZCIsImdldEJvZHlJZCIsInVzZUJvZHlBc1JlZmVyZW5jZXJJZCIsImhlYWRlcklkIiwiZ2V0SGVhZGVySWQiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyIsInVzZUJvZHlBc1NvdXJjZUlkUHJvcHMiLCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMiLCJ1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyIsInVzZUhlYWRlckFzU291cmNlSWRQcm9wcyIsInVzZUhlYWRlckFzU291cmNlSWQiLCJ1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzIiwiZ2V0SGVhZGVyRWxlbWVudCIsInVzZUhlYWRlclJlZkVsZW1lbnRQcm9wcyIsImdldEJvZHlFbGVtZW50IiwidXNlQm9keVJlZkVsZW1lbnRQcm9wcyIsIm9wZW5SZWYiLCJib2R5RWxlbWVudCIsInF1ZXVlTWljcm90YXNrIiwiaXNWYWxpZCIsInJldHVyblRydWUiLCJ0YWJiZWRSZWYiLCJ1c2VMYWJlbCIsImxhYmVsIiwicHJlZml4SW5wdXQiLCJwcmVmaXhMYWJlbCIsInRhZ0lucHV0IiwidGFnTGFiZWwiLCJ1c2VMYWJlbEFzU291cmNlSWQiLCJ1c2VMYWJlbEFzUmVmZXJlbmNlcklkIiwibGFiZWxJZCIsImdldExhYmVsSWQiLCJ1c2VJbnB1dEFzU291cmNlSWQiLCJ1c2VJbnB1dEFzUmVmZXJlbmNlcklkIiwiaW5wdXRJZCIsImdldElucHV0SWQiLCJ1c2VMYWJlbEFzU291cmNlSWRQcm9wcyIsInVzZUlucHV0QXNTb3VyY2VJZFByb3BzIiwidXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzIiwidXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzIiwiaXNTeW50aGV0aWNMYWJlbCIsInVzZUxhYmVsTGFiZWwiLCJ1c2VMYWJlbExhYmVsUHJvcHMiLCJwcm9wc1dpdGhvdXRGb3IiLCJwcm9wc1dpdGhGb3IiLCJ1c2VMYWJlbElucHV0IiwicHJvcHNXaXRoQXJpYUxhYmVsbGVkQnkiLCJwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSIsImhhbmRsZXNJbnB1dCIsImxhYmVsUG9zaXRpb24iLCJ3aGljaCIsInVzZUFyaWFDaGVja2JveCIsImNoZWNrYm94TGlrZSIsImNoZWNrYm94IiwidXNlQ2hlY2tib3hHcm91cCIsImxpc3RSZXR1cm5UeXBlIiwiYWxsSWRzIiwiYXJpYUNvbnRyb2xzIiwic2V0QXJpYUNvbnRyb2xzIiwidXBkYXRlSW5kZXgiLCJzZXRJZFVwZGF0ZUluZGV4IiwiY2hlY2tlZENvdW50Iiwic2V0Q2hlY2tlZENvdW50IiwiY2hlY2tlZEluZGljZXMiLCJnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUiLCJwZXJjZW50YWdlIiwiZ2V0U2VsZklzQ2hlY2tlZFN0YWJsZSIsInNldFBhcmVudENoZWNrYm94Q2hlY2tlZCIsInNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCIsImRlYnVnTG9nIiwiY2hlY2tlZCIsInNldENoZWNrZWQiLCJ1c2VDaGVja2JveElucHV0RWxlbWVudCIsInVzZUNoZWNrYm94TGFiZWxFbGVtZW50Iiwib25JbnB1dCIsIm9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0MiIsInVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMiLCJ1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIiwidXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHMiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyIsInVzZUFyaWFMaXN0Ym94U2luZ2xlIiwibGlzdGJveFNpbmdsZSIsInNlbGVjdGlvbk1vZGUiLCJ0YWdMaXN0Iiwib25TZWxlY3QiLCJfbGJzIiwic2VsZWN0ZWRJbmRleCIsInNzIiwibGFiZWxSZXR1cm5UeXBlIiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiIsImN1cnJlbnRUYXJnZXQiLCJFdmVudERldGFpbCIsInNpbmdsZVNlbGVjdGlvbiIsInVzZUxhYmVsSW5wdXRQcm9wcyIsInN0YWJsZU9uU2VsZWN0IiwidXNlQXJpYUxpc3Rib3hNdWx0aSIsImxpc3Rib3hNdWx0aSIsInVzZUFyaWFUb29sdGlwIiwibW91c2VvdmVyRGVsYXkiLCJtb3VzZW91dERlbGF5IiwiZm9jdXNEZWxheSIsImdldE9wZW4iLCJkZWZhdWx0UHJldmVudGVkIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwic2V0T3BlbiIsInNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIiwic2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwic2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCIsImNhcHR1cmUiLCJzZXRUcmlnZ2VyRm9jdXNlZCIsImZvY3VzZWQiLCJkZWxheSIsImlzRmluaXRlIiwiaGFuZGxlIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJldHVybkZhbHNlIiwic2V0VG9vbHRpcEZvY3VzZWQiLCJzZXRUcmlnZ2VySG92ZXIiLCJob3ZlcmluZyIsInNldFRvb2x0aXBIb3ZlciIsInRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJ0cmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCIsInRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJ0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCIsInVzZVRvb2x0aXBUcmlnZ2VyIiwib25Ub3VjaEVuZCIsInVzZUhhc0ZvY3VzUHJvcHMiLCJ1c2VIYXNGb2N1cyIsIm9uRm9jdXNlZElubmVyQ2hhbmdlZCIsInVzZUFyaWFUYWJsZSIsImdldEN1cnJlbnRTb3J0Q29sdW1uIiwic2V0Q3VycmVudFNvcnRDb2x1bW4iLCJib2R5U29ydCIsInVzZUdyaWROYXZpZ2F0aW9uUHJvcHMiLCJyb3dzIiwiZ3JpZE5hdlJldDEiLCJ1c2VUYWJsZVJvdyIsInRhYmxlUm93IiwibG9jYXRpb24iLCJnZXRDZWxscyIsImNlbGxzIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsIiwidXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyIsImdyaWROYXZSZXQyIiwiYXNQYXJlbnRPZkNlbGxzIiwidXNlVGFibGVDZWxsIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMiLCJncmlkTmF2UmV0MyIsInNvcnRJbmZvIiwiY2VsbEluZGV4IiwiQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQiLCJBcmlhQWNjb3JkaW9uIiwiZXhwYW5kZWRJbmRleCIsInJlbmRlciIsImRlZmF1bHRSZW5kZXJTZXBhcmF0ZSIsImlucHV0VGFnIiwiaW5wdXRMYWJlbCIsImlucHV0UHJvcHMiLCJsYWJlbFByb3BzIiwiaW5wdXQiLCJkZWZhdWx0UmVuZGVyQ2hpbGRTZXBhcmF0ZSIsImRlZmF1bHRSZW5kZXJDaGlsZFdyYXBwaW5nIiwiZGVmYXVsdFJlbmRlcldyYXBwaW5nIiwiZGVmYXVsdFJlbmRlckdyb3VwU2VwYXJhdGUiLCJkZWZhdWx0UmVuZGVyR3JvdXBXcmFwcGluZyIsIlVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQiLCJMaXN0Ym94TXVsdGlDb250ZXh0IiwiTGlzdGJveE11bHRpVSIsIkxpc3Rib3hTaW5nbGVDb250ZXh0IiwiU2xpZGVyVGh1bWJDb250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiVGFibGVCb2R5Q29udGV4dCIsIlRhYmxlUm93Q29udGV4dCIsIlRhYmxlQ2VsbENvbnRleHQiLCJkZWZhdWx0UmVuZGVyVGFibGUiLCJ0YWJsZVByb3BzIiwiZGVmYXVsdFJlbmRlclRhYmxlQm9keSIsImJvZHlQcm9wcyIsImRlZmF1bHRSZW5kZXJUYWJsZUhlYWQiLCJoZWFkUHJvcHMiLCJkZWZhdWx0UmVuZGVyVGFibGVGb290IiwiZm9vdFByb3BzIiwicm93UHJvcHMiLCJkZWZhdWx0UmVuZGVyVGFibGVDZWxsIiwiY2VsbFByb3BzIiwiZGVmYXVsdFJlbmRlciIsInRyaWdnZXJQcm9wcyIsInRvb2x0aXBQcm9wcyIsIl9GcmFnbWVudCIsIkJsdXJiIiwiQ29kZSIsIkRlbW8iLCJBY2NvcmRpb24uRGVtbyIsIkJ1dHRvbi5EZW1vIiwiQ2hlY2tib3guRGVtbyIsIkNoZWNrYm94R3JvdXAuRGVtbyIsIkxpc3Rib3hNdWx0aS5EZW1vIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
