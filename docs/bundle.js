(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t,
        o$2,
        r$2,
        f$1 = {},
        e$1 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$2(n, l) {
      if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$2(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b(n) {
      (!n.__d && (n.__d = !0) && t.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t.length;) n = t.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$2(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$1,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$2(i, h + 1)), N(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$1(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x$1(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x$1(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$2(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$1(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$2(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$2(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null, n.__c = void 0;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P$1(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
    }

    function B$2(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$1.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
    }, d$1.prototype.render = p$1, t = [], g$2.__r = 0, r$2 = 0;

    var _$1 = 0;

    function o$1(o, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: o,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --_$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof o && (l = o.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var r$1,
        u,
        i,
        o,
        f = 0,
        c = [],
        e = [],
        a = l$1.__b,
        v = l$1.__r,
        l = l$1.diffed,
        m = l$1.__c,
        d = l$1.unmount;

    function p(t, r) {
      l$1.__h && l$1.__h(u, t, f || r), f = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: e
      }), i.__[t];
    }

    function y(n) {
      return f = 1, h(C$1, n);
    }

    function h(n, t, i) {
      var o = p(r$1++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(t) : C$1(void 0, t), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = u, !u.u)) {
        u.u = !0;
        var f = u.shouldComponentUpdate;

        u.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !f || f.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function s(t, i) {
      var o = p(r$1++, 3);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__H.__h.push(o));
    }

    function _(t, i) {
      var o = p(r$1++, 4);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__h.push(o));
    }

    function A(n) {
      return f = 5, T$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function T$1(n, t) {
      var u = p(r$1++, 7);
      return B$1(u.__H, t) ? (u.__V = n(), u.i = t, u.__h = n, u.__V) : u.__;
    }

    function q$1(n, t) {
      return f = 8, T$1(function () {
        return n;
      }, t);
    }

    function x(n) {
      var t = u.context[n.__c],
          i = p(r$1++, 9);
      return i.c = n, t ? (null == i.__ && (i.__ = !0, t.sub(u)), t.props.value) : n.__;
    }

    function g$1() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(w$1), t.__H.__h.forEach(z$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      "function" != typeof n.type || n.__m || n.type === p$1 ? n.__m || (n.__m = n.__ && n.__.__m ? n.__.__m : "") : n.__m = (n.__ && n.__.__m ? n.__.__m : "") + (n.__ && n.__.__k ? n.__.__k.indexOf(n) : 0), u = null, a && a(n);
    }, l$1.__r = function (n) {
      v && v(n), r$1 = 0;
      var t = (u = n.__c).__H;
      t && (i === u ? (t.__h = [], u.__h = [], t.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = e, n.__N = n.i = void 0;
      })) : (t.__h.forEach(w$1), t.__h.forEach(z$1), t.__h = [])), i = u;
    }, l$1.diffed = function (t) {
      l && l(t);
      var r = t.__c;
      r && r.__H && (r.__H.__h.length && (1 !== c.push(r) && o === l$1.requestAnimationFrame || ((o = l$1.requestAnimationFrame) || k)(g$1)), r.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== e && (n.__ = n.__V), n.i = void 0, n.__V = e;
      })), i = u = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(w$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || z$1(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), m && m(t, r);
    }, l$1.unmount = function (t) {
      d && d(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          w$1(n);
        } catch (n) {
          r = n;
        }
      }), u.__H = void 0, r && l$1.__e(r, u.__v));
    };
    var j$1 = "function" == typeof requestAnimationFrame;

    function k(n) {
      var t,
          r = function () {
        clearTimeout(u), j$1 && cancelAnimationFrame(t), setTimeout(n);
      },
          u = setTimeout(r, 100);

      j$1 && (t = requestAnimationFrame(r));
    }

    function w$1(n) {
      var t = u,
          r = n.__c;
      "function" == typeof r && (n.__c = void 0, r()), u = t;
    }

    function z$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function B$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function C$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    function g(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function C(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    function w(n, e) {
      function r(n) {
        var t = this.props.ref,
            r = t == n.ref;
        return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
      }

      function u(e) {
        return this.shouldComponentUpdate = r, h$1(n, e);
      }

      return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
    }

    (E.prototype = new d$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var R = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
    };

    var O = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      O(n, t, e, r);
    };

    var T = l$1.unmount;

    function I(n, t, e) {
      return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
        "function" == typeof n.__c && n.__c();
      }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
        return I(n, t, e);
      })), n;
    }

    function L(n, t, e) {
      return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
        return L(n, t, e);
      }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
    }

    function U() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function D(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), T && T(n);
    }, (U.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = D(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = L(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, U.prototype.componentWillUnmount = function () {
      this.t = [];
    }, U.prototype.render = function (n, e) {
      if (this.__b) {
        if (this.__v.__k) {
          var r = document.createElement("div"),
              o = this.__v.__k[0].__c;
          this.__v.__k[0] = I(this.__b, r, o.__O = o.__P);
        }

        this.__b = null;
      }

      var i = e.__a && h$1(p$1, null, n.fallback);
      return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
    };

    var V = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function W(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function P(n) {
      var e = this,
          r = n.i;
      e.componentWillUnmount = function () {
        P$1(null, e.l), e.l = null, e.i = null;
      }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
        nodeType: 1,
        parentNode: r,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        insertBefore: function (n, t) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
        }
      }), P$1(h$1(W, {
        context: e.context
      }, n.__v), e.l)) : e.l && e.componentWillUnmount();
    }

    function $(n, e) {
      var r = h$1(P, {
        __v: n,
        i: e
      });
      return r.containerInfo = e, r;
    }

    (M.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = D(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), V(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x$1(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        V(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        B = "undefined" != typeof document,
        H = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
      Object.defineProperty(d$1.prototype, t, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + t];
        },
        set: function (n) {
          Object.defineProperty(this, t, {
            configurable: !0,
            writable: !0,
            value: n
          });
        }
      });
    });
    var q = l$1.event;

    function G() {}

    function J() {
      return this.cancelBubble;
    }

    function K() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return q && (n = q(n)), n.persist = G, n.isPropagationStopped = J, n.isDefaultPrevented = K, n.nativeEvent = n;
    };

    var X = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        nn = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          u = e;

      if ("string" == typeof t) {
        var o = -1 === t.indexOf("-");

        for (var i in u = {}, e) {
          var l = e[i];
          B && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !H(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && z.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
        }

        "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$1(e.children).forEach(function (n) {
          n.props.selected = -1 != u.value.indexOf(n.props.value);
        })), "select" == t && null != u.defaultValue && (u.value = x$1(e.children).forEach(function (n) {
          n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
        })), n.props = u, e.class != e.className && (X.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", X));
      }

      n.$$typeof = j, nn && nn(n);
    };

    var tn = l$1.__r;

    l$1.__r = function (n) {
      tn && tn(n), n.__c;
    };

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }
    const alreadyWarned = new Set();
    function warnOnOverwrite(componentName, propName, propValue, newValue) {
      const key = `${componentName};${propName}`;

      if (propValue != null) {
        if (!alreadyWarned.has(key)) {
          alreadyWarned.add(key);
          console.warn(`The ${propName} attribute on ${componentName} was given a value of ${propValue} but is being overwritten to ${newValue} for conformance. Consider removing it before passing those props to ${componentName}.`);
        }
      }

      return newValue;
    }
    function debugLog(who) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
    }

    const HeadingLevelContext = B$2(0);
    const Heading = w(function Heading(_ref) {
      let {
        children,
        heading,
        ...props
      } = _ref;
      const headingLevelBeforeUs = x(HeadingLevelContext);
      const newHeadingLevel = headingLevelBeforeUs + 1;
      let tag;

      if (newHeadingLevel <= 6) {
        tag = `h${newHeadingLevel}`;
      } else {
        tag = 'div';
        props["aria-level"] = warnOnOverwrite("Heading", "aria-level", props["aria-level"], `${newHeadingLevel}`);
      }

      return o$1(p$1, {
        children: o$1(HeadingReset, {
          newLevel: headingLevelBeforeUs + 1,
          children: [h$1(tag, props, heading), children]
        })
      });
    });
    const HeadingReset = w(function HeadingReset(_ref2) {
      let {
        newLevel,
        children
      } = _ref2;
      return o$1(HeadingLevelContext.Provider, {
        value: newLevel,
        children: children
      });
    });

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = A(value);
        const shownError = A(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    function debounceRendering(f) {
      var _options$debounceRend;

      ((_options$debounceRend = l$1.debounceRendering) !== null && _options$debounceRend !== void 0 ? _options$debounceRend : setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
     * @returns
     */

    function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
      const valueRef = A(Unset$1);
      const warningRef = A(false);
      const cleanupCallbackRef = A(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = q$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = q$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = q$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      _(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const r = A({
        prevDep: Unset$1
      });
      const setValue = q$1(arg => {
        // Regardless of anything else, figure out what our next value is about to be.
        const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;

        if (r.current.prevDep === Unset$1 && nextValue !== valueRef.current) {
          // This is the first request to change this value.
          // Evaluate the request immediately, then queue up the onChange function
          // Save our current value so that we can compare against it later
          // (if we flip back to this state, then we won't send the onChange function)
          r.current.prevDep = valueRef.current; // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately

          valueRef.current = nextValue; // Schedule the actual check and invocation of onChange later to let effects settle

          (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
            const nextDep = valueRef.current;
            const prevDep = r.current.prevDep;

            if (r.current.prevDep != valueRef.current) {
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = nextDep;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            } // We've finished with everything, so mark us as being on a clean slate again.


            r.current.prevDep = Unset$1;
          });
        } // Update the value immediately.
        // This will be checked against prevDep to see if we should actually call onChange


        valueRef.current = nextValue;
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }

    /*
    const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
    const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
    const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
    const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map(); //const microtasks = new Map<Set<any>, any>();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      const updaters = map.get(window);

      if (updaters) {
        //if (!microtasks.has(updatersKey)) {
        //debounceRendering(() => {
        //const updatersKey = map.get(window)!;
        //const value = microtasks.get(updatersKey);
        //microtasks.delete(updatersKey);
        if (updaters) {
          for (const updater of updaters) {
            const {
              lastSent,
              send
            } = updater;

            if (value !== lastSent) {
              send(value);
              updater.lastSent = value;
            }
          }
        } //});
        //}
        //microtasks.set(updatersKey, value);

      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
      s(() => {
        var _getWindow, _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

        const document = getDocument();
        const window = (_getWindow = getWindow === null || getWindow === void 0 ? void 0 : getWindow(document)) !== null && _getWindow !== void 0 ? _getWindow : document === null || document === void 0 ? void 0 : document.defaultView;

        if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
          document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
            passive: true
          });
          document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
            passive: true
          });
        } // Add them even if they're undefined to more easily
        // manage the ">0 means don't add handlers" logic.


        const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
        const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
        const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
        const laeu = {
          send: setActiveElement,
          lastSent: undefined
        };
        const llaeu = {
          send: setLastActiveElement,
          lastSent: undefined
        };
        const lwfu = {
          send: setWindowFocused,
          lastSent: undefined
        };
        localActiveElementUpdaters.add(laeu);
        localLastActiveElementUpdaters.add(llaeu);
        localWindowFocusedUpdaters.add(lwfu);
        activeElementUpdaters.set(window, localActiveElementUpdaters);
        lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
        windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
        return () => {
          activeElementUpdaters.get(window).delete(laeu);
          lastActiveElementUpdaters.get(window).delete(laeu);
          windowFocusedUpdaters.get(window).delete(lwfu);

          if (activeElementUpdaters.size === 0) {
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
            window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
            window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
          }
        };
      }, []);
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table$1[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = y(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      s(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = A(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return q$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return q$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B$2(null);

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */

    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString$1 = objectProto$5.toString;
    /** Built-in value references. */

    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */

    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString = objectProto$4.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */

    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    /** Built-in value references. */

    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = y(initialState);
      const ref = A(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = q$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(parentParameters) {
      const {
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = q$1(() => {
        return managedChildrenArray.current.highestIndex;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = A({
        arr: [],
        rec: {},
        highestIndex: 0,
        lowestIndex: 0
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which needs to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = q$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          if (child) f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = q$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = A(null);
      const remoteULEChildChangedCausers = A(new Set());
      const remoteULEChildChanged = q$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = q$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (mounted) {
          managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
        } else {
          if (typeof index == "number") {
            delete managedChildrenArray.current.arr[index];
            let shave = 0;

            while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
              ++shave;
            }

            managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
          } else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = q$1(_ref => {
        let {
          managedChild: info
        } = _ref;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        _(() => {
          // Insert this information in-place
          if (typeof info.index == "number") {
            var _info$flags;

            managedChildrenArray.current.arr[info.index] = {
              index: info.index,
              flags: (_info$flags = info.flags) !== null && _info$flags !== void 0 ? _info$flags : {},
              subInfo: info.subInfo
            };
          } else {
            var _info$flags2;

            managedChildrenArray.current.rec[info.index] = {
              index: info.index,
              flags: (_info$flags2 = info.flags) !== null && _info$flags2 !== void 0 ? _info$flags2 : {},
              subInfo: info.subInfo
            };
          }

          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
        // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        _(() => {
          remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
          return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, false);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = A({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        arraySlice: () => {
          return managedChildrenArray.current.arr.slice();
        }
      });
      return {
        useManagedChild,
        managedChildren: {
          children: managedChildren.current
        }
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref2) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key
      } = _ref2;
      useEnsureStability("useChildrenFlag", onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, [])); //    const getFitNullToZero = useStableGetter(fitNullToZero);
      // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = q$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          var _child$flags, _child$flags$key;

          if ((_child$flags = child.flags) !== null && _child$flags !== void 0 && (_child$flags$key = _child$flags[key]) !== null && _child$flags$key !== void 0 && _child$flags$key.isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const reevaluateClosestFit = useStableCallback(() => {
        var _currentChild$flags, _currentChild$flags$k;

        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !((_currentChild$flags = currentChild.flags) !== null && _currentChild$flags !== void 0 && (_currentChild$flags$k = _currentChild$flags[key]) !== null && _currentChild$flags$k !== void 0 && _currentChild$flags$k.isValid()))) {
          var _currentChild$flags2;

          currentChild === null || currentChild === void 0 ? void 0 : (_currentChild$flags2 = currentChild.flags) === null || _currentChild$flags2 === void 0 ? void 0 : _currentChild$flags2[key].set(false);
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex);

          if (closestFitIndex != null) {
            var _closestFitChild$flag;

            const closestFitChild = children.getAt(closestFitIndex);
            console.assert(closestFitChild != null, "Internal logic???");
            (_closestFitChild$flag = closestFitChild.flags) === null || _closestFitChild$flag === void 0 ? void 0 : _closestFitChild$flag[key].set(true);
          }
        }
      });
      const changeIndex = q$1(arg => {
        const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg; //if (requestedIndex == null && getFitNullToZero())
        //    requestedIndex = 0;

        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          var _oldMatchingChild$fla;

          // Easy case
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla = oldMatchingChild.flags) === null || _oldMatchingChild$fla === void 0 ? void 0 : _oldMatchingChild$fla[key].set(false);
          return null;
        } else {
          var _newMatchingChild$fla;

          if (newMatchingChild && (_newMatchingChild$fla = newMatchingChild.flags) !== null && _newMatchingChild$fla !== void 0 && _newMatchingChild$fla[key].isValid()) {
            var _oldMatchingChild$fla2, _newMatchingChild$fla2;

            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla2 = oldMatchingChild.flags) === null || _oldMatchingChild$fla2 === void 0 ? void 0 : _oldMatchingChild$fla2[key].set(false);
            (_newMatchingChild$fla2 = newMatchingChild.flags) === null || _newMatchingChild$fla2 === void 0 ? void 0 : _newMatchingChild$fla2[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              var _oldMatchingChild$fla3, _newMatchingChild$fla3;

              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla3 = oldMatchingChild.flags) === null || _oldMatchingChild$fla3 === void 0 ? void 0 : _oldMatchingChild$fla3[key].set(false);
              (_newMatchingChild$fla3 = newMatchingChild.flags) === null || _newMatchingChild$fla3 === void 0 ? void 0 : _newMatchingChild$fla3[key].set(true);
              return closestFitIndex;
            } else {
              var _oldMatchingChild$fla4;

              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla4 = oldMatchingChild.flags) === null || _oldMatchingChild$fla4 === void 0 ? void 0 : _oldMatchingChild$fla4[key].set(false);
              return null;
            }
          }
        }
      }, []);
      _(() => {
        var _children$getAt, _children$getAt$flags, _children$getAt$flags2;

        if (initialIndex != null) (_children$getAt = children.getAt(initialIndex)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$flags = _children$getAt.flags) === null || _children$getAt$flags === void 0 ? void 0 : (_children$getAt$flags2 = _children$getAt$flags[key]) === null || _children$getAt$flags2 === void 0 ? void 0 : _children$getAt$flags2.set(true);
      }, []);
      return {
        changeIndex,
        reevaluateClosestFit,
        getCurrentIndex
      };
    }

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    function getDocument$d(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      var _rhs$_count, _lhs$_count;

      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = q$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);
      combined._count = ((_rhs$_count = rhs === null || rhs === void 0 ? void 0 : rhs._count) !== null && _rhs$_count !== void 0 ? _rhs$_count : 0) + ((_lhs$_count = lhs === null || lhs === void 0 ? void 0 : lhs._count) !== null && _lhs$_count !== void 0 ? _lhs$_count : 0);
      combined._lhs = lhs;
      combined._rhs = rhs;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = q$1((e, prevValue) => {
        const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
      const useRefElementProps = q$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    function runImmediately(f) {
      f();
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      s(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 6.0.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };


    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRootHost; // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));

      while (!attached && nodeRootHost) {
        var _nodeRootHost2; // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
        //  which means we need to get the host's host and check if that parent host is contained
        //  in (i.e. attached to) the document


        nodeRootHost = getRootNode(nodeRootHost).host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
      }

      return attached;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot; // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check

      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__


        if (displayCheck !== 'legacy-full') {
          return true; // hidden
        } // else, fallback to 'none' mode and consider the node visible

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    function blockingElements() {
      return getDocument$d().$blockingElements;
    }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */


    function useBlockingElement(enabled, getTarget) {
      const stableGetTarget = useStableCallback(getTarget);
      /**
       * Push/pop the element from the blockingElements stack.
       */

      _(() => {
        const target = stableGetTarget();

        if (enabled) {
          // Sometimes blockingElements will fail if, for example,
          // the target element isn't connected to document.body.
          // This is rare, but it's better to fail silently with weird tabbing behavior
          // than to crash the entire application.
          try {
            blockingElements().push(target);
            return () => {
              blockingElements().remove(target);
            };
          } catch (ex) {
            // Well, semi-silently.
            console.error(ex);
          }
        }
      }, [enabled]);
    }
    function getTopElement() {
      return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap(_ref) {
      let {
        trapActive
      } = _ref;
      const handleActiveChange = q$1((trapActive, element) => {
        if (trapActive && element) {
          let rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          let rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: useStableCallback(element => handleActiveChange(trapActive, element))
      });
      const {
        getLastActiveElement
      } = useActiveElement({
        getDocument: useStableCallback(() => {
          var _getElement$ownerDocu, _getElement;

          return (_getElement$ownerDocu = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument) !== null && _getElement$ownerDocu !== void 0 ? _getElement$ownerDocu : window.document;
        })
      }); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      _(() => {
        const element = getElement();

        if (trapActive && element) {
          var _getLastActiveElement;

          const document = getDocument$d(element); // Save the currently focused element
          // to whatever's currently at the top of the stack

          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive]);
      useBlockingElement(trapActive, getElement);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      _(() => {
        handleActiveChange(trapActive, getElement());
      }, [trapActive]);

      const useFocusTrapProps = props => {
        const p1 = useRefElementProps(props);
        const p2 = {
          "aria-modal": trapActive ? "true" : undefined
        };
        return useMergedProps(p1, p2);
      };

      return {
        useFocusTrapProps,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      const firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */

    function useForceUpdate() {
      const [, set] = y(0);
      return A(() => set(i => ++i)).current;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow,
        onElementChange,
        onMount,
        onUnmount
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange,
        onMount,
        onUnmount
      });
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      } = useActiveElement({
        getDocument,
        getWindow,
        onActiveElementChange: q$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = q$1(props => {
        return useRefElementProps(props);
      }, []);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }
    function useChildrenHaveFocus(_ref2) {
      let {
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref2;
      const {
        managedChildren,
        useManagedChild
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const allElementsRef = A(new Set());
      const [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
        console.log(`Changing focus count from ${anyPreviouslyFocused} to ${anyFocused}`);
        console.assert(anyFocused >= 0 && anyFocused <= 1);
        if (anyFocused && !anyPreviouslyFocused) onAnyGainedFocus === null || onAnyGainedFocus === void 0 ? void 0 : onAnyGainedFocus();
        if (!anyFocused && anyPreviouslyFocused) onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
      }));
      const useChildrenHaveFocusChild = q$1(_ref3 => {
        let {
          onElementChange,
          onMount,
          onUnmount,
          getDocument,
          getWindow,
          onActiveElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onWindowFocusedChange,
          managedChild: {
            index,
            flags
          }
        } = _ref3;
        useManagedChild({
          managedChild: {
            index,
            subInfo: {},
            flags
          }
        });
        const {
          useHasFocusProps,
          ...hasFocus
        } = useHasFocus({
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange: q$1((e, prev) => {
            let r = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prev);

            if (e) {
              allElementsRef.current.add(e);
              return () => {
                r === null || r === void 0 ? void 0 : r();
                allElementsRef.current.delete(e);
              };
            }
          }, [onElementChange]),
          onMount,
          onUnmount,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
            if (focused) {
              console.log(`Child ${index} is focused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) + 1);
            } else if (!focused && prev) {
              console.log(`Child ${index} is unfocused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) - 1);
            }

            onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);
          }),
          onWindowFocusedChange
        });
        return {
          useChildrenHaveFocusChildProps: useHasFocusProps,
          ...hasFocus
        };
      }, []);
      return {
        managedChildren,
        useChildrenHaveFocusChild
      };
    }

    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * any element, whether it's a native <BUTTON> or regular <DIV>.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */

    function usePress(_ref) {
      let {
        exclude,
        hasFocus: {
          onFocusedInnerChanged,
          ...hasFocus
        },
        onClickSync
      } = _ref;
      // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element loses focus,
      // this is reset back to 0.
      const [active, setActive, getActive] = useState(0);
      const forceUpdate = useForceUpdate();
      const {
        useHasFocusProps,
        getElement
      } = useHasFocus({ ...hasFocus,
        onFocusedInnerChanged: useStableCallback((f, p) => {
          onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(f, p);

          if (!f) {
            setActive(0);
          }
        })
      }); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      const pseudoActive = active && textSelectedDuringActivationStartTime == null;
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      s(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
        const charactersSelected = nodeSelectedTextLength(getElement()); // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
          forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          try {
            // The default implementation doesn't throw,
            // but we should guard against user implementations that could.
            pulse();
          } finally {
            // Actually call our handler.
            onClickSync(e);
          }
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };
      const onMouseLeave = useStableCallback(() => {
        if (!excludes("click", exclude)) setActive(0);
      });
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return function usePressProps(props) {
        return useMergedProps(props, useHasFocusProps({
          onKeyDown,
          onKeyUp,
          onMouseDown,
          onMouseUp,
          onMouseLeave,
          onClick,
          style: textSelectedDuringActivationStartTime != null ? {
            cursor: "text"
          } : undefined,
          ...{
            "data-pseudo-active": pseudoActive ? "true" : undefined
          }
        }));
      };
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */

    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }

    let pulse = "vibrate" in navigator && navigator.vibrate instanceof Function ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = A(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      s(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = q$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = q$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        linearNavigation: {
          navigateToFirst: ntf,
          navigateToLast: ntl,
          navigateToNext: ntn,
          navigateToPrev: ntp,
          navigationDirection: nd,
          disableArrowKeys: dak,
          disableHomeEndKeys: dhek
        }
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either"; //const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection<ParentOrChildElement>({});

      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        linearNavigation: {},
        useLinearNavigationProps: q$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return; //const info = getLogicalDirectionInfo();

            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsVerticalNavigation = navigationDirection == "vertical" || navigationDirection == "either";
            const allowsHorizontalNavigation = navigationDirection == "horizontal" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  //const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                  const directionAllowed = !disableArrowKeys && allowsVerticalNavigation;

                  if (directionAllowed) {
                    navigateToPrev();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const directionAllowed = !disableArrowKeys && allowsVerticalNavigation;

                  if (directionAllowed) {
                    navigateToNext();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const directionAllowed = !disableArrowKeys && allowsHorizontalNavigation;

                  if (directionAllowed) {
                    navigateToPrev();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const directionAllowed = !disableArrowKeys && allowsHorizontalNavigation;

                  if (directionAllowed) {
                    navigateToNext();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useMergedProps({
            onKeyDown
          }, props);
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        typeaheadNavigation: {
          collator,
          getIndex,
          typeaheadTimeout,
          setIndex,
          noTypeahead
        }
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = A([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      _(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = q$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      s(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
               In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
               It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
               Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
               TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = q$1(_ref4 => {
        let {
          index,
          text
        } = _ref4;
        s(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(parentParameters) {
      var _initialIndex;

      let {
        rovingTabIndex: {
          initialIndex,
          onTabbableRender,
          onTabbableIndexChange
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
          if (oldCount == 0 && newCount > 0) {
              onTabbedInTo?.();
          }
           if (newCount == 0 && (oldCount ?? 0) > 0) {
              onTabbedOutOf?.();
          }
      }), returnZero);*/
      // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => {
        var _initialIndex2;

        return (_initialIndex2 = initialIndex) !== null && _initialIndex2 !== void 0 ? _initialIndex2 : 0;
      }, []));
      const setTabbableIndex = q$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex); //const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
            //if (prevChild != null)
            //    prevChild.subInfo.blurSelf();

            if (nextChild != null && fromUserInteraction) nextChild.subInfo.focusSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const parentReturnType = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: useStableCallback((mounted, unmounted) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(mounted, unmounted);
            reevaluateClosestFit();
          })
        }
      });
      const {
        useManagedChild
      } = parentReturnType;
      const {
        changeIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        initialIndex,
        children: parentReturnType.managedChildren.children,
        closestFit: true,
        key: "tabbable"
      });
      const useRovingTabIndexChild = q$1(childParameters => {
        const {
          subInfo,
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            hidden,
            focusSelf: focusSelfOverride
          }
        } = childParameters;
        s(() => {
          reevaluateClosestFit();
        }, [!!hidden]);
        const fsOverride = useStableGetter(focusSelfOverride);
        const focusSelf = q$1(() => {
          const fs = fsOverride();

          if (fs) {
            fs();
          } else {
            var _element$focus;

            const element = getElement();
            if (element) (_element$focus = element.focus) === null || _element$focus === void 0 ? void 0 : _element$focus.call(element);
          }
        }, []);
        /*const blurSelf = useCallback(() => {
            const bs = bsOverride();
            if (bs) {
                bs();
            }
            else {
                const element = getElement() as (Element & Partial<HTMLElement>);
                if (element)
                    element.blur?.();
            }
        }, []);*/

        const onFocusedInnerChanged = useStableCallback((focused, _prevFocused) => {
          if (focused) {
            setTabbableIndex(index, false);
          }
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged,
          getDocument: q$1(() => {
            var _getElement$ownerDocu, _getElement;

            return (_getElement$ownerDocu = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument) !== null && _getElement$ownerDocu !== void 0 ? _getElement$ownerDocu : window.document;
          }, [])
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = A({
          get: getTabbable,
          set: setTabbable,
          isValid: useStableCallback(() => !hidden)
        });

        useManagedChild({
          managedChild: {
            index,
            flags: { ...flags,
              tabbable: tabbableFlags.current
            },
            subInfo: {
              //blurSelf,
              focusSelf,
              getElement,
              hidden: !!hidden,
              subInfo
            }
          }
        });

        s(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            getElement,
            tabbable,
            getTabbable
          }
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = q$1(() => {
        var _parentReturnType$man, _parentReturnType$man2, _parentReturnType$man3;

        console.log(`useRovingTabIndex.focusSelf`);
        const index = getTabbableIndex();
        if (index != null) (_parentReturnType$man = parentReturnType.managedChildren.children.getAt(index)) === null || _parentReturnType$man === void 0 ? void 0 : (_parentReturnType$man2 = (_parentReturnType$man3 = _parentReturnType$man.subInfo).focusSelf) === null || _parentReturnType$man2 === void 0 ? void 0 : _parentReturnType$man2.call(_parentReturnType$man3);else setTabbableIndex(null, true);
      }, []);
      return {
        useRovingTabIndexChild,
        managedChildren: {
          children: parentReturnType.managedChildren.children
        },
        rovingTabIndex: {
          setTabbableIndex,
          getTabbableIndex,
          focusSelf
        }
      };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */

    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */

    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;
      size = size === undefined ? length : size;

      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];
        array[rand] = array[index];
        array[index] = value;
      }

      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    /** `Object#toString` result references. */

    var argsTag$1 = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */

    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Built-in value references. */

    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */

    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */

    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Built-in value references. */

    var Buffer = moduleExports$1 ? root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */

    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */

    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    /* Node.js helper references. */

    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */

    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */

    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    /** `Object#toString` result references. */

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */

    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */

    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useRearrangeableChildren(_ref) {
      let {
        rearrangeableChildren: {
          getIndex
        }
      } = _ref;
      // These are used to keep track of a mapping between unsorted index <---> sorted index.
      // These are needed for navigation with the arrow keys.
      const mangleMap = A(new Map());
      const demangleMap = A(new Map());
      const indexMangler = q$1(n => {
        var _mangleMap$current$ge;

        return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
      }, []);
      const indexDemangler = q$1(n => {
        var _demangleMap$current$;

        return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
      }, []); // The sort function needs to be able to update whoever has all the sortable children.
      // Because that might not be the consumer of *this* hook directly (e.g. a table uses
      // this hook, but it's tbody that actually needs updating), we need to remotely
      // get and set a forceUpdate function.
      //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);

      const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
      const rearrange = q$1(sortedRows => {
        var _getForceUpdate;

        // Update our sorted <--> unsorted indices map 
        // and rerender the whole table, basically
        for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
          const indexAsUnsorted = sortedRows[indexAsSorted].index;
          mangleMap.current.set(indexAsUnsorted, indexAsSorted);
          demangleMap.current.set(indexAsSorted, indexAsUnsorted);
        }

        (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
      }, []);
      const useRearrangeableProps = q$1(_ref2 => {
        let {
          children,
          ...props
        } = _ref2;
        const forceUpdate = useForceUpdate();
        _(() => {
          setForceUpdate(_prev => forceUpdate);
        }, [forceUpdate]);
        return useMergedProps({
          children: children.slice().map(child => ({
            child,
            mangledIndex: indexMangler(getIndex(child.props)),
            demangledIndex: getIndex(child.props)
          })).sort((lhs, rhs) => {
            return lhs.mangledIndex - rhs.mangledIndex;
          }).map(_ref3 => {
            let {
              child,
              mangledIndex,
              demangledIndex
            } = _ref3;
            return h$1(child.type, { ...child.props,
              key: demangledIndex,
              "data-mangled-index": mangledIndex,
              "data-unmangled-index": demangledIndex
            });
          })
        }, props);
      }, []);
      return {
        useRearrangeableProps,
        rearrangeableChildren: {
          indexMangler,
          indexDemangler,
          mangleMap,
          demangleMap,
          rearrange
        }
      };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useSortableChildren(_ref4) {
      let {
        rearrangeableChildren: {
          getIndex
        },
        sortableChildren: {
          compare: userCompare,
          getValue
        }
      } = _ref4;
      const compare = userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare;
      const {
        useRearrangeableProps: useSortableProps,
        ...rearrangeableChildrenReturnType
      } = useRearrangeableChildren({
        rearrangeableChildren: {
          getIndex
        }
      });
      const {
        rearrangeableChildren: {
          rearrange
        }
      } = rearrangeableChildrenReturnType; // The actual sort function.

      const sort = q$1(function (managedRows, direction) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
          const lhsValue = getValue(lhsRow, ...args);
          const rhsValue = getValue(rhsRow, ...args);
          const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);

          if (direction[0] == "d") return -result;
          return result;
        });
        return rearrange(sortedRows);
      }, [
        /* Must remain stable */
      ]);
      const shuffle$1 = q$1(managedRows => {
        const shuffledRows = shuffle(managedRows.arraySlice());
        return rearrange(shuffledRows);
      }, [
        /* Must remain stable */
      ]);
      return {
        useSortableProps,
        sortableChildren: {
          sort,
          shuffle: shuffle$1
        },
        rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
      };
    }

    function defaultCompare(lhs, rhs) {
      return compare1(lhs, rhs);

      function compare3(lhs, rhs) {
        // Coerce strings to numbers if they seem to stay the same when serialized
        if (`${+lhs}` === lhs) lhs = +lhs;
        if (`${+rhs}` === rhs) rhs = +rhs; // At this point, if either argument is a string, turn the other one into one too

        if (typeof lhs === "string") rhs = `${rhs}`;
        if (typeof rhs === "string") lhs = `${lhs}`;
        console.assert(typeof lhs === typeof rhs);
        if (typeof lhs === "string") return lhs.localeCompare(rhs);
        if (typeof lhs === "number") return +lhs - +rhs;
        return 0;
      }

      function compare2(lhs, rhs) {
        if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
        if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
        return compare3(lhs, rhs);
      }

      function compare1(lhs, rhs) {
        if (lhs == null && rhs == null) {
          // They're both null
          return 0;
        } else if (lhs == null || rhs == null) {
          // One of the two is null -- easy case
          return lhs != null ? 1 : -1;
        }

        return compare2(lhs, rhs);
      }
    }

    function identity$2(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler;

      let {
        managedChildren: {
          onChildrenMountChange,
          ...mc
        },
        rovingTabIndex,
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity$2;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity$2;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const parentReturnType = useRovingTabIndex({
        managedChildren: { ...mc,
          onChildrenMountChange: q$1((m, u) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }, [])
        },
        rovingTabIndex
      });
      const {
        useRovingTabIndexChild,
        managedChildren: {
          children
        },
        rovingTabIndex: {
          getTabbableIndex,
          setTabbableIndex
        }
      } = parentReturnType;
      const navigateToIndex = q$1((i, fromUserInteraction) => {
        if (i != null) {
          var _indexMangler2, _indexDemangler2;

          const nextIndex = tryNavigateToIndex({
            children: children,
            default: 0,
            target: i,
            searchDirection: 1,
            indexMangler: (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity$2,
            indexDemangler: (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity$2
          });
          setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
        } else {
          setTabbableIndex(null, fromUserInteraction);
        }
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      } = useTypeaheadNavigation({
        typeaheadNavigation: {
          getIndex: getTabbableIndex,
          setIndex: q$1(index => {
            setTabbableIndex(index, true);
          }, []),
          ...typeaheadNavigation
        }
      });
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        linearNavigation: {
          navigateToPrev: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler3, _indexDemangler3;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) - 1),
                searchDirection: -1,
                indexMangler: (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity$2,
                indexDemangler: (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity$2
              });
            }, true);
          }, []),
          navigateToNext: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler4, _indexDemangler4;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) + 1),
                searchDirection: 1,
                indexMangler: (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity$2,
                indexDemangler: (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity$2
              });
            }, true);
          }, []),
          navigateToFirst: q$1(() => {
            navigateToIndex(indexDemangler(0), true);
          }, []),
          navigateToLast: q$1(() => {
            navigateToIndex(indexDemangler(children.getHighestIndex()), true);
          }, []),
          ...linearNavigation
        }
      });
      const useListNavigationProps = q$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = q$1(_ref2 => {
        let {
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          },
          listNavigation: {
            text
          },
          subInfo
        } = _ref2;

        useTypeaheadNavigationChild({
          text,
          index
        });

        const getIndex = useStableGetter(index);
        s(() => {
          return () => {
            if (getTabbableIndex() == getIndex()) {
              navigateToIndex(index, false);
            }
          };
        }, []);
        const {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        } = useRovingTabIndexChild({
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden: !!hidden
          },
          subInfo: {
            text,
            subInfo
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        listNavigation: {
          navigateToIndex
        },
        managedChildren: parentReturnType.managedChildren,
        rovingTabIndex: parentReturnType.rovingTabIndex,
        linearNavigation: {},
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
        /*listNavigation: { navigateToIndex },
        rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
        linearNavigation: {},
        typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/

      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      let {
        singleSelection: {
          selectedIndex,
          selectionMode,
          onSelectedIndexChange
        },
        listNavigation,
        managedChildren,
        rovingTabIndex: { ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation,
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      } = _ref4;
      const parentReturnType = useListNavigation({
        listNavigation,
        managedChildren,
        rovingTabIndex: {
          initialIndex: selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : undefined,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      });
      const {
        useChildrenHaveFocusChild
      } = useChildrenHaveFocus({
        childrenHaveFocus: {
          onAllLostFocus: useStableCallback(() => {
            onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
            if (selectedIndex != null) setTabbableIndex(selectedIndex, false);
          }),
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const stableOnChange = useStableCallback(onSelectedIndexChange);
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = parentReturnType;
      const {
        managedChildren: {
          children
        },
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listRest;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex //reevaluateClosestFit

      } = useChildrenFlag({
        children: children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      _(() => {
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        useListNavigationSingleSelectionChild: q$1(_ref5 => {
          let {
            managedChild: {
              index,
              flags
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            hasFocus: {
              onFocusedInnerChanged,
              ...hasFocus
            },
            subInfo
          } = _ref5;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
          const selectedRef = A({
            get: getIsSelected,
            set: setIsSelected,
            isValid: useStableCallback(() => !rti.hidden)
          });
          const {
            useChildrenHaveFocusChildProps,
            getElement
          } = useChildrenHaveFocusChild({
            onFocusedInnerChanged: useStableCallback((focused, prev) => {
              onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);

              if (selectionMode == 'focus' && focused) {
                stableOnChange({
                  target: getElement(),
                  currentTarget: getElement()
                }, getIndex());
              }
            }),
            ...hasFocus,
            managedChild: {
              index
            }
          });
          const {
            rovingTabIndex: rti_ret,
            useListNavigationChildProps
          } = useListNavigationChild({
            managedChild: {
              index,
              flags: {
                selected: selectedRef.current,
                ...flags
              }
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          });
          const getIndex = useStableGetter(index);
          const usePressProps = usePress({
            onClickSync: e => {
              stableOnChange(e, getIndex());
            },
            exclude: {},
            hasFocus
          });
          return {
            useListNavigationSingleSelectionChildProps: props => usePressProps(useChildrenHaveFocusChildProps(useListNavigationChildProps(props))),
            rovingTabIndex: rti_ret,
            singleSelection: {
              selected: isSelected,
              getSelected: getIsSelected
            }
          };
        }, [selectionMode]),
        useListNavigationSingleSelectionProps: q$1(function () {
          return useListNavigationProps(...arguments);
        }, []),
        ...listRest,
        singleSelection: {}
      };
    }
    function tryNavigateToIndex(_ref8) {
      let {
        children,
        searchDirection,
        indexDemangler,
        indexMangler,
        target
      } = _ref8;
      const upper = children.getHighestIndex();
      const lower = 0;

      if (searchDirection === -1) {
        while (target >= lower && children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.subInfo.hidden)) {
          var _children$getAt;

          target = indexDemangler(indexMangler(target) - 1);
        }

        return target < lower ? indexDemangler(lower) : target;
      } else if (searchDirection === 1) {
        while (target <= upper && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.subInfo.hidden)) {
          var _children$getAt2;

          target = indexDemangler(indexMangler(target) + 1);
        }

        return target > upper ? indexDemangler(upper) : target;
      } else {
        return lower;
      }
    }

    function useGridNavigation(_ref) {
      var _rti$initialIndex;

      let {
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: ln,
        typeaheadNavigation: tn,
        gridNavigation: {
          rowIndexDemangler,
          rowIndexMangler
        }
      } = _ref;
      const [currentColumn, setCurrentColumn, getCurrentColumn] = useState((_rti$initialIndex = rti.initialIndex) !== null && _rti$initialIndex !== void 0 ? _rti$initialIndex : 0);
      const {
        useListNavigationChild: useListNavigationChildAsGridRow,
        useListNavigationProps: useListNavigationPropsAsGridParent,
        ...parentLsReturnType
      } = useListNavigation({
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: {
          indexDemangler: rowIndexDemangler,
          indexMangler: rowIndexMangler,
          ...ls
        },
        linearNavigation: {
          navigationDirection: "vertical",
          ...ln
        },
        typeaheadNavigation: tn
      });
      const useGridNavigationRow = q$1(_ref2 => {
        let {
          asChildRowOfSection: asChild,
          asParentRowOfCells: asParent
        } = _ref2;
        // Override the focusSelf that rovingTabIndex does.
        // Instead of focusing the entire row, we ask the cell that corresponds
        // to our current column to focus itself.
        const focusSelf = useStableCallback(() => {
          const c2 = getCurrentColumn();

          if (asChild.rovingTabIndex.focusSelf) {
            asChild.rovingTabIndex.focusSelf();
          } else {
            navigateToIndex(c2 !== null && c2 !== void 0 ? c2 : 0, true);
          }
        });
        const rowLsChildReturnType = useListNavigationChildAsGridRow({
          managedChild: asChild.managedChild,
          listNavigation: { ...asChild.listNavigation
          },
          rovingTabIndex: { ...asChild.rovingTabIndex,
            focusSelf
          },
          subInfo: asChild.subInfo
        });
        const {
          rovingTabIndex: {
            tabbable
          },
          useListNavigationChildProps
        } = rowLsChildReturnType;
        s(() => {
          if (!tabbable) {
            navigateToIndex(null, false);
          }
        }, [tabbable]);
        const rowLsReturnType = useListNavigation({
          managedChildren: { ...asParent.managedChildren
          },
          rovingTabIndex: { ...asParent.rovingTabIndex
          },
          linearNavigation: { ...asParent.linearNavigation,
            navigationDirection: "horizontal"
          },
          typeaheadNavigation: { ...asParent.typeaheadNavigation,
            noTypeahead: true
          },
          listNavigation: { ...asParent.listNavigation
          }
        });
        const {
          rovingTabIndex: {
            setTabbableIndex
          },
          useListNavigationChild: useGridNavigationColumn2,
          useListNavigationProps: useGridNavigationColumnProps,
          listNavigation: {
            navigateToIndex
          }
        } = rowLsReturnType; //const rowHidden = !!asChild.rovingTabIndex.hidden;

        const useGridNavigationCell = q$1(_ref3 => {
          let {
            subInfo,
            hasFocus: {
              onLastFocusedInnerChanged,
              ...hasFocus
            },
            managedChild,
            listNavigation: ls,
            rovingTabIndex: {
              focusSelf: fs,
              ...rti
            }
          } = _ref3;
          //rti.hidden || rowHidden;
          const focusSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem, _rti_cell_ret$getElem2;

            setCurrentColumn(managedChild.index);
            setTabbableIndex(managedChild.index, false);
            if (fs) fs();else (_rti_cell_ret$getElem = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem === void 0 ? void 0 : (_rti_cell_ret$getElem2 = _rti_cell_ret$getElem.focus) === null || _rti_cell_ret$getElem2 === void 0 ? void 0 : _rti_cell_ret$getElem2.call(_rti_cell_ret$getElem);
          });
          /*const blurSelf = useStableCallback(() => {
              if (bs)
                  bs();
              else
                  (rti_cell_ret.getElement() as Element & Partial<HTMLElement>)?.blur?.();
          });*/

          const {
            useListNavigationChildProps,
            rovingTabIndex: rti_cell_ret
          } = useGridNavigationColumn2({
            managedChild: managedChild,
            listNavigation: { ...ls
            },
            rovingTabIndex: {
              focusSelf,
              ...rti
            },
            subInfo
          });
          const {
            useHasFocusProps
          } = useHasFocus({
            onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
              onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);

              if (focused) {
                setCurrentColumn(managedChild.index);
                setTabbableIndex(managedChild.index, false);
              }
            }),
            ...hasFocus
          });
          const ret = {
            gridNavigation: {
              getCurrentColumn
            },
            rovingTabIndex: rti_cell_ret,
            useGridNavigationCellProps: function (props) {
              return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props)));
            }
          };
          return ret;
        }, []);
        const ret = {
          asParentOfCells: {
            linearNavigation: rowLsReturnType.linearNavigation,
            listNavigation: rowLsReturnType.listNavigation,
            managedChildren: rowLsReturnType.managedChildren,
            rovingTabIndex: rowLsReturnType.rovingTabIndex,
            typeaheadNavigation: rowLsReturnType.typeaheadNavigation
          },
          asChildRow: rowLsChildReturnType,
          useGridNavigationCell,
          useGridNavigationRowProps: function (props) {
            const ret = useListNavigationChildProps(props);
            ret.tabIndex = -1;
            return ret;
          }
        };
        return ret;
      }, []);
      return {
        gridNavigation: {
          getCurrentColumn,
          currentColumn
        },
        linearNavigation: parentLsReturnType.linearNavigation,
        listNavigation: parentLsReturnType.listNavigation,
        rovingTabIndex: parentLsReturnType.rovingTabIndex,
        typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
        managedChildren: parentLsReturnType.managedChildren,
        useGridNavigationRow,
        useGridNavigationProps: useListNavigationPropsAsGridParent
      };
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        randomId: {
          prefix
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = A(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        ...managedChildrenReturnType
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const {
        managedChildren: {
          children
        }
      } = managedChildrenReturnType;
      const useRandomIdSourceElement = q$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        s(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").subInfo.setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          managedChild: {
            index: "source",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdSourceElementProps = q$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = q$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          managedChild: {
            index: "referencer",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdReferencerElementProps = q$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        randomId: {
          usedId,
          getUsedId
        },
        ...managedChildrenReturnType,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    function useButton(_ref) {
      let {
        button: {
          tagButton,
          disabled,
          onPress,
          pressed
        },
        hasFocus
      } = _ref;
      debugLog("useButton");

      function useButtonProps(_ref2) {
        let {
          "aria-pressed": ariaPressed,
          tabIndex,
          role,
          ...p
        } = _ref2;
        const usePressProps = usePress({
          onClickSync: e => {
            var _ref3;

            return (_ref3 = disabled ? null : onPress) === null || _ref3 === void 0 ? void 0 : _ref3(enhanceEvent(e, {
              pressed: pressed == null ? null : !pressed
            }));
          },
          exclude: undefined,
          hasFocus
        });
        const props = usePressProps(p);
        const baseProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };
        const buttonProps = { ...baseProps,
          disabled: disabled && disabled != "soft" ? true : false,
          "aria-disabled": disabled === 'soft' ? 'true' : undefined
        };
        const divProps = { ...baseProps,
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled === "hard" ? -1 : 0,
          role: role !== null && role !== void 0 ? role : "button",
          "aria-disabled": disabled ? "true" : undefined
        };

        switch (tagButton) {
          case "button":
            return useMergedProps(buttonProps, props);

          default:
            return useMergedProps(divProps, props);
        }
      }

      return {
        useButtonProps
      };
    }

    //export interface UseAccordionSectionHeaderReturnType<E extends Element> { useAccordionSectionHeaderProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }
    //export type UseAccordionSectionBody<E extends Element> = () => UseAccordionSectionBodyReturnType<E>;
    //export interface UseAccordionSectionBodyReturnType<E extends Element> { useAccordionSectionBodyProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }

    function useAccordion(_ref) {
      let {
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      debugLog("useAccordian");
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const mcReturnType = useManagedChildren({
        managedChildren: {
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc2();
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }),
          onAfterChildLayoutEffect
        }
      });
      const {
        useManagedChild,
        managedChildren: {
          children
        }
      } = mcReturnType;
      const navigateToFirst = q$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = q$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const linearReturnType = useLinearNavigation({
        linearNavigation: {
          navigateToFirst,
          navigateToLast,
          navigateToNext,
          navigateToPrev,
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection: navigationDirection !== null && navigationDirection !== void 0 ? navigationDirection : "vertical" // TODO: Make this relative to the page's logical direction

        }
      });
      const {
        useLinearNavigationProps
      } = linearReturnType;
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: _getCurrentExpandedIndex
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: _getTabbedIndex,
        reevaluateClosestFit: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: true,
        onIndexChange: q$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focus();
          }
        }, [])
      });
      const useAccordionSection = q$1(_ref2 => {
        var _ref3;

        let {
          button: {
            disabled,
            tagButton
          },
          accordionSection: {
            open: openFromUser
          },
          managedChildren: {
            index
          },
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useAccordianSection");
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId,
          randomId: {
            usedId: bodyId,
            getUsedId: getBodyId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-body-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId,
          randomId: {
            usedId: headerId,
            getUsedId: getHeaderId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-header-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index);
        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = q$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = A({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              setCurrentFocusedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = A({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChild({
          managedChild: {
            index: index,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            },
            subInfo: {
              focus,
              getOpenFromParent,
              setOpenFromParent
            } // info: { index, setOpenFromParent, getOpenFromParent, focus, flags: { open: openRef.current, tabbed: tabbedRef.current } }

          }
        });

        function useAccordionSectionHeaderProps(_ref4) {
          var _ref5;

          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          //const onFocus = () => { changeTabbedIndex(index); }
          const onPress = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
          };

          props.tabIndex = 0;
          const {
            useButtonProps
          } = useButton({
            button: {
              tagButton,
              disabled,
              onPress
            },
            hasFocus: { ...hasFocus,
              onFocusedInnerChanged: useStableCallback((focused, prev) => {
                onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
                if (focused) changeTabbedIndex(index);
              })
            }
          });
          const retB = useButtonProps(props); //const ret3: h.JSX.HTMLAttributes<HeaderElement>
          //    = useMergedProps<HeaderElement>(retD, { onFocus });

          return useLinearNavigationProps(useHeaderAsSourceIdProps(useHeaderAsReferencerIdProps({
            "aria-expanded": ((_ref5 = ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open) !== null && _ref5 !== void 0 ? _ref5 : false).toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          })));
        }

        function useAccordionSectionBodyProps(_ref6) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref6;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          accordionSection: {
            expanded: open,
            focused: getCurrentFocusedIndex() == index,
            bodyId,
            headerId,
            getBodyId,
            getHeaderId
          },
          useAccordionSectionHeaderProps,
          useAccordionSectionBodyProps
        };
      }, []);
      return {
        managedChildren: mcReturnType.managedChildren,
        accordion: {
          changeExpandedIndex
        },
        useAccordionSection
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel(_ref) {
      let {
        label: {
          prefixInput,
          prefixLabel,
          tagInput,
          tagLabel
        }
      } = _ref;
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        randomId: {
          usedId: labelId,
          getUsedId: getLabelId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixLabel
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        randomId: {
          usedId: inputId,
          getUsedId: getInputId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixInput
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      const isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = q$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            const propsWithoutFor = useLabelAsSourceIdProps(props);
            const propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = q$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref2 => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref2;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel && !props["aria-label"]) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, [isSyntheticLabel]);
      return {
        useLabelInput,
        useLabelLabel,
        label: {
          labelId,
          inputId,
          getLabelId,
          getInputId
        }
      };
    }

    const handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     *
     * If it's a toggleable click-thing with a label (that can also be clicked), then it's a checkbox-like.
     * @param param0
     * @returns
     */


    function useCheckboxLike(_ref3) {
      let {
        checkboxLike: {
          checked,
          disabled,
          labelPosition,
          role,
          onCheckedChange
        },
        label: {
          tagInput,
          tagLabel
        },
        hasFocusInput,
        hasFocusLabel
      } = _ref3;
      const stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(e);
      });
      const {
        useLabelInput: useILInput,
        useLabelLabel: useILLabel,
        label
      } = useLabel({
        label: {
          prefixLabel: "aria-checkbox-label-",
          prefixInput: "aria-checkbox-input-",
          tagInput: tagInput,
          tagLabel: tagLabel
        }
      });
      const {
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      const {
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      const useCheckboxLikeInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useLabelInputProps: useILInputProps
        } = useILInput();
        const {
          useRefElementProps,
          getElement
        } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        s(() => {
          const element = getElement();

          if (element && tag == "input") {
            element.indeterminate = checked === "mixed";
            element.checked = checked === true;
          }
        }, [tag, checked]);
        return {
          getInputElement: getElement,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref4) {
          let { ...p0
          } = _ref4;
          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          const usePressProps = usePress({
            onClickSync: disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput,
            exclude: undefined,
            hasFocus: hasFocusInput
          });
          let props = usePressProps(p0);
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;
            props.role = "presentation";
            props["aria-hidden"] = "true";

            props.onFocus = _ => {
              var _getLabelElement;

              return (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : _getLabelElement.focus();
            };
          } else {
            if (tag === "input") {
              props.checked = checked === true;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked === "mixed" ? "mixed" : checked === true ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useInputRefElementProps(useMergedProps(p0, props));
        }
      }, [useILInput, role, labelPosition, disabled, checked, tagInput]);
      const useCheckboxLikeLabelElement = q$1(function useCheckboxLabelElement() {
        const tag = tagLabel;
        const {
          useLabelLabelProps: useILLabelProps
        } = useILLabel();

        function useCheckboxLikeLabelElementProps(_ref5) {
          let { ...p0
          } = _ref5;
          const usePressProps = usePress({
            onClickSync: disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput,
            exclude: undefined,
            hasFocus: hasFocusLabel
          });
          const newProps = usePressProps(p0);

          if (labelPosition == "wrapping") {
            if (newProps.tabIndex == null) newProps.tabIndex = 0;
            if (newProps.role == null) newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useILLabelProps(useLabelRefElementProps(newProps));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition, tagLabel]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        checkboxLike: {
          getLabelElement,
          getInputElement
        },
        label
      };
    }

    function useCheckbox(_ref) {
      let {
        checkboxLike,
        label,
        checkbox,
        hasFocusInput,
        hasFocusLabel
      } = _ref;
      debugLog("useCheckbox");
      const {
        disabled,
        labelPosition,
        checked
      } = checkboxLike;
      const {
        tagInput,
        tagLabel
      } = label;
      const {
        onCheckedChange: onInput
      } = checkbox;

      const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      const {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        ...checkboxLikeRest
      } = useCheckboxLike({
        hasFocusInput,
        hasFocusLabel,
        checkboxLike: {
          role: "checkbox",
          checked,
          onCheckedChange: onInputEnhanced,
          disabled,
          labelPosition
        },
        label
      });
      const useCheckboxInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement();
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref2) {
          var _props$checked;

          let { ...p0
          } = _ref2;
          const props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [useCheckboxLikeInputElement, checked, labelPosition, disabled, tagInput]);
      const useCheckboxLabelElement = q$1(function useCheckboxLabelElement() {
        const {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement();

        function useCheckboxLabelElementProps(_ref3) {
          let { ...props
          } = _ref3;
          return useCheckboxLikeLabelElementProps(props);
        }

        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition, tagLabel]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxLikeRest
      };
    }

    /**
     *
     *
     * @param param0
     * @returns
     */

    function useCheckboxGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useCheckboxGroup"); //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));

      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listReturnType
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType; //const [uncheckedCount, setUnheckedCount] = useState(0);
      // Keep track of all child IDs, and any time any of them change, 
      // generate a new string with all of them concatenated together
      // (but only once per render);

      const allIds = A(new Set());
      const [ariaControls, setControls] = useState("");
      const [updateIndex, setIdUpdateIndex] = useState(0);
      const [checkedCount, setCheckedCount] = useState(0);
      const checkedIndices = A(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

      const getSelfIsCheckedUnstable = q$1(() => {
        const percentage = checkedCount / (children.getHighestIndex() + 1);
        return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
      }, [checkedCount]);
      const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable);
      const [setParentCheckboxChecked, setSetParentCheckboxChecked] = useState(null);
      s(() => {
        setParentCheckboxChecked === null || setParentCheckboxChecked === void 0 ? void 0 : setParentCheckboxChecked(checkedCount == 0 ? false : checkedCount == children.getHighestIndex() + 1 ? true : "mixed");
      }, [setParentCheckboxChecked, checkedCount]); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
      // Otherwise, it's null when the last input was from a child checkbox. 
      //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);

      const useCheckboxGroupParentInput = q$1(_ref2 => {
        let {
          checkbox,
          checkboxLike,
          label,
          hasFocusLabel,
          hasFocusInput
        } = _ref2;
        debugLog("useCheckboxGroupParent");
        const {
          disabled,
          labelPosition,
          ..._void2
        } = checkboxLike;
        const {
          tagInput,
          tagLabel,
          ..._void3
        } = label;
        const [checked, setChecked] = useState(false);
        s(() => {
          setSetParentCheckboxChecked(() => setChecked);
        }, []);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement
        } = useCheckbox({
          checkboxLike: {
            labelPosition,
            checked,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          checkbox: {
            onCheckedChange: onCheckboxGroupParentInput2
          },
          hasFocusInput,
          hasFocusLabel
        });
        const {
          useCheckboxInputElementProps
        } = useCheckboxInputElement();
        const {
          useCheckboxLabelElementProps
        } = useCheckboxLabelElement();
        return {
          useCheckboxGroupParentInputProps: function useCheckboxGroupParentInputProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls,
              onInput: tagInput == "input" ? e => e.preventDefault() : undefined
            }), props);
            return useCheckboxInputElementProps(labelPosition == "separate" ? ret : props);
          },
          useCheckboxGroupParentLabelProps: function useCheckboxGroupParentLabelProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls
            }), props);
            return useCheckboxLabelElementProps(labelPosition == "wrapping" ? ret : props);
          }
        };
      }, [ariaControls]);
      const onCheckboxGroupParentInput2 = q$1(e => {
        e.preventDefault();
        const selfIsChecked = getSelfIsCheckedStable();
        const nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        let willChangeAny = false;
        children.forEach(child => willChangeAny || (willChangeAny = child.subInfo.subInfo.subInfo.checked != child.subInfo.subInfo.subInfo.getLastUserChecked()));
        children.forEach(child => {
          var _child$subInfo$subInf, _child$subInfo$subInf2;

          let checked;

          if (nextChecked == "mixed") {
            if (willChangeAny) checked = child.subInfo.subInfo.subInfo.getLastUserChecked();else checked = true;
          } else {
            checked = nextChecked;
          }

          (_child$subInfo$subInf = (_child$subInfo$subInf2 = child.subInfo.subInfo.subInfo).onCheckedChange) === null || _child$subInfo$subInf === void 0 ? void 0 : _child$subInfo$subInf.call(_child$subInfo$subInf2, enhanceEvent(e, {
            checked
          }));
        });
        /*if (selfIsChecked === true || (selfIsChecked === false && savedCheckedValues.current == null)) {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: false }));
        }
        else if (selfIsChecked === "mixed") {
             savedCheckedValues.current = new Map();
            children.forEach(child => {
                savedCheckedValues.current!.set(child.index, child.getLastUserChecked());
            })
             return onUpdateChildren(enhanceEvent(e, { childrenChecked: true }));
        }
        else {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: savedCheckedValues.current ?? true }));
        }*/
      }, []);
      const notifyChecked = q$1((index, checked) => {
        if (checked === true) {
          if (!checkedIndices.current.has(index)) {
            setCheckedCount(c => c + 1);
            checkedIndices.current.add(index);
          }
        } else {
          if (checkedIndices.current.has(index)) {
            setCheckedCount(c => c - 1);
            checkedIndices.current.delete(index);
          }
        }
      }, []);
      /*useEffect(() => {
          let percentage = checkedCount / managedChildren.length;
          setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
      }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

      /*const useCheckboxGroupParentProps = useCallback((props: h.JSX.HTMLAttributes<InputElement>) => {
          return
      }, [ariaControls]);*/

      s(() => {
        setControls(Array.from(allIds.current).join(" "));
      }, [updateIndex]);
      const useCheckboxGroupChild = q$1(function (_ref3) {
        let {
          asCheckbox,
          asCheckboxGroupChild
        } = _ref3;
        debugLog("useCheckboxGroupChild", asCheckboxGroupChild.managedChild.index, asCheckbox.checkboxLike.checked);
        const {
          checkbox: {
            onCheckedChange
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          },
          hasFocusInput,
          hasFocusLabel
        } = asCheckbox;
        const {
          managedChild: {
            index
          }
        } = asCheckboxGroupChild; //labelPosition ??= "separate";

        const [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse$1);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement,
          ...checkboxReturnType
        } = useCheckbox({
          checkbox: {
            onCheckedChange: useStableCallback(e => {
              setLastUserChecked(e[EventDetail].checked);
              onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(e);
            })
          },
          checkboxLike: {
            checked,
            labelPosition,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          hasFocusInput,
          hasFocusLabel
        });
        const {
          label: {
            inputId,
            labelId
          }
        } = checkboxReturnType; //const getChecked = useStableGetter(checked);

        const controlsId = labelPosition == "separate" ? inputId : labelId;
        s(() => {
          allIds.current.add(controlsId);
          setIdUpdateIndex(i => ++i);
          return () => {
            allIds.current.delete(controlsId);
            setIdUpdateIndex(i => ++i);
          };
        }, [controlsId]);
        s(() => {
          notifyChecked(index, checked);
        }, [index, checked]);
        const {
          useListNavigationChildProps,
          ...listNavigationReturnType
        } = useListNavigationChild({
          subInfo: {
            getLastUserChecked,
            onCheckedChange,
            checked
          },
          listNavigation: { ...asCheckboxGroupChild.listNavigation
          },
          managedChild: asCheckboxGroupChild.managedChild,
          rovingTabIndex: asCheckboxGroupChild.rovingTabIndex
        });
        return {
          checkboxLike: checkboxReturnType.checkboxLike,
          label: checkboxReturnType.label,
          rovingTabIndex: listNavigationReturnType.rovingTabIndex,
          useCheckboxGroupChildInputProps: props => {
            const {
              useCheckboxInputElementProps
            } = useCheckboxInputElement();
            const ret = useCheckboxInputElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "separate" ? ret2 : ret;
          },
          useCheckboxGroupChildLabelProps: props => {
            const {
              useCheckboxLabelElementProps
            } = useCheckboxLabelElement();
            const ret = useCheckboxLabelElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "wrapping" ? ret2 : ret;
          }
        };
      }, []);
      return {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable(),
          parentPercentChecked: checkedCount / (children.getHighestIndex() + 1)
        }
      };
    }

    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss(_ref) {
      let {
        softDismiss: {
          onClose,
          getElements,
          open
        },
        activeElement: {
          onLastActiveElementChange,
          ...activeElement
        }
      } = _ref;
      const stableOnClose = useStableCallback(onClose);
      const stableGetElements = useStableCallback(getElements);
      const getOpen = useStableGetter(open);
      const {
        getDocument
      } = activeElement;
      const onBackdropClick = q$1(function onBackdropClick(e) {
        if (!getOpen()) return;
        const document = getDocument(); // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.

        if (e.target == (document === null || document === void 0 ? void 0 : document.documentElement)) {
          stableOnClose("backdrop");
        }

        let elements = stableGetElements();

        if (elements && e.target instanceof Element) {
          if (!Array.isArray(elements)) elements = [elements];
          let foundInsideClick = false;

          for (const element of elements) {
            if (element && element.contains(e.target)) {
              foundInsideClick = true;
              break;
            }
          }

          if (!foundInsideClick) {
            onClose("backdrop");
          }
        }
      }, []);
      useActiveElement({ ...activeElement,
        onLastActiveElementChange: q$1((newElement, prev) => {
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(newElement, prev);
          let validFocusableElements = stableGetElements();

          if (validFocusableElements) {
            if (!Array.isArray(validFocusableElements)) validFocusableElements = [validFocusableElements];

            for (const focusable of validFocusableElements) {
              if (focusable !== null && focusable !== void 0 && focusable.contains(newElement)) return;
            }
          }

          onClose("lost-focus");
        }, [])
      });
      const {
        useRefElementProps
      } = useRefElement({
        onMount: q$1(() => {
          debugger;
        }, []),
        onUnmount: q$1(() => {
          debugger;
        }, []),
        onElementChange: q$1(e => {
          debugger;

          if (e) {
            const document = e.ownerDocument;
            const window = document === null || document === void 0 ? void 0 : document.defaultView; // Since everything else is inert, we listen for captured clicks on the window
            // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
            // Note: We need a *separate* touch event on mobile Safari, because
            // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
            // but touch events work as expected.

            const mouseDown = e => {
              if (getOpen()) onBackdropClick(e);
            };

            const touchStart = e => {
              if (getOpen()) onBackdropClick(e);
            };

            const keyDown = e => {
              if (e.key === "Escape") {
                stableOnClose("escape");
              }
            };

            window === null || window === void 0 ? void 0 : window.addEventListener("mousedown", mouseDown, {
              capture: true
            });
            window === null || window === void 0 ? void 0 : window.addEventListener("touchstart", touchStart, {
              capture: true
            });
            window === null || window === void 0 ? void 0 : window.addEventListener("keydown", keyDown);
            return () => {
              window === null || window === void 0 ? void 0 : window.removeEventListener("mousedown", mouseDown);
              window === null || window === void 0 ? void 0 : window.removeEventListener("touchstart", touchStart);
              window === null || window === void 0 ? void 0 : window.removeEventListener("keydown", keyDown);
            };
          }
        }, [])
      });
      return {
        useSoftDismissProps: q$1(props => {
          debugger;
          return useRefElementProps(props);
        }, []),
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useModal(_ref2) {
      var _focusSelf;

      let {
        modal: {
          bodyIsOnlySemantic: descriptive,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      } = _ref2;
      const {
        useRefElementProps: useTitleRefElementProps,
        getElement: getTitleElement
      } = useRefElement({});
      const {
        useRefElementProps: useBodyRefElementProps,
        getElement: getBodyElement
      } = useRefElement({});
      (_focusSelf = focusSelf) !== null && _focusSelf !== void 0 ? _focusSelf : focusSelf = () => {
        if (descriptive) {
          var _getBodyElement;

          (_getBodyElement = getBodyElement()) === null || _getBodyElement === void 0 ? void 0 : _getBodyElement.focus({
            preventScroll: true
          });
        } else {
          const titleElement = getTitleElement();
          if (titleElement) titleElement.focus({
            preventScroll: true
          });
        } //const elementToFocus = getTitleElement() ?? getBodyElement()

      };
      const stableOnClose = useStableCallback(onClose);
      const stableFocusSelf = useStableCallback(focusSelf); //const [modalDescribedByBody, setModalDescribedByBody] = useState(false);

      useHideScroll(open);
      const {
        useRandomIdSourceElement: useModalIdAsSource,
        useRandomIdReferencerElement: useModalIdAsReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useBodyIdAsSource,
        useRandomIdReferencerElement: useBodyIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-body-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useTitleIdAsSource,
        useRandomIdReferencerElement: useTitleIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-title-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRefElementProps: useModalRefElement,
        getElement: getModalElement
      } = useRefElement({});
      const {
        softDismiss: {
          onBackdropClick
        },
        useSoftDismissProps
      } = useSoftDismiss({
        softDismiss: {
          onClose: stableOnClose,
          getElements: getModalElement,
          open: !!open
        },
        activeElement
      });
      const useModalBackdrop = q$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps({
            onPointerUp: onBackdropClick
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      const useModalFocusContainerProps = function (props) {
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        return useFocusTrapProps(props);
      };

      const useModalProps = function (_ref3) {
        let {
          "aria-modal": ariaModal,
          role,
          ...p0
        } = _ref3;
        const {
          useRandomIdSourceElementProps: useModalIdAsSourceProps
        } = useModalIdAsSource();
        const {
          useRandomIdReferencerElementProps: useTitleIdReferencerElementProps
        } = useTitleIdReferencerElement("aria-labelledby");
        const {
          useRandomIdReferencerElementProps: useBodyIdReferencerElementProps
        } = useBodyIdReferencerElement("aria-describedby");
        console.assert(!ariaModal);
        s(() => {
          if (open) stableFocusSelf();
        }, [open]);
        const p1 = useBodyIdReferencerElementProps(p0);
        const p2 = useModalIdAsSourceProps(p1);
        const pFinal = useTitleIdReferencerElementProps(p2);
        return useSoftDismissProps(useMergedProps(useModalRefElement({
          role: role || "dialog"
        }), descriptive ? pFinal : p2));
      };

      const useModalTitle = q$1(function useModalTitle() {
        const {
          useRandomIdSourceElementProps: useTitleIdAsSourceProps
        } = useTitleIdAsSource();

        const useModalTitleProps = function (props) {
          var _props$tabIndex;

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useTitleRefElementProps(useTitleIdAsSourceProps(props));
        };

        return {
          useModalTitleProps
        };
      }, []);
      const useModalBody = q$1(function useModalBody() {
        const {
          useRandomIdSourceElementProps: useBodyIdAsSourceProps
        } = useBodyIdAsSource();
        const {
          useRandomIdReferencerElementProps: useModalIdAsReferencerElementProps
        } = useModalIdAsReferencerElement("data-modal-id");

        const useModalBodyProps = function (props) {
          var _props$tabIndex2;

          (_props$tabIndex2 = props.tabIndex) !== null && _props$tabIndex2 !== void 0 ? _props$tabIndex2 : props.tabIndex = -1;
          return useBodyRefElementProps(useBodyIdAsSourceProps(useModalIdAsReferencerElementProps(props)));
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop,
        useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      const [getScrollbarWidth, setScrollbarWidth] = usePassiveState(null);
      const [getScrollbarHeight, setScrollbarHeight] = usePassiveState(null);
      s(() => {
        if (hideScroll) {
          // When scrolling is resumed, we'll need to restore the original scroll positions
          // so we need to keep this information around
          const originalScrollTop = document.documentElement.scrollTop;
          const originalScrollLeft = document.documentElement.scrollLeft; // Measure the width of the page (minus the scrollbar)

          const widthWithScrollBar = document.documentElement.scrollWidth;
          const heightWithScrollBar = document.documentElement.scrollHeight; // Apply a class that hides the scrollbar.

          document.documentElement.classList.add("document-scroll-hidden"); // In case multiple things are locking scroll, keep track of how many are doing that
          // (just add 1 on enable, subtract 1 on disable)

          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString(); // Measure the new width without a scrollbar 
          // so we can take the difference as the scrollbar width.

          const widthWithoutScrollBar = document.documentElement.scrollWidth;
          const heightWithoutScrollBar = document.documentElement.scrollHeight;
          let scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar;
          let scrollbarHeight = heightWithoutScrollBar - heightWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it

          if (scrollbarWidth > 80) scrollbarWidth = 0;
          if (scrollbarHeight > 80) scrollbarHeight = 0; // Make our measurements available as CSS properties for general use

          document.documentElement.style.setProperty("--root-scrollbar-width", `${scrollbarWidth}px`);
          document.documentElement.style.setProperty("--root-scrollbar-height", `${scrollbarHeight}px`);
          document.documentElement.style.setProperty("--root-scrollstop-top", `${originalScrollTop}px`);
          document.documentElement.style.setProperty("--root-scrollstop-left", `${originalScrollLeft}px`);
          setScrollbarWidth(scrollbarWidth);
          setScrollbarHeight(scrollbarHeight);
          return () => {
            // Undo all the things we just did
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              // If we were the last scroll-locking thing to stop, then remove the class that stops scrolling.
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden"); // Also, restore the original scroll position
              // We do this by forcing the scroll behavior to not be smooth
              // (it's instant if nothing is set to smooth, https://www.w3.org/TR/cssom-view/#scrolling),
              // scrolling, then restoring the original scroll behavior 
              // (which was probably already auto anyway, but just to be safe)

              const originalScrollBehavior = document.documentElement.style.scrollBehavior;
              document.documentElement.style.scrollBehavior = "auto";
              document.documentElement.scrollTo({
                top: originalScrollTop,
                left: originalScrollLeft,
                behavior: "auto"
              });
              document.documentElement.style.scrollBehavior = originalScrollBehavior;
            }
          };
        }
      }, [hideScroll]);
      return {
        getScrollbarWidth,
        getScrollbarHeight
      };
    }

    function useDialog(_ref) {
      let {
        softDismiss: {
          open
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        dialog: {
          onClose
        },
        activeElement
      } = _ref;
      debugLog("useDialog"); // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.

      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle,
        softDismiss: {
          onBackdropClick
        },
        useModalFocusContainerProps
      } = useModal({
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      });
      const useDialogBackdrop = q$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDialogBody = q$1(() => {
        const {
          useModalBodyProps
        } = useModalBody();
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDialogProps = useModalProps;
      const useDialogTitle = q$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop,
        useDialogFocusContainerProps: useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }

    function useDrawer(_ref) {
      let {
        softDismiss: {
          open,
          onClose
        },
        activeElement,
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        }
      } = _ref;
      debugLog("useDrawer"); // TODO: Drawers are not always modal.

      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle,
        useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      } = useModal({
        modal: {
          bodyIsOnlySemantic: bodyIsOnlySemantic !== null && bodyIsOnlySemantic !== void 0 ? bodyIsOnlySemantic : false,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      });
      const useDrawerBackdrop = q$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDrawerBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDrawerBody = q$1(() => {
        const {
          useModalBodyProps
        } = useModalBody();
        return {
          useDrawerBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDrawerProps = useModalProps;
      const useDrawerTitle = q$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDrawerTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDrawerProps,
        useDrawerTitle,
        useDrawerBody,
        useDrawerBackdrop,
        useDrawerFocusContainerProps: useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }

    function useListboxSingle(_ref) {
      let {
        listboxSingle: {
          tagLabel,
          tagList,
          onSelect,
          ..._lbs
        },
        singleSelection: {
          selectedIndex,
          ...ss
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti
        },
        typeaheadNavigation: { ...tn
        },
        childrenHaveFocus: { ...chf
        }
      } = _ref;
      debugLog("useListboxSingle", selectedIndex);
      const {
        useLabelInput,
        useLabelLabel,
        ...labelReturnType
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagInput: tagList,
          tagLabel: tagLabel
        }
      });
      const onSelectedIndexChange = useStableCallback((event, newIndex) => {
        stableOnSelect(enhanceEvent(event, {
          selectedIndex: newIndex
        }));
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listReturnType
      } = useListNavigationSingleSelection({
        childrenHaveFocus: { ...chf
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti
        },
        singleSelection: { ...ss,
          onSelectedIndexChange,
          selectedIndex
        },
        typeaheadNavigation: tn
      });
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = q$1(_ref2 => {
        let {
          listboxSingleItem: {
            disabled
          },
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocus
        } = _ref2;
        debugLog("useListboxSingleItem", managedChild.index);
        const {
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret,
          useListNavigationSingleSelectionChildProps
        } = useListNavigationSingleSelectionChild({
          managedChild,
          listNavigation,
          rovingTabIndex,
          hasFocus,
          subInfo: {}
        });
        return {
          useListboxSingleItemProps,
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret
        };

        function useListboxSingleItemProps(props) {
          var _ss_ret$selected;

          props.role = "option";
          props["aria-selected"] = ((_ss_ret$selected = ss_ret.selected) !== null && _ss_ret$selected !== void 0 ? _ss_ret$selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationSingleSelectionChildProps(props);
        }
      }, [useListNavigationSingleSelectionChild]);
      const useListboxSingleLabel = q$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        ...listReturnType,
        ...labelReturnType
      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }
    function useListboxGroup() {
      const {
        useRandomIdReferencerElement,
        useRandomIdSourceElement
      } = useRandomId({
        randomId: {
          prefix: "listbox-multi-group"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-labelledby");

      const useListboxGroupHeadingProps = props => {
        return useRandomIdSourceElementProps(props);
      };

      const useListboxGroupContainerProps = _ref3 => {
        let {
          role,
          ...props
        } = _ref3;
        return useRandomIdReferencerElementProps({
          role: warnOnOverwrite("useListboxMultiGroupProps", "role", role, "group"),
          ...props
        });
      };

      return {
        useListboxGroupContainerProps,
        useListboxGroupHeadingProps
      };
    }

    /*export interface UseListboxMultiReturnType<LabelElement extends Element, ListElement extends Element, ListItemElement extends Element> extends Omit<UseListNavigationReturnType<ListElement, ListItemElement, {}, never>, "useListNavigationChild" | "useListNavigationProps"> {
        useListboxMultiItem: UseListboxMultiItem<ListItemElement>;
        useListboxMultiProps: (props: h.JSX.HTMLAttributes<ListElement>) => h.JSX.HTMLAttributes<ListElement>;
        useListboxMultiLabel: () => { useListboxMultiLabelProps: (props: h.JSX.HTMLAttributes<LabelElement>) => h.JSX.HTMLAttributes<LabelElement>; }
    }*/

    function useListboxMulti(_ref) {
      let {
        listboxMulti: {
          tagLabel,
          tagList
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      debugLog("useListboxMulti"); //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagLabel: tagLabel,
          tagInput: tagList
        }
      });
      const listReturnType = useListNavigation({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);
            /*if (selectionMode == "focus") {
                const target = (children.getAt(i!)?.subInfo.getElement());
                if (target)
                    onSelect?.({ target, currentTarget: target, [EventDetail]: { selectedIndex: i! } });
            }*/
          })
        },
        typeaheadNavigation: tn
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const [getShiftHeld, setShiftHeld] = usePassiveState(null, returnFalse$1);
      const useListboxMultiItem = q$1(_ref2 => {
        let {
          listboxMultiItem: {
            selected,
            disabled,
            onSelectedChange
          },
          managedChild,
          listNavigation: ls,
          rovingTabIndex: rti,
          hasFocus
        } = _ref2;
        debugLog("useListboxMultiItem", managedChild.index, selected);
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelectedChange !== null && onSelectedChange !== void 0 ? onSelectedChange : () => {});
        const {
          useListNavigationChildProps,
          rovingTabIndex: rti2_ret
        } = useListNavigationChild({
          listNavigation: ls,
          managedChild,
          rovingTabIndex: rti,
          subInfo: {
            selected,
            onSelect: stableOnSelect
          }
        });
        _(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [rti2_ret.tabbable]);
        return {
          useListboxMultiItemProps,
          listboxMultiItem: {
            getSelected,
            tabbable: rti2_ret.tabbable
          },
          rovingTabIndex: rti2_ret
        };

        function useListboxMultiItemProps(props) {
          var _rti2_ret$tabbable;

          const usePressProps = usePress({
            onClickSync: disabled ? null : e => {
              setTabbableIndex(managedChild.index, false);
              stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
                [EventDetail]: {
                  selected: !getSelected()
                }
              });
              e.preventDefault();
            },
            exclude: {},
            hasFocus
          });
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_rti2_ret$tabbable = rti2_ret.tabbable) !== null && _rti2_ret$tabbable !== void 0 ? _rti2_ret$tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(usePressProps(props)));
        }
      }, [useListNavigationChild]);
      const useListboxMultiLabel = q$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        managedChildren: listReturnType.managedChildren
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    //export type UseMenuChildParameters<I extends UseMenuChildInfo> = I;

    /**
     * A menu is a popup control that contains a list of menu items, and that's it.
     * It has very well-defined logic for managing those items as the menu's state changes.
     *
     * A MenuBase is just the "popup" part without the "list of menu items" part. It can
     * (really, must) have interactive controls, but these controls are allowed to be more
     * free-form. This means that, like a dialog, you must tell this hook
     * where within the popup to send focus when opened (for a menu it's just the first
     * menu item, but with custom content you'll need to provide this).
     *
     */

    function useMenuSurface(_ref) {
      var _intersectionObserver;

      let {
        softDismiss,
        menuSurface: {
          sendFocusToMenu,
          role
        },
        activeElement
      } = _ref;
      debugLog("useMenuSurface"); //const sendFocusWithinMenu = useStableCallback(sendFocusToMenu);
      //const [focusTrapActive, setFocusTrapActive] = useState<null | boolean>(null);

      const {
        open,
        onClose: userOnClose
      } = softDismiss;
      const onClose = useStableCallback(reason => {
        if (reason != "lost-focus") {
          const opener = getOpenerElement();
          if (opener && "focus" in opener) opener.focus({
            preventScroll: true
          });
        }

        return userOnClose(reason);
      });
      useEnsureStability("useMenuSurface", onClose, role, sendFocusToMenu);
      const getIsOpen = useStableGetter(open);
      const intersectionObserver = A(null);
      const [getSurfaceFullyVisible, setSurfaceFullyVisible] = usePassiveState(null, returnFalse$1);
      (_intersectionObserver = intersectionObserver.current) !== null && _intersectionObserver !== void 0 ? _intersectionObserver : intersectionObserver.current = new IntersectionObserver((entries, _observer) => {
        for (const entry of entries) {
          setSurfaceFullyVisible(entry.intersectionRatio >= 1);
        }
      }, {
        root: null,
        threshold: [0, 1]
      });
      const [, setOpenerElement, getOpenerElement] = useState(null); //const { useHasFocusProps: useMenuBaseHasFocusProps, ...surfaceHasFocus } = useHasFocus<MenuSurfaceElement>({ ...hasFocusSurface });
      //const { useHasFocusProps: useButtonHasFocusProps, ...buttonHasFocus } = useHasFocus<MenuButtonElement>({ ...hasFocusButton });
      //const { getLastFocusedInner: getMenuBaseLastFocusedInner } = surfaceHasFocus;

      const {
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-menu-"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-controls");
      const {
        getElement: getButtonElement,
        useRefElementProps: useButtonRefElementProps
      } = useRefElement({
        onElementChange: setOpenerElement
      });
      const {
        getElement: getMenuElement,
        useRefElementProps: useMenuBaseRefElementProps
      } = useRefElement({});
      const {
        useSoftDismissProps,
        ...softDismissReturn
      } = useSoftDismiss({
        softDismiss: { ...softDismiss,
          getElements: () => [getButtonElement(), getMenuElement()]
        },
        activeElement
      });

      const useMenuSurfaceProps = props => {
        function onKeyDown(e) {
          const open = getIsOpen();

          if (e.key == "Escape" && open) {
            onClose("escape");
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }

        return useSoftDismissProps(useMenuBaseRefElementProps(useMergedProps({
          onKeyDown
        }, props)));
      };

      const useMenuSurfaceButtonProps = props => {
        props["aria-expanded"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-expanded", open, open.toString());
        props["aria-haspopup"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-haspopup", role, role);
        return useButtonRefElementProps(useRandomIdReferencerElementProps(props));
      };

      s(() => {
        if (open === true) {
          sendFocusToMenu === null || sendFocusToMenu === void 0 ? void 0 : sendFocusToMenu();
          setTimeout(() => {
            if (!getSurfaceFullyVisible()) {
              var _getMenuElement;

              (_getMenuElement = getMenuElement()) === null || _getMenuElement === void 0 ? void 0 : _getMenuElement.scrollIntoView();
            }
          });
        }
      }, [open]);

      function useMenuSurfaceChildProps(props) {
        props.role = role;
        return useRandomIdSourceElementProps(props);
      }

      return {
        useMenuSurfaceChildProps,
        useMenuSurfaceSentinel: q$1(() => {
          debugLog("useMenuSurfaceSentinel");
          const {
            useSentinelProps: useMenuSentinelProps,
            ...rest
          } = useFocusSentinel({
            focusSentinel: {
              open: open === true,
              onClose: () => onClose("escape"),
              sendFocusToMenu
            }
          });
          return {
            useMenuSentinelProps,
            ...rest
          };
        }, [open, onClose]),
        useMenuSurfaceProps,
        useMenuSurfaceButtonProps,
        menuSurface: {
          /*getActiveElement: buttonHasFocus.getActiveElement,
          getLastActiveElement: buttonHasFocus.getLastActiveElement,
          getButtonElement: buttonHasFocus.getElement,
          getButtonFocused: buttonHasFocus.getFocused,
          getButtonFocusedInner: buttonHasFocus.getFocusedInner,
          getButtonLastFocused: buttonHasFocus.getLastFocused,
          getButtonLastFocusedInner: buttonHasFocus.getLastFocusedInner,
          getSurfaceElement: surfaceHasFocus.getElement,
          getSurfaceFocused: surfaceHasFocus.getFocused,
          getSurfaceFocusedInner: surfaceHasFocus.getFocusedInner,
          getSurfaceLastFocused: surfaceHasFocus.getLastFocused,
          getSurfaceLastFocusedInner: surfaceHasFocus.getLastFocusedInner,
          getWindowFocused: buttonHasFocus.getWindowFocused,*/
        },
        ...softDismissReturn //getMenuBaseLastFocusedInner,
        //getMenuBaseButtonLastFocusedInner,
        //open,
        //onOpen,
        //onClose

      };
    } // A focus sentinal is a hidden but focusable element that comes at the start or end 
    // of the out-of-place-focusable component that, when activated or focused over, closes the component
    // (if focused within 100ms of the open prop changing, instead of
    // closing, focusing the sentinel immediately asks it to focus itself).
    // This exists for things like menus which can have focus but also need a way to return
    // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
    // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
    // and keyboard users can escape to close a menu, screen readers and other input methods 
    // that don't use those two would become stuck.

    function useFocusSentinel(_ref2) {
      let {
        focusSentinel: {
          open,
          onClose,
          sendFocusToMenu
        }
      } = _ref2;
      debugLog("useFocusSentinel");
      const getSendFocusWithinMenu = useStableGetter(sendFocusToMenu);
      const stableOnClose = useStableCallback(onClose);
      const [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: `${open}-${firstSentinelIsActive}`
      });
      const onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
        var _getSendFocusWithinMe;

        return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
      };

      const onClick = () => stableOnClose();

      return {
        useSentinelProps: function (_ref3) {
          let {
            tabIndex,
            ...p
          } = _ref3;
          return useMergedProps({
            onFocus,
            onClick,
            tabIndex: warnOnOverwrite("useFocusSentinel", "tabIndex", tabIndex, 0)
          }, p);
        }
      };
    }
    function useMenu(_ref4) {
      let {
        menuButtonHasFocus,
        linearNavigation,
        listNavigation,
        managedChildren,
        menuSurface,
        rovingTabIndex,
        softDismiss,
        typeaheadNavigation,
        menu,
        activeElement
      } = _ref4;
      debugLog("useMenu");
      const {
        onOpen
      } = menu;
      const {
        open,
        onClose
      } = softDismiss;
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...useListNavReturn
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = useListNavReturn;
      const {
        /*useMenuSentinel,
        useMenuBaseButtonProps,
        useMenuBaseProps,
        open,
        onOpen,
        onClose: _onClose,*/
        useMenuSurfaceButtonProps,
        useMenuSurfaceProps,
        useMenuSurfaceSentinel,
        useMenuSurfaceChildProps,
        ...menuRest
      } = useMenuSurface({
        menuSurface: { ...menuSurface,
          role: "menu",
          sendFocusToMenu: q$1(() => {
            var _children$getAt;

            return (_children$getAt = children.getAt(0)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focusSelf();
          }, [])
        },
        softDismiss,
        //hasFocusButton,
        //hasFocusSurface,
        activeElement //sendFocusWithinMenu: focusMenu ?? (() => { })

      });

      const useMenuButtonProps = p => {
        const usePressProps = usePress({
          onClickSync: () => {
            if (open) onClose === null || onClose === void 0 ? void 0 : onClose("escape");else onOpen === null || onOpen === void 0 ? void 0 : onOpen();
          },
          exclude: {},
          hasFocus: menuButtonHasFocus
        });
        const props = useMenuSurfaceButtonProps(p);
        return usePressProps(props);
      };

      const useMenuItem = q$1(_ref5 => {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex
        } = _ref5;
        debugLog("useMenuItem", managedChild.index);
        const {
          useListNavigationChildProps,
          ...listNavRet
        } = useListNavigationChild({
          listNavigation,
          managedChild,
          rovingTabIndex,
          subInfo: {}
        });

        function useMenuItemProps(_ref6) {
          let { ...props
          } = _ref6;
          props.role = "menuitem";
          return useMergedProps({}, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps,
          ...listNavRet
        };
      }, []);

      function useMenuProps(props) {
        return useListNavigationProps(useMenuSurfaceChildProps(props));
      }

      return {
        useMenuProps,
        useMenuSurfaceProps,
        useMenuButtonProps,
        useMenuItem,
        useMenuSentinel: useMenuSurfaceSentinel,
        //useMenuSubmenuItem,
        ...useListNavReturn,
        ...menuRest
        /*focusMenu,
         currentTypeahead,
        invalidTypeahead,
         managedChildren,*/

      };
    }

    /*
    export function useTabs<TabListElement extends Element, TabElement extends Element, PanelElement extends Element, LabelElement extends Element>({ tabPanels: { managedChildren: { onChildrenMountChange: ocmc, ...tabPanelsManagedChildren } } }: UseTabsParameters): UseTabsReturnTypeWithHooks<TabListElement, TabElement, PanelElement, LabelElement> {
        const {
            useListNavigationSingleSelectionChild,
            useListNavigationSingleSelectionProps
        } = useListNavigationSingleSelection<TabListElement, TabElement, TabInfo, never>({
            childrenHaveFocus: {},
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: {},
            singleSelection: {},
            typeaheadNavigation: {}
         });

        const useTab = useCallback(() => {}, []);
        const useTabPanel = useCallback(() => {});
        function useTabListProps(props: h.JSX.HTMLAttributes<TabListElement>) { return useListNavigationSingleSelectionProps(props); }
        function useTabLabelProps() {}

        return {

        }
        
    }*/

    function useTabs(_ref) {
      let {
        tabPanels: {
          managedChildren: {
            onChildrenMountChange: ocmc,
            ...tabPanelsManagedChildren
          }
        }
      } = _ref;
      debugLog("useTabs");
      const baseId = generateRandomId("aria-tabs-"); //const getTabListId = useCallback(() => { return baseId + "-tab-list"; }, []);

      const getTabId = q$1(index => {
        return baseId + "-tab-" + index;
      }, []);
      const getPanelId = q$1(index => {
        return baseId + "-panel-" + index;
      }, []); // Used for the panels, not the tabs in the tablist.
      // Those are in useTabList itself.

      const {
        useManagedChild,
        ...managedChildrenRet
      } = useManagedChildren({
        managedChildren: { ...tabPanelsManagedChildren,
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc === null || ocmc === void 0 ? void 0 : ocmc(m, u);
            reevaluateClosestFit();
          })
        }
      });
      const {
        changeIndex: changeVisiblePanel,
        getCurrentIndex: getVisibleIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        children: managedChildrenRet.managedChildren.children,
        closestFit: false,
        initialIndex: null,
        key: "visible"
      }); //const { useRandomIdReferencerElement, useRandomIdSourceElement } = useRandomId({ randomId: { prefix: "aria-tabs-" }, managedChildren: { onAfterChildLayoutEffect: null, onChildrenMountChange: null } });

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixInput: "",
          prefixLabel: "",
          tagInput: "div",
          tagLabel: "div"
        }
      });
      const useTabListLabel = q$1(() => {
        const {
          useLabelLabelProps
        } = useLabelLabel();

        function useTabListLabelProps(props) {
          return useLabelLabelProps(props);
        }

        return {
          useTabListLabelProps
        };
      }, [useLabelLabel]);
      const useTabList = q$1(_ref2 => {
        let {
          childrenHaveFocus,
          tabs: {
            onSelectedIndexChange
          },
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection,
          typeaheadNavigation
        } = _ref2;
        debugLog("useTabList");
        const stableOnSelectedIndexChange = useStableCallback(onSelectedIndexChange);
        const {
          useListNavigationSingleSelectionChild,
          useListNavigationSingleSelectionProps,
          ...listNavRet1
        } = useListNavigationSingleSelection({
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection: { ...singleSelection,
            onSelectedIndexChange: q$1((event, index) => {
              onSelectedIndexChange === null || onSelectedIndexChange === void 0 ? void 0 : onSelectedIndexChange(enhanceEvent(event, {
                selectedIndex: index
              }));
            }, [])
          },
          typeaheadNavigation,
          childrenHaveFocus
        });
        s(() => {
          changeVisiblePanel(singleSelection.selectedIndex);
        }, [singleSelection.selectedIndex]);
        const {
          useLabelInputProps
        } = useLabelInput();
        const useTab = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            hasFocus
          } = _ref3;
          debugLog("useTab", managedChild.index);
          const {
            useListNavigationSingleSelectionChildProps,
            ...listNavRet2
          } = useListNavigationSingleSelectionChild({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo: {},
            hasFocus
          });
          const {
            singleSelection: {
              selected
            },
            rovingTabIndex: {
              tabbable
            }
          } = listNavRet2;

          const useTabProps = _ref4 => {
            let {
              role,
              "aria-controls": ariaControls,
              "aria-selected": ariaSelected,
              ...props
            } = _ref4;
            const panelId = getPanelId(managedChild.index);
            const tabId = getTabId(managedChild.index);
            const usePressProps = usePress({
              onClickSync: e => {
                stableOnSelectedIndexChange(enhanceEvent(e, {
                  selectedIndex: managedChild.index
                }));
              },
              exclude: {},
              hasFocus
            });
            return useListNavigationSingleSelectionChildProps(useMergedProps({
              role: warnOnOverwrite("useTab", "role", role, "tab"),
              "aria-controls": warnOnOverwrite("useTab", "ariaControls", ariaControls, panelId),
              "aria-selected": warnOnOverwrite("useTab", "ariaSelected", ariaSelected, selected ? "true" : undefined),
              "data-tabbable": tabbable.toString(),
              id: tabId
            }, usePressProps(props)));
          };

          return {
            useTabProps,
            ...listNavRet2
          };
        }, [useLabelInput, useListNavigationSingleSelectionChild]);

        const useTabListProps = _ref5 => {
          let {
            role,
            "aria-orientation": ariaOrientation,
            ...props
          } = _ref5;
          return useListNavigationSingleSelectionProps(useLabelInputProps(useMergedProps({
            role: warnOnOverwrite("useTabList", "role", role, "tablist"),
            "aria-orientation": ariaOrientation !== null && ariaOrientation !== void 0 ? ariaOrientation : "horizontal"
          }, props)));
        };

        return {
          tabList: listNavRet1,
          useTabListProps,
          useTab
        };
      }, [useLabelInput]);
      const useTabPanel = q$1(_ref6 => {
        let {
          managedChild: {
            flags,
            ...managedChild
          }
        } = _ref6;
        debugLog("useTabPanel", managedChild.index); //const [correspondingTabId, setCorrespondingTabId] = useState<string | null>(null);

        const [isVisible, setIsVisible, getIsVisible] = useState(getVisibleIndex() == managedChild.index);
        const visibleRef = A({
          get: getIsVisible,
          set: setIsVisible,
          isValid: returnTrue
        });
        useManagedChild({
          managedChild: { ...managedChild,
            flags: {
              visible: visibleRef.current,
              ...flags
            },
            subInfo: {}
          }
        });
        const panelId = getPanelId(managedChild.index);
        const tabId = getTabId(managedChild.index);

        const useTabPanelProps = _ref7 => {
          let {
            role,
            "aria-labelledby": ariaLabelledBy,
            id,
            ...props
          } = _ref7;
          return useMergedProps({
            role: warnOnOverwrite("useTabPanelProps", "role", role, "tabpanel"),
            "aria-labelledby": warnOnOverwrite("useTabPanelProps", "aria-labelledby", ariaLabelledBy, tabId),
            id: warnOnOverwrite("useTabPanelProps", "id", id, panelId)
          }, props);
        };

        return {
          useTabPanelProps,
          tabPanel: {
            visible: isVisible,
            getVisible: getIsVisible
          }
        };
      }, []);
      return {
        useTabListLabel,
        useTabList,
        useTabPanel,
        tabPanels: managedChildrenRet
      };
    }

    function returnFalse() {
      return false;
    }

    function useTooltip(_ref) {
      var _mouseoverDelay, _mouseoutToleranceDel, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutToleranceDelay,
        focusDelay
      } = _ref;
      debugLog("useTooltip");
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutToleranceDel = mouseoutToleranceDelay) !== null && _mouseoutToleranceDel !== void 0 ? _mouseoutToleranceDel : mouseoutToleranceDelay = 500;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setHoverState("hidden");
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        randomId: {
          prefix: "aria-tooltip-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const onHoverChange = useStableCallback(function onHoverChange(hovering) {
        if (hovering) {
          switch (hoverState) {
            case "hiding":
              {
                // We're hoving over the tooltip right after hovering away from it.
                // In this case, we show it again immediately
                setHoverState("shown");
                break;
              }

            case "hidden":
              {
                // The tooltip isn't showing and hasn't for awhile (if ever)
                // Wait for our mouseover delay
                setHoverState("showing2");
                break; //const handle = setTimeout(() => { console.log("setHoverState(shown)");  setHoverState("shown") }, mouseoverDelay);
                //return () => clearTimeout(handle);
              }
          }
        } else {
          switch (hoverState) {
            case "shown":
              {
                // The mouse has left the trigger, but delay truly hiding it for a moment
                setHoverState("hiding");
                break; //const handle = setTimeout(() => { console.log("setHoverState(hidden)"); setHoverState("hidden");}, mouseoverDelay);
                //return () => clearTimeout(handle);
              }

            case "showing2":
              {
                // During a mouseover delay, when we mouseout,
                // just reset the timer
                setHoverState("hidden");
                break;
              }
          }
        }
      });
      const [, setTriggerHover] = usePassiveState(onHoverChange, returnFalse);
      const [, setTooltipHover] = usePassiveState(onHoverChange, returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [hoverState, setHoverState] = useState("hidden");
      useTimeout({
        triggerIndex: hoverState,
        timeout: hoverState == "showing2" ? mouseoverDelay : null,
        callback: () => {
          if (hoverState == "showing2") {
            setHoverState("shown");
          }
        }
      });
      useTimeout({
        triggerIndex: hoverState,
        timeout: hoverState == "hiding" ? mouseoutToleranceDelay : null,
        callback: () => {
          if (hoverState == "hiding") {
            setHoverState("hidden");
          }
        }
      }); //const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);

      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false); //const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);

      const hoverDelayCorrected = hoverState == "shown";
      s(() => {
        setOpen(triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected);
      }, [triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected]);
      const useTooltipTrigger = q$1(function useTooltipTrigger(_ref2) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useTooltipTrigger");
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({ ...hasFocus,
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTriggerFocused(focused);
          })
        });

        function useTooltipTriggerProps(_ref3) {
          var _props$tabIndex;

          let { ...props
          } = _ref3;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltipPopup = q$1(function useTooltip(_ref4) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref4;
        debugLog("useTooltipTooltip");
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTooltipFocused(focused);
          }),
          ...hasFocus
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipPopupProps(_ref5) {
          let { ...props
          } = _ref5;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipPopupProps
        };
      }, []);
      return {
        useTooltipPopup,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function useRadioGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        radioGroup: {
          name,
          onSelectedValueChange,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex,
        typeaheadNavigation,
        childrenHaveFocus,
        singleSelection: {
          selectionMode
        }
      } = _ref;
      debugLog("useRadioGroup", selectedValue);
      const {
        getElement: _getRadioGroupParentElement,
        useRefElementProps
      } = useRefElement({}); //const getSelectedIndex = useCallback((selectedValue: V) => { return byName.current.get(selectedValue) ?? 0 }, [])

      const [selectedIndex, setSelectedIndex] = useState(0);
      const byName = A(new Map()); //const stableOnInput = useStableCallback(onSelectedValueChange);
      //const [anyRadiosFocused, setAnyRadiosFocused, getAnyRadiosFocused] = useState(false);

      const {
        useLabelInput: useGroupLabelInput,
        useLabelLabel: useGroupLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-radio-group-label-",
          tagInput: tagGroup,
          tagLabel: tagGroupLabel,
          prefixInput: "aria-radio-group-"
        }
      });
      const {
        useLabelInputProps: useGroupLabelInputProps
      } = useGroupLabelInput();
      const {
        useLabelLabelProps: useGroupLabelLabelProps
      } = useGroupLabelLabel();
      const onSelectedIndexChange = useStableCallback((e, newIndex) => {
        var _listNavRet$managedCh;

        onSelectedValueChange(enhanceEvent(e, {
          selectedValue: (_listNavRet$managedCh = listNavRet.managedChildren.children.getAt(newIndex)) === null || _listNavRet$managedCh === void 0 ? void 0 : _listNavRet$managedCh.subInfo.subInfo.subInfo.getValue()
        }));
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listNavRet
      } = useListNavigationSingleSelection({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        singleSelection: {
          selectedIndex,
          onSelectedIndexChange,
          selectionMode
        },
        typeaheadNavigation,
        childrenHaveFocus
      }); // Track whether the currently focused element is a child of the radio group parent element.
      // When it's not, we reset the tabbable index back to the currently selected element.
      //const { useActiveElementProps } = useActiveElement<G>({ onActiveElementChange: useCallback((activeElement: Node | null) => setAnyRadiosFocused(!!(getRadioGroupParentElement()?.contains(activeElement))), []) });

      /*useEffect(() => {
          if (!anyRadiosFocused)
              navigateToIndex(selectedIndex ?? 0);
      }, [anyRadiosFocused, selectedIndex, navigateToIndex]);*/

      const useRadioGroupProps = q$1(_ref2 => {
        let { ...props
        } = _ref2;
        props.role = "radiogroup";
        return useGroupLabelInputProps(useListNavigationSingleSelectionProps(useRefElementProps(props)));
      }, [useRefElementProps]);
      const useRadioGroupLabelProps = q$1(props => {
        return useGroupLabelLabelProps(props);
      }, [useGroupLabelLabelProps]); //const correctedIndex = (selectedIndex == null || selectedIndex < 0 || selectedIndex >= managedChildren.length) ? null : selectedIndex;

      /*const { onChildrenMountChange } = useChildrenFlag({
          initialIndex: 0,
          children,
          key: "selected"
          //setChildFlag: (i, checked) => managedChildren[i]?.setChecked(checked),
          //getChildFlag: ((i) => managedChildren[i]?.getChecked() ?? false)
      });*/

      s(() => {
        if (selectedValue == null) {
          setSelectedIndex(null);
        } else {
          const selectedIndex = byName.current.get(selectedValue);
          setSelectedIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : null);
        }
      }, [byName, selectedValue]);
      const useRadio = q$1(function useRadio(_ref3) {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocusInput,
          hasFocusLabel,
          radio: {
            disabled,
            labelPosition,
            tagInput,
            tagLabel,
            value
          }
        } = _ref3;
        const index = managedChild.index;
        debugLog("useRadio", index); //const [checked, setChecked, getChecked] = useState<boolean | null>(null);

        const onInput = useStableCallback(e => {
          e.preventDefault();
          onSelectedIndexChange(e, index);
        });
        const getValue = useStableGetter(value);
        const {
          useListNavigationSingleSelectionChildProps,
          ...listNavRet
        } = useListNavigationSingleSelectionChild({
          listNavigation,
          rovingTabIndex,
          managedChild,
          hasFocus: hasFocusInput,
          subInfo: {
            getValue
          }
        });
        const {
          singleSelection: {
            selected: checked
          }
        } = listNavRet;
        const {
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checkboxLike: {
            checked: checked !== null && checked !== void 0 ? checked : false,
            labelPosition,
            disabled,
            onCheckedChange: onInput,
            role: "radio"
          },
          label: {
            tagInput: tagInput,
            tagLabel: tagLabel
          },
          hasFocusInput,
          hasFocusLabel
        });
        _(() => {
          byName.current.set(value, index);
          return () => {
            byName.current.delete(value);
          };
        }, [byName, value, index]);

        const useRadioInput = () => {
          const tag = tagInput;

          const useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked !== null && checked !== void 0 ? checked : false;
              props.type = "radio";
            } else {
              props["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            }

            const propsIfInputHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            const {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement();
            return useMergedProps(useCheckboxLikeInputElementProps({}), labelPosition == "separate" ? propsIfInputHandlesFocus : props);
          };

          return {
            useRadioInputProps
          };
        };

        const useRadioLabel = q$1(() => {
          //const tag = tagLabel;
          const useRadioLabelProps = props => {
            const {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement();
            const propsIfLabelHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            return useCheckboxLikeLabelElementProps(useMergedProps({}, labelPosition == "wrapping" ? propsIfLabelHandlesFocus : props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel,
          ...listNavRet //checked: checked ?? false,
          //tabbable: tabbable ?? false

        };
      }, [byName, useListNavigationSingleSelectionChild]);
      return {
        useRadio,
        useRadioGroupProps,
        useRadioGroupLabelProps,
        radioGroup: {
          selectedIndex,
          selectedValue
        },
        ...listNavRet
      };
    }

    function useSlider(_ref) {
      let {
        slider: {
          max: maxParent,
          min: minParent
        },
        managedChildren
      } = _ref;
      debugLog("useSlider");
      const {
        useManagedChild,
        ...childrenInfo
      } = useManagedChildren({
        managedChildren
      });
      const useSliderThumb = q$1(function useSliderThumb(_ref2) {
        let {
          managedChild,
          sliderThumb
        } = _ref2;
        debugLog("useSliderThumb", managedChild.index);
        const [minParentCopy, setMinParentCopy] = y(minParent);
        const [maxParentCopy, setMaxParentCopy] = y(maxParent);

        useManagedChild({
          managedChild: { ...managedChild,
            subInfo: {
              setMax: setMaxParentCopy,
              setMin: setMinParentCopy
            }
          }
        });

        const {
          tag,
          value,
          max: maxOverride,
          min: minOverride,
          onValueChange,
          valueText,
          label
        } = sliderThumb;
        const min = minOverride !== null && minOverride !== void 0 ? minOverride : minParentCopy;
        const max = maxOverride !== null && maxOverride !== void 0 ? maxOverride : maxParentCopy;
        return {
          useSliderThumbProps,
          sliderThumb: {
            min,
            max
          }
        };

        function useSliderThumbProps(props) {
          let newProps = tag == "input" ? {
            min,
            max,
            value,
            type: "range"
          } : {
            "aria-valuemax": `${max}`,
            "aria-valuemin": `${min}`,
            "aria-valuenow": `${value}`
          };
          newProps = { ...newProps,
            "aria-label": label,
            "aria-valuetext": valueText,
            style: {
              "--range-value": `${value}`,
              "--range-value-text": `${valueText}`
            }
          };

          if (tag == "input") {
            newProps.onInput = e => {
              onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange({
                currentTarget: e.currentTarget,
                target: e.target,
                [EventDetail]: {
                  value: e.currentTarget.valueAsNumber
                }
              });
            };
          } else {
            throw new Error("Unimplemented");
          }

          return useMergedProps(newProps, props);
        }
      }, []);
      return {
        useSliderThumb,
        ...childrenInfo
      };
    }

    function useToasts(_ref) {
      let {
        managedChildren: {
          onChildrenMountChange: ocmu,
          onAfterChildLayoutEffect
        },
        toasts: {
          visibleCount
        }
      } = _ref;
      debugLog("useToasts"); // Normally, this does just look like [0, 1, 2, 3], etc
      // so it could be just an index to the current toast,
      // but if we dismiss toasts out of order, it's [0, 2, 3] or something.
      // So just keep track of it all in a big ol', there's only one of these on a page anyway,
      // and if you're pusing 10000 toasts at once an Array<number> isn't going to be your bottleneck.

      const currentIndexQueue = A([]);
      const [politeness, setPoliteness] = useState("polite");
      const getMaxVisibleCount = useStableGetter(visibleCount);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({});
      const {
        useManagedChild,
        ...childInfo
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: ocmu
        }
      });
      const {
        managedChildren: {
          children: toastQueue
        }
      } = childInfo; // When a toast is shown or hidden, always make sure that we're showing all the toasts that we should be.

      const showHighestPriorityToast = q$1(() => {
        const max = Math.min(getMaxVisibleCount(), currentIndexQueue.current.length);

        for (let i = 0; i < max; ++i) {
          const highestPriorityToast = toastQueue.getAt(currentIndexQueue.current[i]);
          console.assert(!!highestPriorityToast);
          highestPriorityToast === null || highestPriorityToast === void 0 ? void 0 : highestPriorityToast.subInfo.show();
        }
      }, []); // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
      // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)

      const onAnyToastMounted = q$1(toastIndex => {
        var _toastQueue$getAt;

        currentIndexQueue.current.push(toastIndex);
        (_toastQueue$getAt = toastQueue.getAt(toastIndex)) === null || _toastQueue$getAt === void 0 ? void 0 : _toastQueue$getAt.subInfo.setNumberAheadOfMe(currentIndexQueue.current.length - 1);
        showHighestPriorityToast();
      }, []); // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.

      const onAnyToastDismissed = q$1(_index => {
        var _toastQueue$getAt2;

        // When we dismiss a toast, remove it from the "to-display" queue by actually splicing it out of the array.
        // Then notify each toast of its change in position within that queue to keep the two in sync.
        const removalIndex = currentIndexQueue.current.findIndex(i => i == _index); // For all toasts that have already been dismissed, shift them even further back by one to "make space" 
        // (they're removed from the queue but this is the negative index they would have if we kept negatives in the queue)
        // for the newly-dismissed toast.

        toastQueue.forEach(c => {
          c.subInfo.setNumberAheadOfMe(prev => {
            if (prev < 0) return prev - 1;else return prev;
          });
        }); // Let this toast know that it's now the most recently dismissed toast

        (_toastQueue$getAt2 = toastQueue.getAt(_index)) === null || _toastQueue$getAt2 === void 0 ? void 0 : _toastQueue$getAt2.subInfo.setNumberAheadOfMe(-1); // Notify all toasts waiting behind this one in the queue that they've moved up one slot

        toastQueue.forEach(c => {
          c.subInfo.setNumberAheadOfMe(prev => {
            if (prev > removalIndex) return prev - 1;else return prev;
          });
        }); // Actually modify the queue itself

        currentIndexQueue.current.splice(removalIndex, 1); // And after all that, make sure that we're showing any toasts that have been waiting in the queue

        showHighestPriorityToast();
      }, []);
      const [_mouseOver2, setMouseOver, _getMouseOver] = useState(false);
      useGlobalHandler(document, "pointermove", e => {
        var _getElement;

        const mouseOver = e.target != null && e.target instanceof Node && (((_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.contains(e.target)) || getElement() == e.target);
        setMouseOver(mouseOver);
      }); // Any time the index pointing to the currently-showing toast changes,
      // update the relevant children and let them know that they're now either active or dismissed.

      /*const { changeIndex, reevaluateClosestFit } = useChildrenFlag<ToastInfo, "showing">({
          initialIndex: activeToastIndex,
          children: toastQueue,
          key: "showing",
          closestFit: false,
      });
      useEffect(() => {
          changeIndex(activeToastIndex);
      }, [activeToastIndex]);*/

      const useToast = q$1(_ref2 => {
        let {
          toast: {
            politeness,
            timeout
          },
          managedChild: {
            index
          }
        } = _ref2;
        debugLog("useToast", index);
        const [numberOfToastsAheadOfUs, setNumberOfToastsAheadOfUs] = useState(Infinity);
        const getIndex = useStableGetter(index);
        const [dismissed2, setDismissed2, getDismissed2] = useState(false);
        const [showing2, setShowing2, getShowing2] = useState(false); //const [dismissed, setDismissed] = useState(false);
        //const [status, setStatus, getStatus] = useState<"pending" | "active" | "dismissed">("pending");
        //const dismissed = (status === "dismissed");

        const dismiss = q$1(() => {
          if (!getDismissed2()) onAnyToastDismissed(getIndex());
          setDismissed2(true);
          setShowing2(false);
        }, []);
        const show = q$1(() => {
          setShowing2(true);
        }, []);
        s(() => {
          if (!getDismissed2() && !getShowing2()) {
            if (numberOfToastsAheadOfUs >= 0 && numberOfToastsAheadOfUs < getMaxVisibleCount()) {
              show();
            }
          }
        }, [numberOfToastsAheadOfUs]); //const toastId = generateRandomId("toast-");

        _(() => {
          setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
        }, [politeness]);
        const focus = q$1(() => {
          const element = getElement();

          if (element) {
            const firstFocusable = findFirstFocusable(element);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
          }
        }, []);
        /*const [showing, setShowing2, getShowing] = useState(false);
        const setShowing: StateUpdater<boolean> = ((u) => {
            setShowing2(prev => {
                const ret: boolean = (typeof u == 'function') ? u(prev) : u;
                 if (ret === false) {
                    setDismissed(true);
                    onAnyToastDismissed(getIndex())
                }
                 return ret;
            });
        })*/
        //const showingRef = useRef<ChildFlagOperations>({ get: getShowing, set: setShowing, isValid: returnTrue });

        useManagedChild({
          managedChild: {
            index,
            flags: {
              /*showing: showingRef.current*/
            },
            subInfo: {
              focus,
              setNumberAheadOfMe: setNumberOfToastsAheadOfUs,
              show
            }
          }
        }); //const isActive = (status === "active");


        const [triggerIndex, setTriggerIndex] = useState(1);
        const resetDismissTimer = q$1(() => {
          setTriggerIndex(i => ++i);
        }, []);
        s(() => {
          onAnyToastMounted(index);
        }, []);
        /*useEffect(() => {
            if (!showing)
                onAnyToastDismissed(index)
        }, [showing]);*/

        const dismissTimeoutKey = timeout == null || numberOfToastsAheadOfUs != 0 ? null : isFinite(timeout) ? timeout : timeout > 0 ? null : 0;
        useTimeout({
          timeout: dismissTimeoutKey,
          callback: () => {
            if (showing2) dismiss();
          },
          triggerIndex: showing2 ? triggerIndex : false
        });
        return {
          toast: {
            dismissed: dismissed2,
            showing: showing2,
            numberOfToastsAheadOfUs,
            dismiss,
            resetDismissTimer
          }
        };
      }, []);

      function useToastContainerProps(_ref3) {
        var _ref4;

        let {
          role,
          "aria-live": ariaLive,
          "aria-relevant": ariaRelevant,
          ...props
        } = _ref3;
        return useMergedProps(useRefElementProps({
          class: "toasts-container",
          role: role || "status",
          "aria-live": (_ref4 = politeness !== null && politeness !== void 0 ? politeness : ariaLive) !== null && _ref4 !== void 0 ? _ref4 : "polite",
          "aria-relevant": ariaRelevant !== null && ariaRelevant !== void 0 ? ariaRelevant : "additions"
        }), props);
      }

      return {
        useToast,
        useToastContainerProps,
        ...childInfo,
        toasts: {}
      };
    }

    function identity$1(t) {
      return t;
    }

    function useTable(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useTable");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null);
      const manglers = A({
        rowIndexMangler: identity$1,
        rowIndexDemangler: identity$1
      });
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation: { ...listNavigation
        },
        gridNavigation: {
          rowIndexDemangler: q$1(n => manglers.current.rowIndexDemangler(n), []),
          rowIndexMangler: q$1(n => manglers.current.rowIndexMangler(n), [])
        },
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useTableRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          tableRow: {
            location,
            tagTableRow
          }
        } = _ref2;
        debugLog("useTableRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              location
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useTableCell = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus,
            tableCell: {
              tagTableCell,
              headerType
            }
          } = _ref3;
          const [mySortDirection, setMySortDirection] = useState(null);
          debugLog("useTableCell", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo: { ...subInfo,
              setMySortDirection
            },
            hasFocus
          });
          const sort = useStableCallback(() => {
            var _getCurrentSortColumn;

            const sortInfo = (_getCurrentSortColumn = getCurrentSortColumn()) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : {
              index: -1,
              direction: 'ascending'
            };
            const cellIndex = managedChild.index;

            if (sortInfo.index == cellIndex) {
              if (sortInfo.direction[0] == 'a') {
                sortInfo.direction = 'descending';
              } else {
                sortInfo.direction = 'ascending';
              }
            } else {
              sortInfo.direction = "ascending";
            }

            sortInfo.index = managedChild.index;
            setCurrentSortColumn(sortInfo);
            getCells().forEach(cell => {
              if (cell.index == managedChild.index) {
                cell.subInfo.subInfo.subInfo.setMySortDirection(sortInfo.direction);
              } else {
                cell.subInfo.subInfo.subInfo.setMySortDirection(null);
              }
            });
            bodySort.current();
          });

          const useTableCellProps = props => {
            if (tagTableCell != "td" && tagTableCell != "th") {
              if (headerType == "row") props.role = warnOnOverwrite("useTableCell", "role", props.role, "rowheader");else if (headerType == "column") props.role = warnOnOverwrite("useTableCell", "role", props.role, "columnheader");else props.role = warnOnOverwrite("useTableCell", "role", props.role, "cell");
            } else {
              if (headerType == "row") props.scope = warnOnOverwrite("useTableCell", "scope", props.scope, "row");else if (headerType == "column") props.scope = warnOnOverwrite("useTableCell", "scope", props.scope, "col");
            }

            if (headerType != null) {
              if (mySortDirection == "descending") {
                props["aria-sort"] = warnOnOverwrite("useTableCell", "aria-sort", props["aria-sort"], "descending");
              } else if (mySortDirection == "ascending") {
                props["aria-sort"] = warnOnOverwrite("useTableCell", "aria-sort", props["aria-sort"], "ascending");
              }
            }

            return useGridNavigationCellProps(props);
          };

          return {
            tableHeaderCell: {
              sort,
              sortDirection: mySortDirection
            },
            useTableCellProps,
            ...gridNavRet3
          };
        }, []);

        const useTableRowProps = props => {
          if (tagTableRow != "tr") props.role = warnOnOverwrite("useTableRow", "role", props.role, "row");
          return useGridNavigationRowProps(props);
        };

        return {
          useTableCell,
          useTableRowProps,
          ...gridNavRet2
        };
      }, []);
      const useTableBody = q$1(() => {
        debugLog("useTableBody");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn2, _getCurrentSortColumn3, _cell$subInfo$subInfo, _cell$subInfo$subInfo2;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn2 = (_getCurrentSortColumn3 = getCurrentSortColumn()) === null || _getCurrentSortColumn3 === void 0 ? void 0 : _getCurrentSortColumn3.index) !== null && _getCurrentSortColumn2 !== void 0 ? _getCurrentSortColumn2 : 0);
          return {
            location: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.location) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : "head",
            value: (_cell$subInfo$subInfo2 = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.value) !== null && _cell$subInfo$subInfo2 !== void 0 ? _cell$subInfo$subInfo2 : -1
          }; //return cells.getAt(getCurrentSortColumn()?.index ?? 0)?.subInfo.subInfo.subInfo.value ?? null;
        }, []);

        const compare = (lhs, rhs) => {
          var _lhs$value, _rhs$value;

          if (lhs.location === rhs.location) return +((_lhs$value = lhs.value) !== null && _lhs$value !== void 0 ? _lhs$value : -Infinity) - +((_rhs$value = rhs.value) !== null && _rhs$value !== void 0 ? _rhs$value : -Infinity);
          if (lhs.location == 'head') return -1;
          if (lhs.location == 'body') return rhs.location == 'head' ? -1 : 1;
          return 1;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          },
          rearrangeableChildren: {
            indexDemangler,
            indexMangler
          }
        } = sortableRet;
        s(() => {
          manglers.current.rowIndexDemangler = indexDemangler;
          manglers.current.rowIndexMangler = indexMangler;
        }, [indexDemangler, indexMangler]);
        _(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn4, _getCurrentSortColumn5;

            sort(rows, (_getCurrentSortColumn4 = (_getCurrentSortColumn5 = getCurrentSortColumn()) === null || _getCurrentSortColumn5 === void 0 ? void 0 : _getCurrentSortColumn5.direction) !== null && _getCurrentSortColumn4 !== void 0 ? _getCurrentSortColumn4 : 'ascending');
          };
        }, [sort]);

        const useTableBodyProps = props => {
          console.assert(props.children != null);
          return useSortableProps(props);
        };

        return {
          useTableBodyProps,
          ...sortableRet
        };
      }, []);
      const useTableProps = useGridNavigationProps;
      const useTableSectionProps = q$1((tag, location, props) => {
        if (!(tag == "thead" || tag == "tbody" || tag == "tfoot")) {
          props.role = warnOnOverwrite("useTableSectionProps", "role", props.role, "rowgroup");
        }

        return props;
      }, []);
      return {
        useTableProps,
        useTableBody,
        useTableRow,
        useTableSectionProps,
        ...gridNavRet1
      };
    }

    function identity(t) {
      return t;
    }

    function useGridlist(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useGridlist");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null); // TODO: Comparing the location should happen out here, not in each section so that grid navigation works right...

      const manglers = A({
        rowIndexMangler: identity,
        rowIndexDemangler: identity
      });
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation,
        gridNavigation: {
          rowIndexDemangler: q$1(n => manglers.current.rowIndexDemangler(n), []),
          rowIndexMangler: q$1(n => manglers.current.rowIndexMangler(n), [])
        }
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useGridlistRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          gridlistRow: {
            locationIndex
          }
        } = _ref2;
        debugLog("useGridlistRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              locationIndex
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useGridlistChild = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          } = _ref3;
          debugLog("useGridlistChild", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          });

          const useGridlistChildProps = props => {
            props.role = warnOnOverwrite("useGridlistChild", "role", props.role, "cell");
            return useGridNavigationCellProps(props);
          };

          return {
            useGridlistChildProps,
            ...gridNavRet3
          };
        }, []);

        const useGridlistRowProps = props => {
          props.role = warnOnOverwrite("useGridlistRow", "role", props.role, "row");
          return useGridNavigationRowProps(props);
        };

        return {
          useGridlistChild,
          useGridlistRowProps,
          ...gridNavRet2
        };
      }, []);
      const useGridlistSection = q$1(_ref4 => {
        let {
          compareRows
        } = _ref4;
        debugLog("useGridlistSection");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn, _getCurrentSortColumn2, _cell$subInfo$subInfo, _cell$index;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn = (_getCurrentSortColumn2 = getCurrentSortColumn()) === null || _getCurrentSortColumn2 === void 0 ? void 0 : _getCurrentSortColumn2.index) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : 0);
          return {
            locationIndex: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.locationIndex) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : 0,
            index: (_cell$index = cell === null || cell === void 0 ? void 0 : cell.index) !== null && _cell$index !== void 0 ? _cell$index : 0
          };
        }, []);

        const compare = (lhs, rhs) => {
          if (lhs.locationIndex === rhs.locationIndex) return compareRows(lhs.index, rhs.index);
          return lhs.locationIndex - rhs.locationIndex;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          }
        } = sortableRet;
        _(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn3, _getCurrentSortColumn4;

            sort(rows, (_getCurrentSortColumn3 = (_getCurrentSortColumn4 = getCurrentSortColumn()) === null || _getCurrentSortColumn4 === void 0 ? void 0 : _getCurrentSortColumn4.direction) !== null && _getCurrentSortColumn3 !== void 0 ? _getCurrentSortColumn3 : 'ascending');
          };
        }, [sort]);

        const useGridlistSectionProps = props => {
          console.assert(props.children != null);
          props.role = warnOnOverwrite("useGridlistSection", "role", props.role, "rowgroup");
          return useSortableProps(props);
        };

        return {
          useGridlistSectionProps,
          ...sortableRet
        };
      }, []);

      const useGridlistProps = props => {
        props.role = warnOnOverwrite("useGridlist", "role", props.role, "grid");
        return useGridNavigationProps(props);
      };

      return {
        useGridlistProps,
        useGridlistSection,
        useGridlistRow,
        ...gridNavRet1
      };
    }

    const AccordionSectionContext = B$2(null);
    const Accordion = w(function Accordion(_ref) {
      let {
        disableArrowKeys,
        disableHomeEndKeys,
        expandedIndex,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render
      } = _ref;
      const {
        useAccordionSection,
        ...provider
      } = useAccordion({
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      s(() => {
        provider.accordion.changeExpandedIndex(expandedIndex !== null && expandedIndex !== void 0 ? expandedIndex : null);
      }, [expandedIndex]);
      return o$1(AccordionSectionContext.Provider, {
        value: useAccordionSection,
        children: render(provider)
      });
    });
    function defaultRenderAccordionSection(_ref2) {
      let {
        makePropsHeadingContainer,
        makePropsHeadingButton,
        makePropsBody,
        tagBody,
        tagHeadingButton
      } = _ref2;
      return function (info, modifyHeadingButtonProps, modifyBodyProps) {
        return o$1(p$1, {
          children: o$1(Heading, { ...makePropsHeadingContainer(info),
            heading: h$1(tagHeadingButton, modifyHeadingButtonProps(makePropsHeadingButton(info))),
            children: h$1(tagBody, modifyBodyProps(makePropsBody(info)))
          })
        });
      };
    }
    const AccordionSection = w(function AccordionSection(_ref3) {
      let {
        open,
        index,
        tagButton,
        disabled,
        render,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref3;
      const useAccordionSection = x(AccordionSectionContext);
      const {
        useAccordionSectionBodyProps,
        useAccordionSectionHeaderProps,
        ...sectionInfo
      } = useAccordionSection({
        button: {
          disabled,
          tagButton
        },
        accordionSection: {
          open
        },
        managedChildren: {
          index
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(sectionInfo, useAccordionSectionHeaderProps, useAccordionSectionBodyProps);
    });

    function defaultRenderButton(tag, makeButtonProps) {
      return function (modifyButtonProps) {
        return h$1(tag, modifyButtonProps(makeButtonProps({})));
      };
    }
    const Button = w(function Button(_ref) {
      let {
        tagButton,
        onPress,
        pressed,
        render,
        disabled,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref;
      const {
        useButtonProps
      } = useButton({
        button: {
          tagButton,
          onPress,
          pressed,
          disabled
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(useButtonProps);
    });

    function defaultRenderCheckboxLike(_ref) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        if (labelPosition == "wrapping") {
          const inputPropsBase = makeInputProps(info);
          const labelPropsBase = makeLabelProps(info);
          const inputProps = modifyInputProps(inputPropsBase);
          const {
            children,
            ...labelProps
          } = modifyLabelProps(labelPropsBase);
          const input = h$1(tagInput, inputProps);
          const label = h$1(tagLabel, { ...labelProps,
            children: o$1(p$1, {
              children: [input, children]
            })
          });
          return o$1(p$1, {
            children: label
          });
        } else if (labelPosition == "separate") {
          const inputProps = modifyInputProps(makeInputProps(info));
          const labelProps = modifyLabelProps(makeLabelProps(info));
          const input = h$1(tagInput, inputProps);
          const label = h$1(tagLabel, labelProps);
          return o$1(p$1, {
            children: [input, label]
          });
        } else {
          const userProps = makeInputProps(info);
          console.assert(!!userProps["aria-label"]);
          return h$1(tagInput, modifyInputProps(userProps));
        }
      };
    }
    function defaultRenderCheckbox(_ref2) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref2;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    const Checkbox = w(function Checkbox(_ref3) {
      let {
        checked,
        disabled,
        tagLabel,
        labelPosition,
        tagInput,
        onCheckedChange,
        render,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref3;
      const {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxInfo
      } = useCheckbox({
        checkbox: {
          onCheckedChange
        },
        checkboxLike: {
          checked,
          disabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        },
        hasFocusInput: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        hasFocusLabel: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange: onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount: onMount,
          onUnmount: onUnmount,
          onWindowFocusedChange
        }
      });
      const {
        useCheckboxInputElementProps
      } = useCheckboxInputElement();
      const {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement();
      return render(checkboxInfo, useCheckboxInputElementProps, useCheckboxLabelElementProps);
    });

    function defaultRenderCheckboxGroupChild(_ref) {
      let {
        tagInput,
        tagLabel,
        labelPosition,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        return defaultRenderCheckboxLike({
          labelPosition,
          tagInput,
          tagLabel,
          makeInputProps,
          makeLabelProps
        })(info, modifyInputProps, modifyLabelProps);
      };
    }
    function defaultRenderCheckboxGroup(_ref2) {
      let {
        children,
        labelPosition,
        makeInputProps,
        makeLabelProps,
        tagInput,
        tagLabel
      } = _ref2;
      return function (info, modifyInputProps, modifyLabelProps) {
        return o$1(p$1, {
          children: [defaultRenderCheckboxLike({
            labelPosition,
            makeInputProps,
            makeLabelProps,
            tagInput,
            tagLabel
          })(info, modifyInputProps, modifyLabelProps), children]
        });
      };
    }
    const UseCheckboxGroupChildContext = B$2(null);
    const CheckboxGroup = w(function CheckboxGroup(_ref3) {
      let {
        disabled: parentDisabled,
        tagInput,
        tagLabel,
        render,
        getDocument,
        getWindow,
        labelPosition,
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref3;
      const {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        ...checkboxGroupParentInfo
      } = useCheckboxGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useCheckboxGroupParentInputProps,
        useCheckboxGroupParentLabelProps
      } = useCheckboxGroupParentInput({
        checkbox: {},
        checkboxLike: {
          disabled: parentDisabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        },
        hasFocusInput: {
          getWindow,
          getDocument
        },
        hasFocusLabel: {
          getWindow,
          getDocument
        }
      });
      let wrapping;

      if (labelPosition == "separate") {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      } else {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      }

      return o$1(UseCheckboxGroupChildContext.Provider, {
        value: useCheckboxGroupChild,
        children: wrapping
      });
    });
    const CheckboxGroupCheckbox = w(function CheckboxGroupCheckbox(_ref4) {
      let {
        checked,
        disabled,
        index,
        labelPosition,
        tagInput,
        tagLabel,
        text,
        getWindow,
        getDocument,
        flags,
        focusSelf,
        hidden,
        onCheckedChange,
        render
      } = _ref4;
      const {
        useCheckboxGroupChildInputProps,
        useCheckboxGroupChildLabelProps,
        ...checkboxGroupChildInfo
      } = x(UseCheckboxGroupChildContext)({
        asCheckbox: {
          checkbox: {
            onCheckedChange
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          },
          hasFocusInput: {
            getWindow,
            getDocument
          },
          hasFocusLabel: {
            getWindow,
            getDocument
          }
        },
        asCheckboxGroupChild: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          }
        }
      });

      if (labelPosition == "separate") {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      } else {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      }
    });

    function defaultRenderPortal(_ref) {
      var _portalRef$current;

      let {
        portalId,
        children
      } = _ref;
      const portalRef = A(null);
      (_portalRef$current = portalRef.current) !== null && _portalRef$current !== void 0 ? _portalRef$current : portalRef.current = document.getElementById(portalId);
      if (portalRef.current) return $(children, portalRef.current);else return children;
    }
    function defaultRenderModal(_ref2) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref2;
      return function (dialogInfo, modifyFocusContainerProps, modifyDialogProps, modifyTitleProps, modifyBodyProps, modifyBackdropProps) {
        const {
          children: titleChildren,
          ...titleProps
        } = modifyTitleProps(makePropsTitle(dialogInfo));
        const {
          children: bodyChildren,
          ...bodyProps
        } = modifyBodyProps(makePropsBody(dialogInfo));
        const {
          children: dialogChildren,
          ...dialogProps
        } = modifyDialogProps(makePropsDialog(dialogInfo));
        const {
          children: backdropChildren,
          ...backdropProps
        } = modifyBackdropProps(makePropsBackdrop(dialogInfo));
        const {
          children: focusContainerChildren,
          ...focusContainerProps
        } = modifyFocusContainerProps(makePropsFocusContainer(dialogInfo));
        const title = h$1(tagTitle, titleProps, titleChildren);
        const body = h$1(tagBody, bodyProps, bodyChildren);
        const dialog = h$1(tagDialog, dialogProps, dialogChildren, title, body);
        const backdrop = h$1(tagBackdrop, backdropProps, backdropChildren);
        const focusContainer = h$1(tagFocusContainer, focusContainerProps, o$1("div", {
          children: [focusContainerChildren, dialog, backdrop]
        }));
        return defaultRenderPortal({
          portalId,
          children: focusContainer
        });
      };
    }
    function defaultRenderDialog(_ref3) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref3;
      return defaultRenderModal({
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      });
    }
    const Dialog = w(function Dialog(_ref4) {
      let {
        onClose,
        open,
        bodyIsOnlySemantic,
        getDocument,
        getWindow,
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        focusSelf,
        render
      } = _ref4;
      const {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle,
        useDialogFocusContainerProps,
        ...r
      } = useDialog({
        dialog: {
          onClose
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          open
        },
        activeElement: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onLastActiveElementChange,
          onWindowFocusedChange
        }
      });
      const {
        useDialogTitleProps
      } = useDialogTitle();
      const {
        useDialogBodyProps
      } = useDialogBody();
      const {
        useDialogBackdropProps
      } = useDialogBackdrop();
      return render(r, useDialogFocusContainerProps, useDialogProps, useDialogTitleProps, useDialogBodyProps, useDialogBackdropProps);
    });

    w(function Drawer(_ref2) {
      let {
        render,
        onClose,
        open,
        bodyIsOnlySemantic,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange
      } = _ref2;
      const {
        useDrawerBackdrop,
        useDrawerBody,
        useDrawerProps,
        useDrawerTitle,
        useDrawerFocusContainerProps,
        ...drawerInfo
      } = useDrawer({
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onLastActiveElementChange,
          onWindowFocusedChange
        }
      });
      const {
        useDrawerTitleProps
      } = useDrawerTitle();
      const {
        useDrawerBodyProps
      } = useDrawerBody();
      const {
        useDrawerBackdropProps
      } = useDrawerBackdrop();
      return render(drawerInfo, useDrawerFocusContainerProps, useDrawerProps, useDrawerTitleProps, useDrawerBodyProps, useDrawerBackdropProps);
    });

    const ListboxSingleContext = B$2(null);

    function ListboxSingleU(_ref) {
      let {
        render,
        selectedIndex,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        selectionMode,
        tagList,
        onSelect
      } = _ref;
      const {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps,
        ...listboxReturnType
      } = useListboxSingle({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxSingle: {
          tagLabel,
          tagList,
          onSelect
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex,
          selectionMode
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      });
      const {
        useListboxSingleLabelProps
      } = useListboxSingleLabel(); //const label = createElement(tagLabel, useListboxSingleLabelProps({}) as any);
      //const list = createElement(tagList, useListboxSingleProps({ children: vnodeChildren, ref }) as any);

      return o$1(ListboxSingleContext.Provider, {
        value: useListboxSingleItem,
        children: render({ ...listboxReturnType
        }, useListboxSingleLabelProps, useListboxSingleProps)
      });
    }

    function defaultRenderListboxSingle(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxSingleItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }

    function ListboxSingleItemU(_ref4) {
      let {
        index,
        disabled,
        flags,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render,
        text,
        hidden
      } = _ref4;
      const {
        useListboxSingleItemProps,
        rovingTabIndex,
        singleSelection
      } = x(ListboxSingleContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxSingleItem: {
          disabled
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return o$1(p$1, {
        children: render({
          rovingTabIndex,
          singleSelection
        }, useListboxSingleItemProps)
      });
    }

    const ListboxSingle = w(ListboxSingleU);
    const ListboxSingleItem = w(ListboxSingleItemU);
    w(ListboxGroupU);

    function ListboxGroupU(_ref5) {
      let {
        render
      } = _ref5;
      const {
        useListboxGroupHeadingProps,
        useListboxGroupContainerProps
      } = useListboxGroup();
      return render(useListboxGroupContainerProps, useListboxGroupHeadingProps);
    }
    function defaultRenderList(_ref7) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref7;
      return function (info, modifyPropsLabel, modifyPropsList) {
        const label = h$1(tagLabel, modifyPropsLabel(makePropsLabel(info)));
        const list = h$1(tagList, modifyPropsList(makePropsList(info)));
        return o$1(p$1, {
          children: [label, list]
        });
      };
    }
    function defaultRenderListItem(_ref8) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref8;
      return function (info, modifyPropsListItem) {
        return h$1(tagListItem, modifyPropsListItem(makePropsListItem(info)));
      };
    }

    const ListboxMultiContext = B$2(null);
    const ListboxMulti = w(function ListboxMulti(_ref) {
      let {
        render,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        tagList
      } = _ref;
      const {
        useListboxMultiItem,
        useListboxMultiLabel,
        useListboxMultiProps,
        ...listboxReturnType
      } = useListboxMulti({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxMulti: {
          tagLabel,
          tagList
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxMultiLabelProps
      } = useListboxMultiLabel();
      return o$1(ListboxMultiContext.Provider, {
        value: useListboxMultiItem,
        children: render(listboxReturnType, useListboxMultiLabelProps, useListboxMultiProps)
      });
    });
    function defaultRenderListboxMulti(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxMultiItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }
    const ListboxMultiItem = w(function ListboxMultiItem(_ref4) {
      let {
        index,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        selected,
        onSelectedChange,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref4;
      const {
        useListboxMultiItemProps,
        ...itemReturn
      } = x(ListboxMultiContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxMultiItem: {
          disabled,
          selected,
          onSelectedChange
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return o$1(p$1, {
        children: render(itemReturn, useListboxMultiItemProps)
      });
    });

    const MenuItemContext = B$2(null);
    const Menu = w(function Menu(_ref) {
      let {
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onOpen,
        onClose,
        open,
        openDirection,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        getDocument,
        getWindow,
        render
      } = _ref;
      const {
        useMenuButtonProps,
        useMenuItem,
        useMenuProps,
        useMenuSentinel,
        useMenuSurfaceProps,
        ...menuReturn
      } = useMenu({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        menu: {
          onOpen: useStableCallback(onOpen),
          openDirection
        },
        menuSurface: {},
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        softDismiss: {
          onClose: useStableCallback(onClose),
          open
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        activeElement: {
          getDocument,
          getWindow
        },
        menuButtonHasFocus: {
          getDocument,
          getWindow
        }
      });
      const {
        useMenuSentinelProps: useFirstSentinelProps
      } = useMenuSentinel();
      const {
        useMenuSentinelProps: useLastSentinelProps
      } = useMenuSentinel();
      return o$1(MenuItemContext.Provider, {
        value: useMenuItem,
        children: render(menuReturn, useMenuButtonProps, useMenuSurfaceProps, useMenuProps, useFirstSentinelProps, useLastSentinelProps)
      });
    });
    const MenuItem = w(function MenuItem(_ref2) {
      let {
        render,
        index,
        text,
        hidden,
        flags,
        focusSelf
      } = _ref2;
      const {
        useMenuItemProps,
        ...rest
      } = x(MenuItemContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        }
      });
      return render(rest, useMenuItemProps);
    });
    function defaultRenderMenu(_ref3) {
      let {
        portalId,
        tagButton,
        tagMenu,
        tagSurface,
        tagSentinel,
        makePropsButton,
        makePropsMenu,
        makePropsSurface,
        makePropsSentinel
      } = _ref3;
      return function (menuInfo, modifyMenuButtonProps, modifyMenuSurfaceProps, modifyMenuProps, modifyFirstSentinelProps, modifyLastSentinelProps) {
        const {
          children: surfaceChildren,
          ...surfaceProps
        } = modifyMenuSurfaceProps(makePropsSurface(menuInfo));
        const {
          children: menuChildren,
          ...menuProps
        } = modifyMenuProps(makePropsMenu(menuInfo));
        return o$1(p$1, {
          children: [h$1(tagButton, modifyMenuButtonProps(makePropsButton(menuInfo))), defaultRenderPortal({
            portalId,
            children: h$1(tagSurface, { ...surfaceProps,
              children: o$1(p$1, {
                children: [h$1(tagSentinel, modifyFirstSentinelProps(makePropsSentinel(menuInfo))), surfaceChildren, h$1(tagMenu, { ...menuProps,
                  children: o$1(p$1, {
                    children: menuChildren
                  })
                }), h$1(tagSentinel, modifyLastSentinelProps(makePropsSentinel(menuInfo)))]
              })
            })
          })]
        });
      };
    }
    function defaultRenderMenuItem(_ref4) {
      let {
        makePropsMenuItem: makePropsMenuItem,
        tagMenuItem
      } = _ref4;
      return function (info, modifyMenuItemProps) {
        return h$1(tagMenuItem, modifyMenuItemProps(makePropsMenuItem(info)));
      };
    }

    function defaultRenderRadioGroup(_ref) {
      let {
        tagGroup,
        tagLabel,
        makePropsGroup,
        makePropsLabel
      } = _ref;
      return function (info, modifyLabelProps, modifyGroupProps) {
        return o$1(p$1, {
          children: [h$1(tagLabel, modifyLabelProps(makePropsLabel(info))), h$1(tagGroup, modifyGroupProps(makePropsGroup(info)))]
        });
      };
    }
    const RadioContext = B$2(null);
    const RadioGroup = w(function RadioGroup(_ref2) {
      let {
        render,
        tagGroup,
        tagGroupLabel,
        name,
        onSelectedValueChange,
        selectedValue,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAllLostFocus,
        onAnyGainedFocus,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref2;
      const {
        useRadio,
        useRadioGroupLabelProps,
        useRadioGroupProps,
        ...radioGroupReturn
      } = useRadioGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        radioGroup: {
          name,
          onSelectedValueChange,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        singleSelection: {
          selectionMode: "focus"
        }
      });
      return o$1(RadioContext.Provider, {
        value: useRadio,
        children: render(radioGroupReturn, useRadioGroupLabelProps, useRadioGroupProps)
      });
    });
    function defaultRenderRadio(_ref3) {
      let {
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps,
        labelPosition
      } = _ref3;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    const Radio = w(function Radio(_ref4) {
      let {
        disabled,
        index,
        text,
        hidden,
        tagInput,
        labelPosition,
        tagLabel,
        value,
        render,
        flags,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref4;
      const {
        useRadioInput,
        useRadioLabel,
        ...radioReturn
      } = x(RadioContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        radio: {
          disabled,
          labelPosition,
          tagInput,
          tagLabel,
          value
        },
        rovingTabIndex: {
          hidden,
          focusSelf
        },
        hasFocusInput: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        hasFocusLabel: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      const {
        useRadioInputProps
      } = useRadioInput({
        tag: tagInput
      });
      const {
        useRadioLabelProps
      } = useRadioLabel({
        tag: tagLabel
      });
      return render(radioReturn, useRadioInputProps, useRadioLabelProps);
    });

    const SliderThumbContext = B$2(null);
    const Slider = w(function Slider(_ref) {
      let {
        max,
        min,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        children
      } = _ref;
      const {
        useSliderThumb,
        ..._sliderInfo
      } = useSlider({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        slider: {
          max,
          min
        }
      });
      return o$1(SliderThumbContext.Provider, {
        value: useSliderThumb,
        children: children
      });
    });
    const SliderThumb = w(function SliderThumbU(_ref2) {
      let {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        index,
        flags,
        render,
        valueText
      } = _ref2;
      const {
        useSliderThumbProps,
        ...sliderInfo
      } = x(SliderThumbContext)({
        managedChild: {
          index,
          flags
        },
        sliderThumb: {
          label,
          tag,
          value,
          max,
          min,
          onValueChange,
          valueText
        }
      });
      return render(sliderInfo, useSliderThumbProps);
    });
    function defaultRenderSliderThumb(_ref3) {
      let {
        tagThumb,
        makePropsThumb
      } = _ref3;
      return function (info, modifyThumbProps) {
        return h$1(tagThumb, modifyThumbProps(makePropsThumb(info)));
      };
    }

    const LocationContext = B$2(null);
    const TableSectionContext = B$2(null);
    const TableBodyContext = B$2(null);
    const TableRowContext = B$2(null);
    const TableCellContext = B$2(null);
    function defaultRenderTable(_ref) {
      let {
        tagTable,
        makePropsTable
      } = _ref;
      return function (info, modifyPropsTable) {
        return h$1(tagTable, modifyPropsTable(makePropsTable(info)));
      };
    }
    function defaultRenderTableBody(_ref2) {
      let {
        tagTableBody,
        makePropsTableBody
      } = _ref2;
      return function (info, modifyPropsTableBody) {
        return h$1(tagTableBody, modifyPropsTableBody(makePropsTableBody(info)));
      };
    }
    function defaultRenderTableHead(_ref3) {
      let {
        tagTableHead,
        makePropsTableHead
      } = _ref3;
      return function (modifyPropsTableHead) {
        return h$1(tagTableHead, modifyPropsTableHead(makePropsTableHead()));
      };
    }
    function defaultRenderTableRow(_ref5) {
      let {
        tagTableRow,
        makePropsTableRow
      } = _ref5;
      return function (info, modifyPropsTableRow) {
        return h$1(tagTableRow, modifyPropsTableRow(makePropsTableRow(info)));
      };
    }
    function defaultRenderTableCell(_ref6) {
      let {
        tagTableCell,
        makePropsTableCell
      } = _ref6;
      return function (info, modifyPropsTableCell) {
        return h$1(tagTableCell, modifyPropsTableCell(makePropsTableCell(info)));
      };
    }
    const Table = w(function TableU(_ref7) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref7;
      const {
        useTableBody,
        useTableProps,
        useTableRow,
        useTableSectionProps,
        ...tableInfo
      } = useTable({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(TableSectionContext.Provider, {
        value: useTableSectionProps,
        children: o$1(TableBodyContext.Provider, {
          value: useTableBody,
          children: o$1(TableRowContext.Provider, {
            value: useTableRow,
            children: render(tableInfo, useTableProps)
          })
        })
      });
    });
    const TableBody = w(function TableBodyU(_ref8) {
      let {
        render
      } = _ref8;
      const {
        useTableBodyProps,
        ...sectionInfo
      } = x(TableBodyContext)({});
      return o$1(LocationContext.Provider, {
        value: "body",
        children: render(sectionInfo, useTableBodyProps)
      });
    });
    const TableHead = w(function TableHeadU(_ref9) {
      let {
        render,
        tagTableHead
      } = _ref9;
      const useTableSectionPropsBase = x(TableSectionContext);

      const useTableSectionProps = props => useTableSectionPropsBase(tagTableHead, "head", props);

      return o$1(LocationContext.Provider, {
        value: "head",
        children: render(useTableSectionProps)
      });
    });
    w(function TableFootU(_ref10) {
      let {
        render,
        tagTableFoot
      } = _ref10;
      const useTableSectionPropsBase = x(TableSectionContext);

      const useTableSectionProps = props => useTableSectionPropsBase(tagTableFoot, "foot", props);

      return o$1(LocationContext.Provider, {
        value: "foot",
        children: render(useTableSectionProps)
      });
    });
    const TableRow = w(function TableRowU(_ref11) {
      let {
        index,
        text,
        tagTableRow,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref11;
      const {
        useTableCell,
        useTableRowProps,
        ...rowInfo
      } = x(TableRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        tableRow: {
          location: x(LocationContext),
          tagTableRow
        }
      });
      return o$1(TableCellContext.Provider, {
        value: useTableCell,
        children: render(rowInfo, useTableRowProps)
      });
    });
    const TableCell = w(function TableCell(_ref12) {
      let {
        index,
        text,
        flags,
        focusSelf,
        hidden,
        value,
        headerType,
        tagTableCell,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref12;
      const {
        useTableCellProps,
        ...cellInfo
      } = x(TableCellContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        subInfo: {
          location: x(LocationContext),
          value
        },
        tableCell: {
          headerType,
          tagTableCell
        }
      });
      return render(cellInfo, useTableCellProps);
    });

    const TabContext = B$2(null);
    const TabPanelContext = B$2(null);
    const Tabs = w(function Tabs(_ref) {
      let {
        selectedIndex,
        selectionMode,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        onSelectedIndexChange,
        render
      } = _ref;
      const {
        useTabList,
        useTabListLabel,
        useTabPanel,
        ...tabsInfo
      } = useTabs({
        tabPanels: {
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          }
        }
      });
      const {
        useTab,
        useTabListProps,
        ...tablistInfo
      } = useTabList({
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        tabs: {
          onSelectedIndexChange
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex,
          selectionMode
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useTabListLabelProps
      } = useTabListLabel({});
      return o$1(TabContext.Provider, {
        value: useTab,
        children: o$1(TabPanelContext.Provider, {
          value: useTabPanel,
          children: render({ ...tabsInfo,
            ...tablistInfo
          }, useTabListLabelProps, useTabListProps)
        })
      });
    });
    const Tab = w(function Tab(_ref2) {
      let {
        index,
        text,
        flags,
        focusSelf,
        hidden,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref2;
      const {
        useTabProps,
        ...tabInfo
      } = x(TabContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(tabInfo, useTabProps);
    });
    const TabPanel = w(function TabPanel(_ref3) {
      let {
        index,
        flags,
        render
      } = _ref3;
      const {
        useTabPanelProps,
        ...tabPanelInfo
      } = x(TabPanelContext)({
        managedChild: {
          index,
          flags
        }
      });
      return render(tabPanelInfo, useTabPanelProps);
    });
    function defaultRenderTabs(_ref4) {
      let {
        tagLabel,
        tagList,
        makePropsLabel,
        makePropsList,
        panels
      } = _ref4;
      return function (tabsInfo, modifyLabelProps, modifyListProps) {
        const label = h$1(tagLabel, modifyLabelProps(makePropsLabel(tabsInfo)));
        const list = h$1(tagList, modifyListProps(makePropsList(tabsInfo)));
        return o$1(p$1, {
          children: [label, list, panels]
        });
      };
    }
    function defaultRenderTab(_ref5) {
      let {
        makePropsTab,
        tagTab
      } = _ref5;
      return function (tabInfo, modifyTabProps) {
        return h$1(tagTab, modifyTabProps(makePropsTab(tabInfo)));
      };
    }
    function defaultRenderTabPanel(_ref6) {
      let {
        makePropsTabPanel,
        tagTabPanel
      } = _ref6;
      return function (tabPanelInfo, modifyTabPanelProps) {
        return h$1(tagTabPanel, modifyTabPanelProps(makePropsTabPanel(tabPanelInfo)));
      };
    }

    /*export function defaultRenderToasts({}: {}) {
        return function (args: UseToastsReturnTypeInfo, props: h.JSX.HTMLAttributes<ContainerType>) {
            return (
            <div>

            </div>
            )
        }
    }*/

    const ToastContext = B$2(null);
    const Toasts = w(function Toasts(_ref) {
      let {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render,
        visibleCount
      } = _ref;
      const {
        useToast,
        useToastContainerProps,
        ...info
      } = useToasts({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        toasts: {
          visibleCount
        }
      });
      return o$1(ToastContext.Provider, {
        value: useToast,
        children: render(info, useToastContainerProps({}))
      });
    });
    const Toast = w(function Toast(_ref2) {
      let {
        render,
        index,
        timeout,
        flags,
        politeness
      } = _ref2;
      const { ...toastInfo
      } = x(ToastContext)({
        managedChild: {
          index,
          flags
        },
        toast: {
          timeout,
          politeness
        }
      });
      return render(toastInfo);
    });

    function defaultRenderTooltip(_ref) {
      let {
        tagTooltip,
        tagTrigger,
        makeTooltipProps,
        makeTriggerProps,
        portalId
      } = _ref;
      return function (info, modifyPropsTrigger, modifyPropsTooltip) {
        return o$1(p$1, {
          children: [h$1(tagTrigger, modifyPropsTrigger(makeTriggerProps(info))), defaultRenderPortal({
            portalId,
            children: h$1(tagTooltip, modifyPropsTooltip(makeTooltipProps(info)))
          })]
        });
      };
    }
    const Tooltip = w(function TooltipU(_ref2) {
      let {
        focusDelay,
        mouseoutToleranceDelay,
        mouseoverDelay,
        getDocument,
        getWindow,
        render
      } = _ref2;
      const {
        useTooltipPopup,
        useTooltipTrigger,
        ...info
      } = useTooltip({
        focusDelay,
        mouseoutToleranceDelay,
        mouseoverDelay
      });
      const {
        useTooltipTriggerProps
      } = useTooltipTrigger({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      const {
        useTooltipPopupProps
      } = useTooltipPopup({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      return render(info, useTooltipTriggerProps, useTooltipPopupProps);
    });

    const LocationIndexContext = B$2(0);
    B$2(null);
    const GridlistSectionContext = B$2(null);
    const GridlistRowContext = B$2(null);
    const GridlistChildContext = B$2(null);
    function defaultRenderGridlist(_ref) {
      let {
        tagGridlist,
        makePropsGridlist
      } = _ref;
      return function (info, modifyPropsGridlist) {
        return h$1(tagGridlist, modifyPropsGridlist(makePropsGridlist(info)));
      };
    }
    function defaultRenderGridlistSection(_ref2) {
      let {
        tagGridlistSection,
        makePropsGridlistSection
      } = _ref2;
      return function (info, modifyPropsGridlistSection) {
        return h$1(tagGridlistSection, modifyPropsGridlistSection(makePropsGridlistSection(info)));
      };
    }
    function defaultRenderGridlistRow(_ref5) {
      let {
        tagGridlistRow,
        makePropsGridlistRow
      } = _ref5;
      return function (info, modifyPropsGridlistRow) {
        return h$1(tagGridlistRow, modifyPropsGridlistRow(makePropsGridlistRow(info)));
      };
    }
    function defaultRenderGridlistChild(_ref6) {
      let {
        tagGridlistChild,
        makePropsGridlistChild
      } = _ref6;
      return function (info, modifyPropsGridlistChild) {
        return h$1(tagGridlistChild, modifyPropsGridlistChild(makePropsGridlistChild(info)));
      };
    }
    const Gridlist = w(function GridlistU(_ref7) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref7;
      const {
        useGridlistSection,
        useGridlistProps,
        useGridlistRow,
        ...gridlistInfo
      } = useGridlist({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(GridlistSectionContext.Provider, {
        value: useGridlistSection,
        children: o$1(GridlistRowContext.Provider, {
          value: useGridlistRow,
          children: render(gridlistInfo, useGridlistProps)
        })
      });
    });
    const GridlistSection = w(function GridlistSectionU(_ref8) {
      let {
        render,
        compareRows,
        index
      } = _ref8;
      const {
        useGridlistSectionProps,
        ...sectionInfo
      } = x(GridlistSectionContext)({
        compareRows
      });
      return o$1(LocationIndexContext.Provider, {
        value: index,
        children: render(sectionInfo, useGridlistSectionProps)
      });
    });
    const GridlistRow = w(function GridlistRowU(_ref9, ref) {
      let {
        index,
        text,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref9;
      const {
        useGridlistChild,
        useGridlistRowProps,
        ...rowInfo
      } = x(GridlistRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        gridlistRow: {
          locationIndex: x(LocationIndexContext)
        }
      });
      return o$1(GridlistChildContext.Provider, {
        value: useGridlistChild,
        children: render(rowInfo, useGridlistRowProps)
      });
    });
    const GridlistChild = w(function GridlistChild(_ref10, ref) {
      let {
        index,
        text,
        flags,
        focusSelf,
        hidden,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref10;
      const {
        useGridlistChildProps,
        ...cellInfo
      } = x(GridlistChildContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        subInfo: {
          locationIndex: x(LocationIndexContext)
        }
      });
      return render(cellInfo, useGridlistChildProps);
    });

    function DemoAccordion({ children, ...props }) {
        return o$1(Accordion, { ...props, render: (_info) => { return o$1("div", { id: "accordion-demo", children: children }); } });
    }
    function getDocument$c() {
        return window.document;
    }
    const DemoAccordionSection = w(function DemoAccordionSection({ index, body, heading, disabled, open }) {
        return o$1(AccordionSection, { index: index, tagButton: "button", open: open, disabled: disabled, getDocument: getDocument$c, render: defaultRenderAccordionSection({
                makePropsBody: (info) => { return { hidden: !info.accordionSection.expanded, children: body }; },
                makePropsHeading: () => { return { children: heading }; },
                tagBody: "div",
                tagHeading: "button"
            }) });
    });
    function Blurb$e() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/", children: "In accordance with the ARIA guidelines for Accordion patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Each section's header and body are linked via ID; the body is ", o$1("code", { children: "labelled-by" }), " the header and the header ", o$1("code", { children: "control" }), "s the body."] }), o$1("li", { children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used." }), o$1("li", { children: ["If the header element is not a ", o$1("code", { children: "<button>" }), " element, it is given that ", o$1("code", { children: "role" }), "."] }), o$1("li", { children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab" }), o$1("li", {})] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["The ", o$1("code", { children: "render" }), " prop each ", o$1("code", { children: "AccordionSection" }), " takes must wrap the header button with a ", o$1("a", { href: "https://w3c.github.io/aria/#heading", children: "heading" }), " (e.g. ", o$1("code", { children: "h3" }), ", or ", o$1("code", { children: "<Heading>" }), "). See the default implementation for an example."] }) })] }));
    }
    function Code$e() {
        return (o$1("code", { children: `<Accordion render={...}>
    <AccordionSection index={0} render={...} />
    <AccordionSection index={1} render={...} />
    <AccordionSection index={2} render={...} />
</Accordion>` }));
    }
    function Demo$e() {
        const [count, setCount] = y(5);
        return (o$1(p$1, { children: [o$1(Blurb$e, {}), o$1(Code$e, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of accordion sections"] }), o$1(DemoAccordion, { children: o$1(p$1, { children: Array.from((function* () {
                            yield o$1(DemoAccordionSection, { index: 0, heading: "Accordion section #0", body: "Body content #0", disabled: false });
                            yield o$1(DemoAccordionSection, { index: 1, heading: "Accordion section #1", body: "Body content #1", disabled: false });
                            yield o$1(DemoAccordionSection, { index: 2, heading: "Accordion section #2 (disabled)", body: "Body content #2", disabled: true });
                            yield o$1(DemoAccordionSection, { index: 3, heading: "Accordion section #3 (forced open)", body: "Body content #3", disabled: false, open: true });
                            yield o$1(DemoAccordionSection, { index: 4, heading: "Accordion section #4 (forced closed)", body: "Body content #4", disabled: false, open: false });
                            for (let i = 5; i < count; ++i) {
                                yield o$1(DemoAccordionSection, { index: i, heading: `Accordion section #${i}`, body: `BodyContent #${i}`, disabled: false });
                            }
                        })()).slice(0, count) }) })] }));
    }

    function getDocument$b() {
        return window.document;
    }
    function Blurb$d() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/", children: "In accordance with the ARIA guidelines for Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Whether using an actual ", o$1("code", { children: "<button>" }), ", or something else like a ", o$1("code", { children: "<div>" }), ", the proper roles and event handlers will be applied."] }), o$1("li", { children: "Buttons can be toggled (pressed or unpressed)." }), o$1("li", { children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", { children: [o$1("li", { children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click" }), o$1("li", { children: "When Enter is pressed, the button is immediately activated" }), o$1("li", { children: "When Space is pressed, the button is activated once released" }), o$1("li", { children: "iOS Safari properly focuses the button" })] })] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", { children: "aria-label" }), " manually stating what happens when the button is pressed."] }) })] }));
    }
    function Code$d() {
        return (o$1("code", { children: `<Button tag="button">Button</Button>
    <Button tag="div">Div</Button>` }));
    }
    function Demo$d() {
        const [pressed, setPressed] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$d, {}), o$1(Code$d, {}), o$1(DemoButton, { disabled: false, tag: "button" }), o$1(DemoButton, { disabled: "soft", tag: "button" }), o$1(DemoButton, { disabled: "hard", tag: "button" }), o$1(DemoButton, { disabled: false, tag: "div" }), o$1(DemoButton, { disabled: "soft", tag: "div" }), o$1(DemoButton, { disabled: "hard", tag: "div" }), o$1(Button, { getDocument: getDocument$b, disabled: false, tagButton: "button", pressed: pressed, onPress: e => setPressed(e[EventDetail].pressed ?? false), render: defaultRenderButton("button", () => ({ children: `Toggle button (${pressed ? "pressed" : "unpressed"})` })) })] }));
    }
    function DemoButton({ tag, disabled }) {
        const onPress = () => { alert("Button clicked"); };
        return (o$1(Button, { getDocument: getDocument$b, tagButton: tag, onPress: onPress, render: defaultRenderButton(tag, () => ({ class: "btn", children: `${tag} ${disabled ? ` disabled (${disabled == "soft" ? "soft" : "hard"})` : ""}` })) }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <Button disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$c() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/", children: "In accordance with the ARIA guidelines for Checkbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)" }), o$1("li", { children: ["Can be ", o$1("code", { children: "mixed" }), " instead, though ", o$1("code", { children: "onInput" }), " will only ever be called with ", o$1("code", { children: "true" }), " or ", o$1("code", { children: "false" })] }), o$1("li", { children: ["Supports using ", o$1("code", { children: "<input>" }), "s and ", o$1("code", { children: "<label>" }), "s, as well as just plain ol' ", o$1("code", { children: "<div>" }), "s on either/both"] }), o$1("li", { children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element." }), o$1("li", { children: "When selecting the text of a checkbox's label, this does not change the checkbox's state" }), o$1("li", { children: "Double-clicking the label checks & un-checks the checkbox instead of selecting the label's text" }), o$1("li", { children: "Checkbox groups (with a tri-state parent) are a separate component/hook" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }) })] }));
    }
    function Code$c() {
        return (o$1("code", { children: `<Checkbox checked={true} labelPosition="separate" tagInput="input" tagLabel="label">Label text</Checkbox>` }));
    }
    function Demo$c() {
        const [checked, setChecked] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$c, {}), o$1(Code$c, {}), o$1(Button, { tagButton: "button", getDocument: getDocument$a, onPress: () => { setChecked("mixed"); }, render: defaultRenderButton("button", () => ({ children: "Change to mixed" })) }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "hidden", disabled: false, tagInput: "input", tagLabel: "label" })] }));
    }
    function DemoCheckbox$1({ labelPosition, tagInput, tagLabel, disabled, checked, setChecked }) {
        //const [checked, setChecked] = useState(false);
        return (o$1("div", { style: { border: "1px solid black" }, children: [o$1(Checkbox, { getDocument: getDocument$a, disabled: disabled, checked: checked, onCheckedChange: e => setChecked(e[EventDetail].checked), labelPosition: labelPosition == "hidden" ? "separate" : labelPosition, tagInput: tagInput, tagLabel: tagLabel, render: defaultRenderCheckbox({
                        labelPosition,
                        tagInput,
                        tagLabel,
                        makeInputProps: () => ({ "aria-label": labelPosition == "hidden" ? `Hidden label (technically separate), ${tagInput} and ${tagLabel} ${checked ? "checked" : "not checked"}` : undefined, }),
                        makeLabelProps: () => ({ children: `${labelPosition}, ${tagInput} and ${tagLabel}, ${checked ? "checked" : "not checked"}` })
                    }) }), labelPosition == "hidden" && o$1("div", { children: ["(This is not a label -- the actual label is via the ", o$1("code", { children: "aria-label" }), " prop)"] })] }));
    }
    function getDocument$a() {
        return window.document;
    }

    function getDocument$9() {
        return window.document;
    }
    function DemoCheckbox({ index }) {
        const [checked, setChecked] = useState(false);
        const labelText = `Checkbox #${index}`;
        return (o$1(CheckboxGroupCheckbox, { render: defaultRenderCheckboxGroupChild({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({}),
                makeLabelProps: () => ({ children: labelText })
            }), getDocument: getDocument$9, checked: checked, index: index, disabled: false, labelPosition: "separate", text: labelText, tagInput: "input", tagLabel: "label", onCheckedChange: e => setChecked(e[EventDetail].checked) }));
    }
    function Blurb$b() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", { children: "checkboxgroup" }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."] }), o$1("ul", { children: [o$1("li", { children: ["All normal ", o$1("code", { children: "Checkbox" }), " functionality is supported on each individual checkbox."] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$b() {
        return (o$1("code", { children: `` }));
    }
    function Demo$b() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$b, {}), o$1(Code$b, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of checkboxes"] }), o$1("div", { children: o$1(CheckboxGroup, { getDocument: getDocument$9, disabled: false, labelPosition: "separate", tagInput: "input", tagLabel: "label", render: defaultRenderCheckboxGroup({
                            labelPosition: "separate",
                            tagInput: "input",
                            tagLabel: "label",
                            makeInputProps: () => ({}),
                            makeLabelProps: () => ({ children: "Group checkbox parent" }),
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoCheckbox, { index: i }, i) });
                                }
                            })())
                        }) }) })] }));
    }

    function getDocument$8() {
        return window.document;
    }
    const DemoListItem$2 = w(function DemoListItem({ index }) {
        const [selected, setSelected] = useState(false);
        const labelText = `List item #${index}${selected ? " (selected)" : ""}`;
        return (o$1(ListboxMultiItem, { getDocument: getDocument$8, selected: selected, index: index, disabled: false, text: labelText, onSelectedChange: e => { setSelected(e[EventDetail].selected); }, render: defaultRenderListboxMultiItem({ tagListItem: "li", makePropsListItem: () => ({ children: labelText }) }) }));
    });
    function Blurb$a() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$a() {
        return (o$1("code", { children: `` }));
    }
    function Demo$a() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$a, {}), o$1(Code$a, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxMulti, { tagLabel: "label", tagList: "ul", render: defaultRenderListboxMulti({
                            tagLabel: "label", tagList: "ul", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: Array.from((function* () {
                                    for (let i = 0; i < count; ++i) {
                                        yield o$1(DemoListItem$2, { index: i }, i);
                                    }
                                })())
                            })
                        }) }) })] }));
    }

    function getDocument$7() { return window.document; }
    const DemoListItem$1 = w(function DemoListItem({ index }) {
        return (o$1(ListboxSingleItem, { index: index, getDocument: getDocument$7, disabled: false, text: `List item #${index}`, render: defaultRenderListboxSingleItem({ tagListItem: "li", makePropsListItem: ({ singleSelection: { selected } }) => ({ children: `List item #${index}${selected ? " (selected)" : ""}` }) }) }));
    });
    function Blurb$9() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["In terms of keyboard navigation and tabbing through elements, a Listbox is considered a ", o$1("strong", { children: "single" }), " tab stop; in other words, no matter how many list items there are in a Listbox, it only takes one press of the Tab button to go through it.", o$1("ul", { children: [o$1("li", { children: "When a Listbox is tabbed into, the most recently selected item is given focus" }), o$1("li", { children: "Pressing Tab again navigates out of the listbox; no other list items are tabbable other than the one currently designated." }), o$1("li", { children: "Pressing the arrow keys navigates through the Listbox one item at a time" }), o$1("li", { children: "Pressing the Home/End keys move focus to the first/last items respectively" }), o$1("li", { children: "Typing any sequence of text starts typeahead that navigates to the next item that matches what's being typed" }), o$1("li", { children: "Focus & selection management is as optimized as possible; only two children re-render at a time when focus or selection changes" }), o$1("li", { children: "These apply generally to all composite components with a variable number of children (Tab Lists, Radio Groups, Multi-Select Listboxes etc.)" })] })] }), o$1("li", { children: ["Rather than each individual list item knowing whether it is selected or not (as with multi-select lists), here the parent knows the ", o$1("code", { children: "selectedIndex" }), " and simply notifies the (max two) relevant children any time it changes."] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "Listboxes do not support interactive content within them (e.g. a dropdown menu), as ARIA specifies that this is a different pattern." }) })] }));
    }
    function Code$9() {
        return (o$1("code", { children: `` }));
    }
    function Demo$9() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$9, {}), o$1(Code$9, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxSingle, { render: defaultRenderListboxSingle({
                            tagLabel: "label", tagList: "ol", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoListItem$1, { index: i }, i);
                                        }
                                    })()) })
                            })
                        }), selectionMode: "activation", tagLabel: "label", tagList: "ol", selectedIndex: selectedIndex, onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex) }) })] }));
    }

    function DemoListItem({ index }) {
        return (o$1(MenuItem, { index: index, text: `List item #${index}`, render: defaultRenderMenuItem({ tagMenuItem: "li", makePropsMenuItem: () => ({ children: `Menu item #${index}` }) }) }));
    }
    function getDocument$6() { return window.document; }
    function Blurb$8() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$8() {
        return (o$1("code", { children: `` }));
    }
    function Demo$8() {
        const [count, setCount] = useState(5);
        const [open, setOpen] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$8, {}), o$1(Code$8, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of menu items"] }), o$1("div", { children: o$1(Menu, { getDocument: getDocument$6, onOpen: () => setOpen(true), onClose: () => setOpen(false), open: open, openDirection: "down", render: defaultRenderMenu({
                            tagButton: "button",
                            tagMenu: "ul",
                            tagSentinel: "div",
                            tagSurface: "div",
                            portalId: "portal",
                            makePropsButton: () => ({ children: "Open menu" + (open ? " (open)" : " (closed)") }),
                            makePropsMenu: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1("div", { children: o$1(DemoListItem, { index: i }, i) });
                                        }
                                    })()) })
                            }),
                            makePropsSurface: () => ({ style: { display: !open ? "none" : undefined } }),
                            makePropsSentinel: () => ({}),
                        }) }) })] }));
    }

    function getDocument$5() {
        return window.document;
    }
    const DemoRadioButton = w(function DemoRadioButton({ index }) {
        const value = `Radio button #${index}`;
        return (o$1(Radio, { index: index, getDocument: getDocument$5, disabled: false, labelPosition: "separate", text: value, value: index, tagInput: "input", tagLabel: "label", render: defaultRenderRadio({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({ name: "radio-demo" }),
                makeLabelProps: () => ({ children: value })
            }) }));
    });
    function Blurb$7() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/", children: "In accordance with the ARIA guidelines for Radio Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The input & label support the same text-selection affordances as Checkboxes (labels can be selected, but double-clicking doesn't select the text and selecting text doesn't count as an input)" }), o$1("li", { children: "Selection state is handled by the parent; instead of specifying whether any given radio button is checked or not, the parent notifies each child of the necessary changes." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }), o$1("li", { children: ["The above also applies to the radio group as a whole; ARIA requires that all Radio Buttons be contained within an element with a specific role which is labelled either by an element (handled for you) or ", o$1("code", { children: "aria-label" }), " (specified by you manually on the input)."] })] })] }));
    }
    function Code$7() {
        return (o$1("code", { children: `` }));
    }
    function Demo$7() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$7, {}), o$1(Code$7, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of radio buttons"] }), o$1("div", { children: o$1(RadioGroup, { name: "radio-demo", onSelectedValueChange: e => setSelectedIndex(e[EventDetail].selectedValue ?? 0), selectedValue: selectedIndex, tagGroupLabel: "label", tagGroup: "div", render: defaultRenderRadioGroup({
                            tagGroup: "div",
                            tagLabel: "label",
                            makePropsGroup: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoRadioButton, { index: i }, i);
                                        }
                                    })()) })
                            }),
                            makePropsLabel: (info) => ({ children: "Radio group example " + "(" + info.radioGroup.selectedIndex?.toString() + ")" })
                        }) }) })] }));
    }

    function DemoSliderThumb({ index }) {
        const [value, setValue] = useState(0);
        return (o$1(SliderThumb, { index: index, tag: "input", label: `Slider thumb #${index}`, value: value, onValueChange: e => setValue(e[EventDetail].value), min: 0, max: 10, render: defaultRenderSliderThumb({ tagThumb: "input", makePropsThumb: () => ({}) }) }));
    }
    function Blurb$6() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$6() {
        return (o$1("code", { children: `` }));
    }
    function Demo$6() {
        const [count, setCount] = useState(5);
        useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$6, {}), o$1(Code$6, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of slider thumbs"] }), o$1("div", { children: o$1(Slider, { min: 0, max: 10, children: o$1(p$1, { children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoSliderThumb, { index: i }, i) });
                                }
                            })()) }) }) })] }));
    }

    function getDocument$4() { return window.document; }
    function Blurb$5() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/", children: "In accordance with the ARIA guidelines for Modal Dialog patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Dialogs block all other elements on the page from receiving focus/interaction and being perceivable to screen readers." }), o$1("li", { children: "Dialogs can be dismissed by pressing Escape or clicking the element designated as the backdrop, both of which can be cancelled/ignored if you need" }), o$1("li", { children: "When opened, the dialog will focus its title or body content as appropriate, however read below under Things Not Handled for caveats." }), o$1("li", { children: "When closed for any reason, the element that was responsible for opening the dialog will be focused." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["By default, when opened, a dialog will focus its body content or title content depending on ", o$1("code", { children: "bodyIsOnlySemantic" }), ", which indicates that the dialog's body contains no interactive elements. This may not be suitable for all situations."] }), o$1("li", { children: ["It is ", o$1("em", { children: "hightly" }), " recommended to override ", o$1("code", { children: "focusSelf" }), " for all dialogs you create, and have it focus whatever element makes the most sense for your particular dialog.", o$1("ul", { children: [o$1("li", { children: "Dialogs that act like a form should focus the first interactive element" }), o$1("li", { children: "Dialogs that perform destructive actions should focus the \"Cancel\" button" }), o$1("li", { children: "In some cases, it's best to focus the first paragraph of the body." })] }), "In all cases, consider that the first focused element will both be how keyboard users interact with the dialog, but also the first thing a screen reader will read aloud."] })] })] }));
    }
    function Code$5() {
        return (o$1("code", { children: `` }));
    }
    function Demo$5() {
        const [open, setOpen] = useState(false);
        q$1((...args) => { console.log(...args); }, []);
        return (o$1(p$1, { children: [o$1(Blurb$5, {}), o$1(Code$5, {}), o$1("div", { children: [o$1(Button, { tagButton: "button", getDocument: getDocument$4, onPress: () => setOpen(true), render: defaultRenderButton("button", () => ({ children: "Open dialog " + (open ? "(open)" : "(closed)") })) }), o$1(Dialog, { getDocument: getDocument$4, onClose: () => setOpen(false), open: open, bodyIsOnlySemantic: true, render: defaultRenderDialog({
                                portalId: "portal",
                                makePropsBackdrop: () => ({ "data-type": "backdrop" }),
                                makePropsFocusContainer: () => ({ "data-type": "focus" }),
                                makePropsBody: () => ({ children: "Dialog body", "data-type": "body" }),
                                makePropsDialog: () => ({ style: { display: !open ? "none" : undefined }, "data-type": "dialog" }),
                                makePropsTitle: () => ({ children: "Dialog title", "data-type": "title" }),
                                tagBackdrop: "div",
                                tagBody: "div",
                                tagDialog: "div",
                                tagTitle: "div",
                                tagFocusContainer: "div"
                            }) })] })] }));
    }

    function getDocument$3() { return window.document; }
    function Blurb$4() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/", children: "In accordance with the ARIA guidelines for Tab and Tab Panel patterns," }), " this widget supports the following:"] }), o$1("ul", { children: o$1("li", { children: ["The tabs are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }) }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$4() {
        return (o$1("code", { children: `` }));
    }
    function Demo$4() {
        const [count, setCount] = useState(5);
        const [selectedIndex, setSelectedIndex] = useState(0);
        return (o$1(p$1, { children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of tabs"] }), o$1("div", { children: o$1(Tabs, { selectedIndex: selectedIndex, selectionMode: "focus", onSelectedIndexChange: e => setSelectedIndex(e[EventDetail].selectedIndex), render: defaultRenderTabs({
                            panels: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1(DemoTabPanel, { i: i });
                                }
                            })()),
                            tagLabel: "label",
                            tagList: "ul",
                            makePropsLabel: () => ({ children: "Tabs example" }),
                            makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoTab, { i: i });
                                        }
                                    })()) })
                            })
                        }) }) })] }));
    }
    const DemoTab = w(function DemoTab({ i }) {
        const label = `Tab #${i}`;
        return o$1(Tab, { index: i, getDocument: getDocument$3, render: defaultRenderTab({ tagTab: "li", makePropsTab: () => ({ children: label }) }), text: label }, i);
    });
    const DemoTabPanel = w(function DemoTabPanel({ i }) {
        const label = `Tab panel #${i}`;
        return o$1(TabPanel, { index: i, render: defaultRenderTabPanel({ tagTabPanel: "div", makePropsTabPanel: ({ tabPanel: { visible } }) => ({ hidden: !visible, children: label }) }) }, i);
    });

    function getDocument$2() { return window.document; }
    function Blurb$3() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/", children: "Tooltips have yet to be well defined in many areas" }), ", but this implementation aims to support common use cases:"] }), o$1("ul", { children: [o$1("li", { children: "Hovering or focusing the trigger element shows the tooltip" }), o$1("li", { children: "The tooltip stays shown when it itself is hovered/focused as well, so that the text inside can be selected" }), o$1("li", { children: "Moving the mouse between the trigger and the tooltip has some tolerance associated with immediately hiding the tooltip." }), o$1("li", { children: "Hovering, focusing, and re-hovering can each have a custom delay associated with it" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["You must ensure that either the tooltip contains a focusable element (a button, link, ", o$1("code", { children: "<div tabIndex=\"-1\" />" }), ", etc.)"] }), o$1("li", { children: "Long presses on mobile devices are not yet handled (e.g. a long press on a button triggers a tooltip but does not activate the button)" })] })] }));
    }
    function Code$3() {
        return (o$1("code", { children: `` }));
    }
    function Demo$3() {
        return (o$1(p$1, { children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1("div", { children: ["The following text triggers a tooltip: ", o$1(Tooltip, { getDocument: getDocument$2, render: defaultRenderTooltip({
                                portalId: "portal",
                                makeTooltipProps: ({ isOpen }) => ({ children: "This text describes the triggering text in more detail.", style: { opacity: +isOpen } }),
                                makeTriggerProps: () => ({ children: "Tooltip-triggering text that is hoverable and focusable:", tabIndex: 0 }),
                                tagTooltip: "div",
                                tagTrigger: "span"
                            }) })] })] }));
    }

    function Blurb$2() {
        return (o$1(p$1, { children: [o$1("p", { children: o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/alert/", children: "Toasts (aka snackbars) are implemented using the Alert pattern." }) }), o$1("ul", { children: [o$1("li", { children: "Pushing a toasts causes its contents to be shown visibly (and audibly with a screen reader)" }), o$1("li", { children: "Only new toasts are announced" }), o$1("li", { children: "Toasts are shown as soon as they are pushed, but you can control the maximum number shown at once with" }), o$1("li", { children: "Toasts can be dismissed in any order" }), o$1("li", { children: "Toasts can be set to auto-dismiss." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: "Auto-dismiss behavior is very situational. An auto-dismissed toast should only refer to information that can be viewed elsewhere; \"X files deleted\" can be double-checked in the Recycle Bin, \"X has logged in\" which you can along with everyone else in a tab somewhere, etc. This obviously cannot be checked programmatically." }), o$1("li", { children: "TODO: Focus management related to toasts that have interactive content" }), o$1("li", { children: "TODO: Toasts are still announced even when the current browser tab is hidden instead of saving them for when the user returns" }), o$1("li", { children: "TODO: Toasts still auto-dismiss when they have focus/are being interacted with" })] })] }));
    }
    function Code$2() {
        return (o$1("code", { children: `` }));
    }
    function Demo$2() {
        const currentIndex = A(0);
        const [toasts, setToasts] = useState([]);
        const pushToast = q$1(() => {
            const index = currentIndex.current;
            currentIndex.current += 1;
            setToasts(t => [...t, o$1(Toast, { index: index, render: ({ toast: { dismiss, showing, dismissed, numberOfToastsAheadOfUs } }) => (o$1("div", { style: showing ? {} : { opacity: 0.5 }, children: ["This the toast with an index of ", index, ". (#", numberOfToastsAheadOfUs, " in the queue to be shown). ", o$1("button", { disabled: dismissed, onClick: dismiss, children: "Click to dismiss" })] })), timeout: null }, index)]);
        }, []);
        return (o$1(p$1, { children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1("button", { onClick: pushToast, children: "Push a toast" }), o$1("div", { children: o$1(Toasts, { visibleCount: 3, render: (info, props) => { return o$1("div", { ...props, children: toasts }); } }) })] }));
    }

    function getDocument$1() { return window.document; }
    function Blurb$1() {
        return (o$1(p$1, { children: [o$1("p", { children: ["This is an implementation of an interactive data table that complies with ", o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/table/", children: "the ARIA guidelines for Table patterns" }), "."] }), o$1("ul", { children: [o$1("li", { children: ["In terms of keyboard navigation and tabbing through elements, a Table is considered a ", o$1("strong", { children: "single" }), " tab stop; in other words, no matter how many cells there are in a table (including if the cells contain interactive elements), it only takes one press of the Tab button to go through it.", o$1("ul", { children: [o$1("li", { children: ["Pressing the arrow keys navigates through the cells of the Table. You can override each cell's ", o$1("code", { children: "focusSelf" }), " prop to handle child elements."] }), o$1("li", { children: "Most other rules of list navigation apply (as in Listboxes), but in two dimensions." })] })] }), o$1("li", { children: ["The body rows are sortable via each cell's ", o$1("code", { children: "value" }), " prop. As a result of this, each row must be a ", o$1("em", { children: "direct" }), " child of the body, like as a normal array of children with no intervening JSX."] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["If you don't need all the sorting and focus management and such, there's no reason not to just use the good old ", o$1("code", { children: "<table>" }), " element."] }), o$1("li", { children: ["It's up to you to make sure that any interactive elements within a table cell respond to focus management properly with the aforementioned ", o$1("code", { children: "focusSelf" }), " prop and a properly placed ", o$1("code", { children: ["tabIndex=", "{", "info.rovingTabIndex.tabbable? 0 : -1", "}"] }), " in the ", o$1("code", { children: "render" }), " prop."] })] })] }));
    }
    function Code$1() {
        return (o$1("code", { children: `` }));
    }
    function DemoInput({ tabbable }) {
        const [v, setV] = useState("");
        return (o$1("input", { type: "text", tabIndex: tabbable ? 0 : -1, onInput: q$1((e) => {
                setV(e.currentTarget.value);
                e.preventDefault();
            }, []), value: v }));
    }
    function DemoTableCell({ index, header }) {
        const r = A(Math.random());
        if (header) {
            const text = `Header #${index}`;
            return o$1(TableCell, { headerType: "column", tagTableCell: "th", index: index, getDocument: getDocument$1, text: text, value: text, render: defaultRenderTableCell({ tagTableCell: "th", makePropsTableCell: (info) => ({ children: o$1("button", { tabIndex: info.rovingTabIndex.tabbable ? 0 : -1, onClick: () => info.tableHeaderCell.sort(), children: text }) }) }) });
        }
        else {
            switch (index) {
                case 0:
                    return o$1(TableCell, { headerType: null, tagTableCell: "td", index: index, getDocument: getDocument$1, text: "", value: "", render: defaultRenderTableCell({
                            tagTableCell: "td", makePropsTableCell: (info) => ({
                                children: o$1(DemoInput, { tabbable: info.rovingTabIndex.tabbable })
                            })
                        }) });
                default:
                    return o$1(TableCell, { headerType: null, tagTableCell: "td", index: index, getDocument: getDocument$1, text: r.current.toString(), value: r.current.toString(), render: defaultRenderTableCell({ tagTableCell: "td", makePropsTableCell: () => ({ children: r.current.toString() }) }) });
            }
        }
    }
    function Demo$1() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of table rows"] }), o$1("div", { children: o$1(Table, { noTypeahead: true, render: defaultRenderTable({
                            tagTable: "table",
                            makePropsTable: () => ({
                                children: o$1(p$1, { children: [o$1(TableHead, { tagTableHead: "thead", render: defaultRenderTableHead({
                                                tagTableHead: "thead",
                                                makePropsTableHead: () => ({
                                                    children: o$1(TableRow, { tagTableRow: "tr", noTypeahead: true, index: 0, text: "", render: defaultRenderTableRow({
                                                            tagTableRow: "tr",
                                                            makePropsTableRow: () => ({
                                                                children: o$1(p$1, { children: [o$1(DemoTableCell, { index: 0, header: true }, 0), o$1(DemoTableCell, { index: 1, header: true }, 1), o$1(DemoTableCell, { index: 2, header: true }, 2)] })
                                                            })
                                                        }) })
                                                })
                                            }) }), o$1(TableBody, { render: defaultRenderTableBody({
                                                tagTableBody: "tbody",
                                                makePropsTableBody: () => ({
                                                    children: Array.from(function* () {
                                                        for (let i = 0; i < count; ++i) {
                                                            yield o$1(TableRow, { tagTableRow: "tr", noTypeahead: true, index: i + 1, text: "", render: defaultRenderTableRow({
                                                                    tagTableRow: "tr",
                                                                    makePropsTableRow: () => ({
                                                                        children: o$1(p$1, { children: [o$1(DemoTableCell, { index: 0 }, 0), o$1(DemoTableCell, { index: 1 }, 1), o$1(DemoTableCell, { index: 2 }, 2)] })
                                                                    })
                                                                }) }, i);
                                                        }
                                                    }())
                                                })
                                            }) })] })
                            })
                        }) }) })] }));
    }

    function getDocument() { return window.document; }
    function Blurb() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Because Listboxes are not allowed to contain interactive content, a Gridlist is semantically a list that ", o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/grid/", children: "complies with the ARIA pattern for grids" }), "."] }), o$1("ul", { children: [o$1("li", { children: "In terms of keyboard navigation and tabbing through elements, a Gridlist is like a Listbox, but in two dimensions, like a Table." }), o$1("li", { children: "The rows of a Gridlist are sortable. It is possible to have multiple, independently sortable sections within the same Gridlist." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It's up to you to make sure that any interactive elements within a Gridlist respond to focus management properly with ", o$1("code", { children: "focusSelf" }), " prop and a properly placed ", o$1("code", { children: ["tabIndex=", "{", "info.rovingTabIndex.tabbable? 0 : -1", "}"] }), " in the ", o$1("code", { children: "render" }), " prop."] }), o$1("li", { children: "Any given row in a Gridlist can be marked as selected, but this is up to you to handle manually at the moment" })] })] }));
    }
    function Code() {
        return (o$1("code", { children: `` }));
    }
    function DemoGridlistChild1({ row }) {
        const text = "Gridlist child " + row;
        return o$1(GridlistChild, { getDocument: getDocument, index: 0, locationIndex: 0, text: text, render: defaultRenderGridlistChild({ tagGridlistChild: "div", makePropsGridlistChild: (info) => ({ children: text }) }) });
    }
    function DemoGridlistChild2() {
        const ref = A(null);
        const [b, setB] = useState(false);
        return o$1(GridlistChild, { focusSelf: () => ref.current?.focus(), getDocument: getDocument, index: 1, locationIndex: 0, text: b.toString(), render: defaultRenderGridlistChild({ tagGridlistChild: "div", makePropsGridlistChild: (info) => ({ children: o$1("input", { ref: ref, type: "checkbox", tabIndex: info.rovingTabIndex.tabbable ? 0 : -1, checked: b, onInput: e => setB(e.currentTarget.checked) }) }) }) });
    }
    function Demo() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of table rows"] }), o$1("div", { children: o$1(Gridlist, { initialIndex: 0, render: defaultRenderGridlist({
                            tagGridlist: "div", makePropsGridlist: (info) => ({
                                children: o$1(GridlistSection, { index: 0, compareRows: (lhs, rhs) => lhs - rhs, render: defaultRenderGridlistSection({
                                        tagGridlistSection: "div", makePropsGridlistSection: (info) => ({
                                            children: Array.from(function* () {
                                                for (let i = 0; i < count; ++i) {
                                                    yield o$1(GridlistRow, { index: i, text: "", render: defaultRenderGridlistRow({
                                                            tagGridlistRow: "div", makePropsGridlistRow: (info) => ({
                                                                children: [o$1(DemoGridlistChild1, { row: i }), o$1(DemoGridlistChild2, {})]
                                                            })
                                                        }) });
                                                }
                                            }())
                                        })
                                    }) })
                            })
                        }) }) })] }));
    }

    //import { options } from "preact";
    //options.debounceRendering = queueMicrotask;
    //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const Component = () => {
        return (o$1(Heading, { heading: "Demos", children: [o$1(Heading, { heading: "Dialog", children: o$1(Demo$5, {}) }), o$1(Heading, { heading: "Gridlist", children: o$1(Demo, {}) }), o$1(Heading, { heading: "Table", children: o$1(Demo$1, {}) }), o$1(Heading, { heading: "Toast", children: o$1(Demo$2, {}) }), o$1(Heading, { heading: "Tooltip", children: o$1(Demo$3, {}) }), o$1(Heading, { heading: "Tabs", children: o$1(Demo$4, {}) }), o$1(Heading, { heading: "Slider", children: o$1(Demo$6, {}) }), o$1(Heading, { heading: "Single-select Listbox", children: o$1(Demo$9, {}) }), o$1(Heading, { heading: "Accordion", children: o$1(Demo$e, {}) }), o$1(Heading, { heading: "Button", children: o$1(Demo$d, {}) }), o$1(Heading, { heading: "Checkbox", children: o$1(Demo$c, {}) }), o$1(Heading, { heading: "Checkbox Group", children: o$1(Demo$b, {}) }), o$1(Heading, { heading: "Multi-select Listbox", children: o$1(Demo$a, {}) }), o$1(Heading, { heading: "Menu", children: o$1(Demo$8, {}) }), o$1(Heading, { heading: "Radio", children: o$1(Demo$7, {}) })] }));
    };
    requestAnimationFrame(() => {
        P$1(o$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyIuLi9zcmMvcHJvcHMudHMiLCIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZG9jdW1lbnQtY2xhc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvdGFiYmFibGUvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1mb2N1cy10cmFwLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZm9yY2UtdXBkYXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtaGFzLWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcHJlc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS10aW1lb3V0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJvdmluZy10YWJpbmRleC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2h1ZmZsZVNlbGYuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc29ydGFibGUtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1saXN0LW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1ncmlkLW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yYW5kb20taWQudHN4IiwiLi4vc3JjL3VzZS1idXR0b24udHMiLCIuLi9zcmMvdXNlLWFjY29yZGlvbi50c3giLCIuLi9zcmMvdXNlLWxhYmVsLnRzIiwiLi4vc3JjL3VzZS1jaGVja2JveC1ncm91cC50cyIsIi4uL3NyYy91c2UtbW9kYWwudHMiLCIuLi9zcmMvdXNlLWRyYXdlci50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1zaW5nbGUudHMiLCIuLi9zcmMvdXNlLWxpc3Rib3gtbXVsdGkudHMiLCIuLi9zcmMvdXNlLW1lbnUudHMiLCIuLi9zcmMvdXNlLXRhYnMudHMiLCIuLi9zcmMvdXNlLXRvb2x0aXAudHMiLCIuLi9zcmMvdXNlLXJhZGlvLWdyb3VwLnRzeCIsIi4uL3NyYy91c2UtdG9hc3RzLnRzeCIsIi4uL3NyYy91c2UtdGFibGUudHN4IiwiLi4vc3JjL3VzZS1ncmlkbGlzdC50c3giLCIuLi9zcmMvY29tcG9uZW50L2FjY29yZGlvbi50c3giLCIuLi9zcmMvY29tcG9uZW50L2NoZWNrYm94LnRzeCIsIi4uL3NyYy9jb21wb25lbnQvY2hlY2tib3gtZ3JvdXAudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9kaWFsb2cudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9saXN0Ym94LXNpbmdsZS50c3giLCIuLi9zcmMvY29tcG9uZW50L21lbnUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9yYWRpby1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L3NsaWRlci50c3giLCIuLi9zcmMvY29tcG9uZW50L3RhYmxlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFicy50c3giLCIuLi9zcmMvY29tcG9uZW50L3Rvb2x0aXAudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9ncmlkbGlzdC50c3giLCJkZW1vcy9hY2NvcmRpb24udHN4IiwiZGVtb3MvYnV0dG9uLnRzeCIsImRlbW9zL2NoZWNrYm94LnRzeCIsImRlbW9zL2NoZWNrYm94LWdyb3VwLnRzeCIsImRlbW9zL2xpc3Rib3gtbXVsdGkudHN4IiwiZGVtb3MvbGlzdGJveC1zaW5nbGUudHN4IiwiZGVtb3MvbWVudS50c3giLCJkZW1vcy9yYWRpby50c3giLCJkZW1vcy9zbGlkZXIudHN4IiwiZGVtb3MvZGlhbG9nLnRzeCIsImRlbW9zL3RhYnMudHN4IiwiZGVtb3MvdG9vbHRpcC50c3giLCJkZW1vcy90b2FzdC50c3giLCJkZW1vcy90YWJsZS50c3giLCJkZW1vcy9ncmlkbGlzdC50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaCwgUmVmIH0gZnJvbSBcInByZWFjdFwiO1xuXG5leHBvcnQgdHlwZSBSZWZGcm9tVGFnPFQgZXh0ZW5kcyBrZXlvZiBoLkpTWC5JbnRyaW5zaWNFbGVtZW50cz4gPSBOb25OdWxsYWJsZTxoLkpTWC5JbnRyaW5zaWNFbGVtZW50c1tUXVtcInJlZlwiXT4gJiBSZWY8YW55PjtcbmV4cG9ydCB0eXBlIEVsZW1lbnRGcm9tUmVmPFIgZXh0ZW5kcyBSZWY8YW55Pj4gPSBSIGV4dGVuZHMgUmVmPGluZmVyIEU+ID8gRSA6IEV2ZW50VGFyZ2V0O1xuZXhwb3J0IHR5cGUgRWxlbWVudEZyb21UYWc8VCBleHRlbmRzIGtleW9mIGguSlNYLkludHJpbnNpY0VsZW1lbnRzPiA9IEVsZW1lbnRGcm9tUmVmPFJlZkZyb21UYWc8VD4+O1xuXG5leHBvcnQgdHlwZSBFbGVtZW50VG9UYWc8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IGtleW9mIFN1YlR5cGU8SFRNTEVsZW1lbnRUYWdOYW1lTWFwLCBFPjtcbnR5cGUgU3ViVHlwZTxCYXNlLCBDb25kaXRpb24+ID0gUGljazxCYXNlLCB7XG4gICAgW0tleSBpbiBrZXlvZiBCYXNlXTogQmFzZVtLZXldIGV4dGVuZHMgQ29uZGl0aW9uID8gS2V5IDogbmV2ZXJcbn1ba2V5b2YgQmFzZV0+O1xuXG4vKipcbiAqIEZvciB0aW1lcyB3aGVuIG1vcmUgdGhhbiBqdXN0IHRoZSBhYnN0cmFjdCBlbGVtZW50IHR5cGUgaXMgbmVlZGVkLFxuICogYnV0IHRoZSBhY3R1YWwsIGNvbmNyZXRlLCBpbXBsZW1lbnRhdGlvbi1hZmZlY3RpbmcgXCJkaXZcIiBzdHJpbmcgdHlwZS5cbiAqIFxuICogVE9ETzogU2hvdWxkIHRoaXMgYmUgdGhlIHN0YW5kYXJkIGZvciBhbGwgdGhlIG5vbi1BUklBIGhvb2tzP1xuICogVGhleSAqbmV2ZXIqIGNhcmUgYWJvdXQgdGhlIHNwZWNpZmljIHR5cGUgZm9yIHRoZSBpbXBsZW1lbnRhdGlvbixcbiAqIGp1c3QgZm9yIHR5cGluZywgc28gaXQgd291bGRuJ3QgYmUgbmVjZXNzYXJ5LCBcbiAqIGJ1dCBpdCB3b3VsZCBiZSBjb25zaXN0ZW50IHdpdGggdGhlc2UgQVJJQSBob29rcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYWdTZW5zaXRpdmVQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICB0YWc6IEVsZW1lbnRUb1RhZzxFPjtcbn1cblxuZXhwb3J0IGNvbnN0IEV2ZW50RGV0YWlsID0gU3ltYm9sKFwiZXZlbnQtZGV0YWlsXCIpO1xuZXhwb3J0IHR5cGUgRXZlbnREZXRhaWwgPSB0eXBlb2YgRXZlbnREZXRhaWw7XG5leHBvcnQgdHlwZSBFbmhhbmNlZEV2ZW50PFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUeXBlZEV2ZW50IGV4dGVuZHMgRXZlbnQsIERldGFpbD4gPSBoLkpTWC5UYXJnZXRlZEV2ZW50PFRhcmdldCwgVHlwZWRFdmVudD4gJiB7XG4gICAgW0V2ZW50RGV0YWlsXTogRGV0YWlsO1xufTtcblxuXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVHlwZWRFdmVudCBleHRlbmRzIEV2ZW50LCBEZXRhaWwgZXh0ZW5kcyBvYmplY3Q+KGU6IFR5cGVkRXZlbnQgfCBoLkpTWC5UYXJnZXRlZEV2ZW50PEUsIFR5cGVkRXZlbnQ+LCBkZXRhaWw6IERldGFpbCk6IEVuaGFuY2VkRXZlbnQ8RSwgVHlwZWRFdmVudCwgRGV0YWlsPiB7XG4gICAgY29uc3QgZXZlbnQgPSBlIGFzIHVua25vd24gYXMgRW5oYW5jZWRFdmVudDxFLCBUeXBlZEV2ZW50LCBEZXRhaWw+O1xuICAgIGV2ZW50W0V2ZW50RGV0YWlsXSA9IGRldGFpbDtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cblxuY29uc3QgYWxyZWFkeVdhcm5lZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG50eXBlIFdPTyA9IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gd2Fybk9uT3ZlcndyaXRlPFQgZXh0ZW5kcyBXT08+KGNvbXBvbmVudE5hbWU6IHN0cmluZywgcHJvcE5hbWU6IHN0cmluZywgcHJvcFZhbHVlOiBXT08sIG5ld1ZhbHVlOiBUKTogVCB7XG4gICAgY29uc3Qga2V5ID0gYCR7Y29tcG9uZW50TmFtZX07JHtwcm9wTmFtZX1gO1xuICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWFscmVhZHlXYXJuZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGFscmVhZHlXYXJuZWQuYWRkKGtleSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSAke3Byb3BOYW1lfSBhdHRyaWJ1dGUgb24gJHtjb21wb25lbnROYW1lfSB3YXMgZ2l2ZW4gYSB2YWx1ZSBvZiAke3Byb3BWYWx1ZX0gYnV0IGlzIGJlaW5nIG92ZXJ3cml0dGVuIHRvICR7bmV3VmFsdWV9IGZvciBjb25mb3JtYW5jZS4gQ29uc2lkZXIgcmVtb3ZpbmcgaXQgYmVmb3JlIHBhc3NpbmcgdGhvc2UgcHJvcHMgdG8gJHtjb21wb25lbnROYW1lfS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cblxubGV0IGRlYnVnID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdMb2dnaW5nKGxvZ2dpbmc6IGJvb2xlYW4pIHtcbiAgICBkZWJ1ZyA9IGxvZ2dpbmc7XG59XG5cbmV4cG9ydCB0eXBlIERlYnVnTG9nVHlwZXMgPVxuICAgIFwidXNlQWNjb3JkaWFuXCIgfCBcInVzZUFjY29yZGlhblNlY3Rpb25cIiB8XG4gICAgXCJ1c2VCdXR0b25cIiB8XG4gICAgXCJ1c2VDaGVja2JveFwiIHxcbiAgICBcInVzZUNoZWNrYm94R3JvdXBcIiB8IFwidXNlQ2hlY2tib3hHcm91cFBhcmVudFwiIHwgXCJ1c2VDaGVja2JveEdyb3VwQ2hpbGRcIiB8XG4gICAgXCJ1c2VEaWFsb2dcIiB8IFwidXNlRHJhd2VyXCIgfFxuICAgIFwidXNlTGlzdGJveE11bHRpXCIgfCBcInVzZUxpc3Rib3hNdWx0aUl0ZW1cIiB8XG4gICAgXCJ1c2VMaXN0Ym94U2luZ2xlXCIgfCBcInVzZUxpc3Rib3hTaW5nbGVJdGVtXCIgfFxuICAgIFwidXNlTWVudVwiIHwgXCJ1c2VNZW51U3VyZmFjZVwiIHwgXCJ1c2VNZW51SXRlbVwiIHwgXCJ1c2VGb2N1c1NlbnRpbmVsXCIgfCBcInVzZU1lbnVTdXJmYWNlU2VudGluZWxcIiB8XG4gICAgXCJ1c2VSYWRpb0dyb3VwXCIgfCBcInVzZVJhZGlvXCIgfFxuICAgIFwidXNlU2xpZGVyXCIgfCBcInVzZVNsaWRlclRodW1iXCIgfFxuICAgIFwidXNlVGFibGVcIiB8IFwidXNlVGFibGVSb3dcIiB8IFwidXNlVGFibGVDZWxsXCIgfCBcInVzZVRhYmxlQm9keVwiIHxcbiAgICBcInVzZUdyaWRsaXN0XCIgfCBcInVzZUdyaWRsaXN0Um93XCIgfCBcInVzZUdyaWRsaXN0Q2hpbGRcIiB8IFwidXNlR3JpZGxpc3RTZWN0aW9uXCIgfFxuICAgIFwidXNlVGFic1wiIHwgXCJ1c2VUYWJMaXN0XCIgfCBcInVzZVRhYlwiIHwgXCJ1c2VUYWJQYW5lbFwiIHxcbiAgICBcInVzZVRvYXN0c1wiIHwgXCJ1c2VUb2FzdFwiIHxcbiAgICBcInVzZVRvb2x0aXBcIiB8IFwidXNlVG9vbHRpcFRvb2x0aXBcIiB8IFwidXNlVG9vbHRpcFRyaWdnZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnTG9nKHdobzogRGVidWdMb2dUeXBlcywgLi4uYXJnczogUGFyYW1ldGVyczwodHlwZW9mIGNvbnNvbGUpW1wibG9nXCJdPikge1xuICAgIGlmIChkZWJ1ZylcbiAgICAgICAgY29uc29sZS5kZWJ1Zyh3aG8gKyBcIjpcIiwgLi4uYXJncyk7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BNb2RpZmllcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5cbmNvbnN0IEhlYWRpbmdMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5leHBvcnQgY29uc3QgSGVhZGluZyA9IG1lbW8oZnVuY3Rpb24gSGVhZGluZzxUIGV4dGVuZHMgRWxlbWVudD4oeyBjaGlsZHJlbiwgaGVhZGluZywgLi4ucHJvcHMgfTogeyBoZWFkaW5nOiBDb21wb25lbnRDaGlsZHJlbiB9ICYgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pIHtcbiAgICBjb25zdCBoZWFkaW5nTGV2ZWxCZWZvcmVVcyA9IHVzZUNvbnRleHQoSGVhZGluZ0xldmVsQ29udGV4dCk7XG4gICAgY29uc3QgbmV3SGVhZGluZ0xldmVsID0gaGVhZGluZ0xldmVsQmVmb3JlVXMgKyAxO1xuICAgIGxldCB0YWc6IHN0cmluZztcbiAgICBpZiAobmV3SGVhZGluZ0xldmVsIDw9IDYpIHtcbiAgICAgICAgdGFnID0gYGgke25ld0hlYWRpbmdMZXZlbH1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFnID0gJ2Rpdic7XG4gICAgICAgIHByb3BzW1wiYXJpYS1sZXZlbFwiXSA9IHdhcm5Pbk92ZXJ3cml0ZShcIkhlYWRpbmdcIiwgXCJhcmlhLWxldmVsXCIsIHByb3BzW1wiYXJpYS1sZXZlbFwiXSwgYCR7bmV3SGVhZGluZ0xldmVsfWApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8SGVhZGluZ1Jlc2V0IG5ld0xldmVsPXtoZWFkaW5nTGV2ZWxCZWZvcmVVcyArIDF9PlxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZyBhcyBhbnksIHByb3BzLCBoZWFkaW5nKX1cbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L0hlYWRpbmdSZXNldD5cbiAgICAgICAgPC8+XG4gICAgKVxufSlcblxuZXhwb3J0IGNvbnN0IEhlYWRpbmdSZXNldCA9IG1lbW8oZnVuY3Rpb24gSGVhZGluZ1Jlc2V0KHsgbmV3TGV2ZWwsIGNoaWxkcmVuIH06IHsgbmV3TGV2ZWw6IG51bWJlciwgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8SGVhZGluZ0xldmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bmV3TGV2ZWx9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0hlYWRpbmdMZXZlbENvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCJcblxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+ID0gKCh2YWx1ZTogVCwgcHJldlZhbHVlOiBUIHwgdW5kZWZpbmVkKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCwgMCk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVPih2YWx1ZTogVSwgaW5kZXg6IG51bWJlcikge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWYodmFsdWUpO1xuICAgICAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aW5kZXh9LWluZGV4ZWQgYXJndW1lbnQuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBCeSBkZWZhdWx0LCBjaGFuZ2VzIHRvIHBhc3NpdmUgc3RhdGUgYXJlIGRlbGF5ZWQgYnkgb25lIHRpY2sgc28gdGhhdCB3ZSBvbmx5IGNoZWNrIGZvciBjaGFuZ2VzIGluIGEgc2ltaWxhciB3YXkgdG8gUHJlYWN0LiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgdG8sIGZvciBleGFtcGxlLCBhbHdheXMgcnVuIGltbWVkaWF0ZWx5IGluc3RlYWQuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBULCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZz86IHR5cGVvZiBkZWJvdW5jZVJlbmRlcmluZyk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD5dIHtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCB3YXJuaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2tSZWYgPSB1c2VSZWY8dW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpPih1bmRlZmluZWQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVBhc3NpdmVTdGF0ZVwiLCBvbkNoYW5nZSwgZ2V0SW5pdGlhbFZhbHVlLCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCByID0gdXNlUmVmKHsgcHJldkRlcDogVW5zZXQgYXMgVCB8ICh0eXBlb2YgVW5zZXQpIH0pO1xuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxUPj4oKGFyZykgPT4ge1xuXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiB2YWx1ZVJlZi5jdXJyZW50KSA6IGFyZyk7XG5cblxuICAgICAgICBpZiAoci5jdXJyZW50LnByZXZEZXAgPT09IFVuc2V0ICYmIG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgci5jdXJyZW50LnByZXZEZXAgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIChjdXN0b21EZWJvdW5jZVJlbmRlcmluZyA/PyBkZWJvdW5jZVJlbmRlcmluZykoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREZXAgPSB2YWx1ZVJlZi5jdXJyZW50ISBhcyBUO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZEZXAgPSByLmN1cnJlbnQucHJldkRlcCA7XG4gICAgICAgICAgICAgICAgaWYgKHIuY3VycmVudC5wcmV2RGVwICE9IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJlZCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4obmV4dERlcCwgcHJldkRlcCA9PT0gVW5zZXQ/IHVuZGVmaW5lZCA6IHByZXZEZXApID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IFVuc2V0O1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgcHJldkRlcCB0byBzZWUgaWYgd2Ugc2hvdWxkIGFjdHVhbGx5IGNhbGwgb25DaGFuZ2VcbiAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcbn1cblxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcblxuLy8gRWFzeSBjb25zdGFudHMgZm9yIGdldEluaXRpYWxWYWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH0iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcblxuXG4vKipcbiAqIFxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxuICogXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cbiAqICAgICogTm90aGluZyBpcyBmb2N1c2VkLCBidXQgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGBib2R5YC4gXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqIFxuICogXG4gKiBJbiBzdW1tYXJ5OlxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxuICogMi4gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgICppcyBub3QqIGFsd2F5cyB0aGUgc2FtZSBhcyB3aGF0J3MgYmVpbmcgcmVmZXJlbmNlZCBieSBhIGZvY3VzIGV2ZW50LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXkgYmVjb21lIGBib2R5YCBhdCBhbnkgYXJiaXRyYXJ5IHRpbWUuXG4gKiAzLiBBIGBibHVyYCB3aXRob3V0IGEgYGZvY3VzYCBjYW4gYW5kIHdpbGwgb2NjdXIuIFRoaXMgbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHNvbGVseSB1c2UgYGZvY3VzYCB0byBkZXRlY3QgYWxsIGNoYW5nZXMuXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxuICogXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmludGVyZmFjZSBGb288VD4ge1xuICAgIGxhc3RTZW50OiBUIHwgdW5kZWZpbmVkO1xuICAgIHNlbmQ6IChlOiBUKSA9PiB2b2lkO1xufVxuLypcbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSB8IG51bGwpID0+IHZvaWQpPj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUpID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTsqL1xuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGUgfCBudWxsPj4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGU+Pj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxib29sZWFuPj4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xuXG4vL2NvbnN0IG1pY3JvdGFza3MgPSBuZXcgTWFwPFNldDxhbnk+LCBhbnk+KCk7XG5cbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxuLy8gRm9yIHRoZSBwdXJwb3NlIG9mIGltcHJvdmluZyBzdGFiaWxpdHksIHdlIGRlYm91bmNlIGFsbCBmb2N1cyBldmVudHMgdG8gdGhlIG5leHQgbWljcm90YXNrLlxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPFQ+Pj4sIHZhbHVlOiBUKSB7XG4gICAgY29uc3QgdXBkYXRlcnMgPSBtYXAuZ2V0KHdpbmRvdyk7XG4gICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgIC8vaWYgKCFtaWNyb3Rhc2tzLmhhcyh1cGRhdGVyc0tleSkpIHtcbiAgICAgICAgLy9kZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgIC8vY29uc3QgdXBkYXRlcnNLZXkgPSBtYXAuZ2V0KHdpbmRvdykhO1xuICAgICAgICAvL2NvbnN0IHZhbHVlID0gbWljcm90YXNrcy5nZXQodXBkYXRlcnNLZXkpO1xuICAgICAgICAvL21pY3JvdGFza3MuZGVsZXRlKHVwZGF0ZXJzS2V5KTtcblxuICAgICAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFzdFNlbnQsIHNlbmQgfSA9IHVwZGF0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBsYXN0U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlci5sYXN0U2VudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vfSk7XG4gICAgICAgIC8vfVxuXG4gICAgICAgIC8vbWljcm90YXNrcy5zZXQodXBkYXRlcnNLZXksIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgbnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gd2luZG93Rm9jdXMoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIHRydWUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dCbHVyKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgZmFsc2UpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIHtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCB8IG51bGw+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzIGFuZCBpcyBub3QgbnVsbC4gXG4gICAgICogTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSB3aW5kb3cgZ2FpbnMvbG9zZXMgZm9jdXMuIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4+O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggd2hhdGV2ZXIgZWxlbWVudHMgd2UncmUgbGlzdGVuaW5nIHRvLlxuICAgICAqIFxuICAgICAqIEUuRy4gc29tZURpdkVsZW1lbnQub3duZXJEb2N1bWVudFxuICAgICAqIFxuICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxuICAgICAqL1xuICAgIGdldERvY3VtZW50KCk6IERvY3VtZW50O1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgZXZlbnQgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCdzIGRlZmF1bHRWaWV3IFdpbmRvdy5cbiAgICAgKiBJZiB5b3UgbmVlZCBzb21ldGhpbmcgZGlmZmVyZW50LCBvdmVycmlkZSBpdCBoZXJlLlxuICAgICAqIFxuICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxuICAgICAqL1xuICAgIGdldFdpbmRvdz8oZG9jdW1lbnQ6IERvY3VtZW50KTogV2luZG93O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciBgbnVsbGAgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudCB8IG51bGw7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGluc3BlY3Qgd2hpY2ggZWxlbWVudCBpbiB0aGUgYGRvY3VtZW50YCBjdXJyZW50bHkgaGFzIGZvY3VzLCB3aGljaCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIG5vbmUgYXJlIGN1cnJlbnRseSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB3aW5kb3cgaGFzIGZvY3VzIGJ5IHJldHVybmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqICogYGdldEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRXaW5kb3dGb2N1c2VkKClgXG4gKiBcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcbiAqIFxuICogVGhpcyBpcyBhIHBhc3NpdmUgaG9vaywgc28gYnkgZGVmYXVsdCBpdCByZXR1cm5zIGdldHRlciBmdW5jdGlvbnMgdGhhdCByZXBvcnQgdGhpcyBpbmZvcm1hdGlvbiBidXQgdGhlIGNvbXBvbmVudCB3aWxsIG5vdCByZS1yZW5kZXIgYnkgZGVmYXVsdCB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLlxuICogXG4gKiBJZiB5b3UgbmVlZCB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLCB1c2UgdGhlIGBvbipDaGFuZ2VgIGFyZ3VtZW50cyB0byBzZXQgc29tZSBzdGF0ZSBvbiB5b3VyIGVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQoeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyk6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUFjdGl2ZUVsZW1lbnRcIiwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCB3aW5kb3cgPSAoZ2V0V2luZG93Py4oZG9jdW1lbnQpID8/IGRvY3VtZW50Py5kZWZhdWx0Vmlldyk7XG5cbiAgICAgICAgaWYgKChhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdyk/LnNpemUgPz8gMCkgPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XG4gICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgIGNvbnN0IGxhZXUgPSB7IHNlbmQ6IHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPiwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9XG4gICAgICAgIGNvbnN0IGxsYWV1ID0geyBzZW5kOiBzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4sIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcbiAgICAgICAgY29uc3QgbHdmdSA9IHsgc2VuZDogc2V0V2luZG93Rm9jdXNlZCwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9O1xuXG4gICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsYWV1KTtcbiAgICAgICAgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsbGFldSk7XG4gICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChsd2Z1KTtcblxuICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobHdmdSk7XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQgfCBudWxsPihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xuXG4gICAgcmV0dXJuIHsgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIGdldFdpbmRvd0ZvY3VzZWQgfTtcbn1cbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICAvKigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2QXJnc1JlZiA9IHVzZVJlZjxJbnB1dHM+KG51bGwhKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKGlucHV0cywgcHJldkFyZ3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xuICAgICAgICAgICAgaWYgKGNsZWFudXAuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfSkoKTsqL1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUsIGRlYm91bmNlUmVuZGVyaW5nIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBpbmRleDogVDtcbiAgICBmbGFncz86IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PjtcbiAgICBzdWJJbmZvOiBDO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5pbnRlcmZhY2UgTUNQPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAqIFxuICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAqL1xuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VD47XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQ+O1xufVxuXG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyA9IGtleW9mIE1DUDxhbnk+O1xuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkT21pdHMgPSBrZXlvZiBNYW5hZ2VkQ2hpbGRJbmZvPGFueSwgYW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgT21pdHMgZXh0ZW5kcyBrZXlvZiBNQ1A8VD4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IE9taXQ8TUNQPFQ+LCBPbWl0cz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+IHtcbiAgICBtYW5hZ2VkQ2hpbGQ6IE9taXQ8TWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiwgTWNPbWl0cz47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQsIEMsIEs+IHtcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgdGhhdCBtdXN0IGJlIGNhbGxlZCBieSBldmVyeSBjaGlsZCBjb21wb25lbnQgdGhhdFxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIGNoaWxkJ3MgaW5kZXguXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIHVzZU1hbmFnZWRDaGlsZDogVXNlTWFuYWdlZENoaWxkPFQsIEMsIEs+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCwgQywgSywgbmV2ZXI+KSA9PiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlO1xuXG5cblxuXG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IFQpOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+KSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqICoqVU5TVEFCTEUqKiwgYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz5bXTtcbn1cblxuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyB7fT4gPSB7IGluZm86IEkgfTtcblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCwgbmV2ZXI+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxULCBDLCBLPiB7XG4gICAgLy90eXBlIEkgPSBJMyAmIE1hbmFnZWRDaGlsZEluZm9CYXNlPHN0cmluZyB8IG51bWJlcj47XG4gICAgdHlwZSBJbmZvID0gTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPjtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSA9IHBhcmVudFBhcmFtZXRlcnM7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjx7IGFycjogQXJyYXk8SW5mbz47IHJlYzogUGFydGlhbDxSZWNvcmQ8VCwgSW5mbz4+OyBoaWdoZXN0SW5kZXg6IG51bWJlciwgbG93ZXN0SW5kZXg6IG51bWJlciB9Pih7IGFycjogW10sIHJlYzoge30sIGhpZ2hlc3RJbmRleDogMCwgbG93ZXN0SW5kZXg6IDAgfSk7XG5cbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcbiAgICAvLyBDb21wYXJlIGdldE1hbmFnZWRDaGlsZEluZm9cbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xuICAgIC8vIHdoaWNoIG5lZWRzIHRvIHNlYXJjaCBhbGwgY2hpbGRyZW4gZm9yIHRoYXQgY2xvc2VzdCBmaXQuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIGJldHRlciBmb3IgdGhhdC5cbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxULCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz5bXCJnZXRBdFwiXT4oKGluZGV4OiBUKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdITtcbiAgICB9LCBbXSlcblxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xuICAgIC8vIG91cnNlbHZlcyBiZWNhdXNlIG9mIGhhdmluZyBhIGBjaGlsZENvdW50YCBzdGF0ZSBvciBhbnl0aGluZyBzaW1pbGFyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcbiAgICAvLyB0byBtYXliZSBkbyBzb21ldGhpbmcgd2l0aCBhbGwgdGhlc2UgY2hpbGRyZW4gdGhhdCBqdXN0IG1vdW50ZWQuXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xuICAgIC8vIHNldENoaWxkQ291bnQgYW5kIHJlLXJlbmRlcmluZyBldmVyeSB0aW1lIGNoaWxkcmVuIG1vdW50XG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcbiAgICAvLyBcbiAgICAvLyBBcyBhbiBhbHRlcm5hdGUgc29sdXRpb24sIGFueSB0aW1lIGEgY2hpbGQgdXNlcyBVTEUgb24gbW91bnQsIGl0IHF1ZXVlcyBhIG1pY3JvdGFza1xuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XG4gICAgLy8gcnVucyBvbmNlLiBXaGVuIGl0J3MgZG9uZSwgaGFzUmVtb3RlVUxFIGlzIHJlc2V0IHNvIGl0IGNhbiBydW4gYWdhaW4gaWZcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8VD4sIHVubW91bnRzOiBTZXQ8VD4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxUPigpKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD8uKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKVxuICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4IGFzIG51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXTtcbiAgICAgICAgICAgICAgICBsZXQgc2hhdmUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzaGF2ZSA8PSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggJiYgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICsrc2hhdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLnNwbGljZShtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSBzaGF2ZSwgc2hhdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBUXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgdXNlTWFuYWdlZENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTWFuYWdlZENoaWxkPFQsIEMsIEs+PigoeyBtYW5hZ2VkQ2hpbGQ6IGluZm8sIH0pID0+IHtcbiAgICAgICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgICAgICAvLyB0aGUgcGFyZW50IGlmIHRoZXkgbmVlZCBpdC5cbiAgICAgICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXG4gICAgICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8uaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZm8uaW5kZXggYXMgbnVtYmVyXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZm8uaW5kZXggYXMgVF0gPSB7IGluZGV4OiBpbmZvLmluZGV4LCBmbGFnczogaW5mby5mbGFncyA/PyB7fSwgc3ViSW5mbzogaW5mby5zdWJJbmZvIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZm8uaW5kZXggYXMgVCk7XG4gICAgICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcbiAgICAgICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZm8uaW5kZXggYXMgVCwgZmFsc2UpO1xuICAgICAgICB9LCBbaW5mby5pbmRleF0pO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaXMgY29uc2lkZXJlZCBhY3RpdmUgb24gbW91bnQuXG4gICAgICogXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxuICAgICAqL1xuICAgIGluaXRpYWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgLy9jbG9zZXN0Rml0PzogYm9vbGVhbjtcbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqIFxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxuICAgICAqIGlmIHRoZSByZXF1ZXN0ZWQgaW5kZXggZGlkbid0IGV4aXN0IG9yIHdhcyBoaWRkZW4uXG4gICAgICovXG4gICAgb25JbmRleENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPG51bWJlciB8IG51bGw+O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBjaGlsZHJlbiBoYXZlIG11bHRpcGxlIGZsYWdzLCB0aGUgYGtleWAgcGFyYW1ldGVyIGNvbnRyb2xzIHdoaWNoIGZsYWcgd2UncmUgY2hlY2tpbmcuXG4gICAgICogXG4gICAgICogVGhpcyBjYW4gYmUgYW55dGhpbmcgeW91IHdhbnQsIGJ1dCBtdXN0IG5vdCBjaGFuZ2UuXG4gICAgICovXG4gICAga2V5OiBLO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cbi8vZXhwb3J0IGludGVyZmFjZSBGbGFnZ2FibGVDaGlsZEluZm9CPEsgZXh0ZW5kcyBzdHJpbmc+IHsgZmxhZ3M6IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PiB9IFxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBjaGFuZ2VJbmRleDogKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICogXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCBvciB3aGVuZXZlciBjYWxsaW5nIGEgY2hpbGQncyBpc1ZhbGlkKCkgd291bGQgY2hhbmdlXG4gICAgICogICovXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcbiAqIDEuIFlvdSBoYXZlIGEgYnVuY2ggb2YgY2hpbGRyZW5cbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cbiAqIFxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB5b3UgbWF5IHdhbnQgdG8gdXNlIG11bHRpcGxlIGZsYWdzIHdpdGggdGhlIHNhbWUgY2hpbGRyZW4sIHRoaXMgaG9vayAqZG9lcyBub3QqIHVzZSBgdXNlTWFuYWdlZENoaWxkcmVuYCFcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXG4gKiBcbiAqIEFsc28gYmVjYXVzZSBvZiB0aGF0LCB0aGUgdHlwZXMgb2YgdGhpcyBmdW5jdGlvbiBhcmUgcmF0aGVyIG9kZC4gIEl0J3MgYmV0dGVyIHRvIHN0YXJ0IG9mZiB1c2luZyBhIGhvb2sgdGhhdCBhbHJlYWR5IHVzZXMgYSBmbGFnLCBzdWNoIGFzIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFzIGFuIGV4YW1wbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5GbGFnPEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwga2V5IH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8QywgSz4pOiBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlIHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwga2V5KTtcblxuICAgIGNvbnN0IFtnZXRDdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4ob25JbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4obnVsbCwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xuXG4gICAgLy8gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWMgKGJ1dCBjb3VsZCBiZSBJIGd1ZXNzKVxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLmFicyhjaGlsZC5pbmRleCAtIHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UgfHwgKG5ld0Rpc3RhbmNlID09IGNsb3Nlc3REaXN0YW5jZSAmJiBjaGlsZC5pbmRleCA8IHJlcXVlc3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlISAqL10pO1xuXG4gICAgLy8gQW55IHRpbWUgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIHdlIG5lZWQgdG8gZG91YmxlLWNoZWNrIHRvIHNlZSBpZiB0aGF0IGFmZmVjdHMgXG4gICAgLy8gdGhlIFwiY3VycmVudGx5IHNlbGVjdGVkXCIgKG9yIHdoYXRldmVyKSBpbmRleC4gIFRoZSB0d28gY2FzZXMgd2UncmUgbG9va2luZyBmb3I6XG4gICAgLy8gMS4gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjaGlsZCB1bm1vdW50ZWRcbiAgICAvLyAyLiBBIGNoaWxkIG1vdW50ZWQsIGFuZCBpdCBtb3VudHMgd2l0aCB0aGUgaW5kZXggd2UncmUgbG9va2luZyBmb3JcbiAgICBjb25zdCByZWV2YWx1YXRlQ2xvc2VzdEZpdCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KTtcblxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWN1cnJlbnRDaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RGaXRDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbiAgICBjb25zdCBjaGFuZ2VJbmRleCA9IHVzZUNhbGxiYWNrKChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnO1xuICAgICAgICAvL2lmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsICYmIGdldEZpdE51bGxUb1plcm8oKSlcbiAgICAgICAgLy8gICAgcmVxdWVzdGVkSW5kZXggPSAwO1xuXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCk7XG4gICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkICYmIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdEZpdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5pdGlhbEluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpbml0aWFsSW5kZXgpPy5mbGFncz8uW2tleV0/LnNldCh0cnVlKTtcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgZ2V0Q3VycmVudEluZGV4IH07XG59XG5cbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb2N1bWVudChlbGVtZW50PzogTm9kZSkgeyByZXR1cm4gKGVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ID8/IGdsb2JhbFRoaXMuZG9jdW1lbnQpOyB9XG5cbnR5cGUgUCA9IFBhcmFtZXRlcnM8dHlwZW9mIGNsc3g+O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9jdW1lbnRDbGFzcyhjbGFzc05hbWU6IFBbMF0sIGFjdGl2ZT86IGJvb2xlYW4sIGVsZW1lbnQ/OiBIVE1MRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPz89IGdldERvY3VtZW50KCkuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNsYXNzTmFtZSA9IGNsc3goY2xhc3NOYW1lKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZWxlbWVudCEuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2NsYXNzTmFtZSwgYWN0aXZlLCBlbGVtZW50XSk7XG5cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2hpbGRyZW4oeyBjaGlsZHJlbjogbGhzIH06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+LCB7IGNoaWxkcmVuOiByaHN9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJjaGlsZHJlblwiPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdIHtcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxyXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cclxuICogXHJcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XHJcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyBjbGFzczogbGhzQ2xhc3MsIGNsYXNzTmFtZTogbGhzQ2xhc3NOYW1lIH06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+LCB7IGNsYXNzOiByaHNDbGFzcywgY2xhc3NOYW1lOiByaHNDbGFzc05hbWV9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBcImNsYXNzXCIgfCBcImNsYXNzTmFtZVwiPik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblxyXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xyXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXHJcblxyXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcclxuICAgICAgICBjb25zdCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWxsQ2xhc3Nlcykuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGgsIFJlZiwgUmVmQ2FsbGJhY2ssIFJlZk9iamVjdCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJlZihpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgIChyZWYgYXMgUmVmT2JqZWN0PFQgfCBudWxsPikuY3VycmVudCA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBSPEU+IHtcclxuICAgIHJlZj86IFJlZjxFPjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cclxuICogQHBhcmFtIGxocyBcclxuICogQHBhcmFtIHJocyBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHsgcmVmOiByaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHsgcmVmOiBsaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pIHtcclxuICAgIGNvbnN0IGNvbWJpbmVkOiBSZWZDYWxsYmFjazxFPiA9IHVzZUNhbGxiYWNrKChjdXJyZW50OiBFIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcclxuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIHJocyk7XHJcbiAgICB9LCBbbGhzLCByaHNdKTtcclxuXHJcbiAgICAoY29tYmluZWQgYXMgYW55KS5fY291bnQgPSAoKHJocyBhcyBhbnkpPy5fY291bnQgPz8gMCkgKyAoKGxocyBhcyBhbnkpPy5fY291bnQgPz8gMCk7XHJcbiAgICAoY29tYmluZWQgYXMgYW55KS5fbGhzID0gbGhzO1xyXG4gICAgKGNvbWJpbmVkIGFzIGFueSkuX3JocyA9IHJocztcclxuXHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsaHMhO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG5mdW5jdGlvbiBzdHlsZVN0cmluZ1RvT2JqZWN0KHN0eWxlOiBzdHJpbmcpOiBoLkpTWC5DU1NQcm9wZXJ0aWVzIHtcclxuICAgIC8vIFRPRE86IFRoaXMgc3Vja3MgRDpcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0d28gc3R5bGUgb2JqZWN0cywgcmV0dXJuaW5nIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcclxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcclxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+LCByaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0ge1xyXG5cclxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxyXG4gICAgaWYgKCFsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xyXG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiAhcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5zdHlsZTtcclxuICAgICAgICBpZiAoIWxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIHJocy5zdHlsZTtcclxuXHJcbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSkge1xyXG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyh7IHN0eWxlOiBzdHlsZVN0cmluZ1RvT2JqZWN0KGxocz8uc3R5bGUgYXMgc3RyaW5nKSB9LCByaHMpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QocmhzPy5zdHlsZSBhcyBzdHJpbmcpIH0pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2dpYz8/P1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cclxuICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2xocy5zdHlsZX07JHtyaHM/LnN0eWxlID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi4obGhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgICAgICAuLi4ocmhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcmVmc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlc1wiO1xyXG5cclxubGV0IGxvZyA9IGNvbnNvbGUud2FybjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xyXG4gICAgbG9nID0gbG9nMlxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gKiBcclxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cclxuICogQHBhcmFtIGxoczIgXHJcbiAqIEBwYXJhbSByaHMyIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAvLyBGaXJzdCwgc2VwYXJhdGUgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4gaW50byB0d28gZ3JvdXBzOlxyXG4gICAgLy8gbGhzQWxsIGFuZCByaHNBbGwgY29udGFpbiBhbGwgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4sIGFuZFxyXG4gICAgLy8gbGhzTWlzYyBhbmQgcmhzTWlzYyBjb250YWluIGFsbCBwcm9wcyAqZXhjZXB0KiBmb3IgdGhlIGVhc3kgb25lc1xyXG4gICAgLy8gbGlrZSBjbGFzc05hbWUgYW5kIHN0eWxlIHRoYXQgd2UgYWxyZWFkeSBrbm93IGhvdyB0byBtZXJnZS5cclxuICAgIGNvbnN0IHsgY2hpbGRyZW46IF9saHNDaGlsZHJlbiwgY2xhc3M6IF9saHNDbGFzcywgY2xhc3NOYW1lOiBfbGhzQ2xhc3NOYW1lLCBzdHlsZTogX2xoc1N0eWxlLCByZWY6IF9saHNSZWYsIC4uLmxoc01pc2MgfSA9IGxoc0FsbDtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW46IF9yaHNDaGlsZHJlbiwgY2xhc3M6IF9yaHNDbGFzcywgY2xhc3NOYW1lOiBfcmhzQ2xhc3NOYW1lLCBzdHlsZTogX3Joc1N0eWxlLCByZWY6IF9yaHNSZWYsIC4uLnJoc01pc2MgfSA9IHJoc0FsbDtcclxuXHJcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xyXG4gICAgICAgIC4uLmxoc01pc2MsXHJcbiAgICAgICAgcmVmOiB1c2VNZXJnZWRSZWZzPEU+KGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBzdHlsZTogdXNlTWVyZ2VkU3R5bGVzKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNoaWxkcmVuOiB1c2VNZXJnZWRDaGlsZHJlbihsaHNBbGwsIHJoc0FsbCksXHJcbiAgICB9IGFzIGFueTtcclxuXHJcbiAgICBpZiAocmV0LnJlZiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnJlZjtcclxuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcclxuICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xyXG4gICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xyXG5cclxuICAgIC8vIE5vdywgZG8gKmV2ZXJ5dGhpbmcqIGVsc2VcclxuICAgIC8vIE1lcmdlIGV2ZXJ5IHJlbWFpbmluZyBleGlzdGluZyBlbnRyeSBpbiBsaHMgd2l0aCB3aGF0IHdlJ3ZlIGFscmVhZHkgcHV0IGluIHJldC5cclxuICAgIC8vY29uc3QgbGhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGxocykgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW107XHJcbiAgICBjb25zdCByaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmhzTWlzYyk7XHJcblxyXG4gICAgZm9yIChjb25zdCBbcmhzS2V5VSwgcmhzVmFsdWVdIG9mIHJoc0VudHJpZXMpIHtcclxuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG5cclxuICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc01pc2NbcmhzS2V5IGFzIGtleW9mIHR5cGVvZiBsaHNNaXNjXTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXHJcbiAgICAgICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VGdW5jdGlvbnMobGhzVmFsdWUgYXMgbmV2ZXIsIHJoc1ZhbHVlIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgcmV0W3Joc0tleSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPl0gPSBtZXJnZWQgYXMgbmV2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gbGhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJoc1ZhbHVlIGFzIGFueSkgPT0gbGhzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEkgbWVhbiwgdGhleSdyZSB0aGUgc2FtZSB2YWx1ZSBhdCBsZWFzdFxyXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCByZWFsbHkgaWRlYWwgdGhvdWdoLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gTm8gZ29vZCBzdHJhdGVnaWVzIGhlcmUsIGp1c3QgbG9nIGl0IGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgbG9nPy4oYFRoZSBwcm9wIFwiJHtyaHNLZXl9XCIgY2Fubm90IHNpbXVsdGFuZW91c2x5IGJlIHRoZSB2YWx1ZXMgJHtsaHNWYWx1ZX0gYW5kICR7cmhzVmFsdWV9LiBPbmUgbXVzdCBiZSBjaG9zZW4gb3V0c2lkZSBvZiB1c2VNZXJnZWRQcm9wcy5gKTtcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnM8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBVIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuXHJcbiAgICBpZiAoIWxocylcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgaWYgKCFyaHMpXHJcbiAgICAgICAgcmV0dXJuIGxocztcclxuXHJcbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcclxuICAgICAgICBjb25zdCBsdiA9IGxocyguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgaWYgKGx2IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBydiBpbnN0YW5jZW9mIFByb21pc2UpXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKlxyXG5mdW5jdGlvbiB0ZXN0PFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuXHJcbiAgICBjb25zdCBpZDA6IEdlbmVyaWNHZXQ8e30sIFwiaWRcIiwgc3RyaW5nPiA9IFwiXCI7XHJcbiAgICBjb25zdCBpZDM6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNDogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ1OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDY6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIC8vY29uc3QgaWQyOiBaaXBTaW5nbGU8c3RyaW5nIHwgdW5kZWZpbmVkLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQxOiBaaXBPYmplY3Q8eyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHsgaWQ6IHVuZGVmaW5lZCB9O1xyXG5cclxuICAgIHR5cGUgTTEgPSBHZW5lcmljR2V0PFAsIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIHR5cGUgTTIgPSBHZW5lcmljR2V0PHt9LCBcInN0eWxlXCIsIHN0cmluZz47XHJcbiAgICBjb25zdCBtMTogTTEgPSBcIlwiO1xyXG4gICAgY29uc3QgbTI6IE0xID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG0zOiBNMSA9IDA7XHJcblxyXG4gICAgY29uc3QgbTQ6IE0yID0gXCJcIjtcclxuICAgIGNvbnN0IG01OiBNMiA9IHVuZGVmaW5lZDtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXHJcbiAgICBjb25zdCBtNjogTTIgPSAwO1xyXG5cclxuICAgIGNvbnN0IHAxOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAyOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAzOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDQ6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7fT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7fSk7XHJcbiAgICBjb25zdCBwNSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHt9KTtcclxuICAgIGNvbnN0IHA2ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDcgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG5cclxuXHJcbiAgICBwMS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHAzLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICBwNC5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBwNS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDYuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHA3LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDUuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDYuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDcuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA1LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDYuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNy5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgaXQgd29ya3MgcmVjdXJzaXZlbHlcclxuICAgIGNvbnN0IHIxYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAxKTtcclxuICAgIGNvbnN0IHIxYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAxKTtcclxuICAgIGNvbnN0IHIyYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAyKTtcclxuICAgIGNvbnN0IHIyYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAyKTtcclxuICAgIGNvbnN0IHIzYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAzKTtcclxuICAgIGNvbnN0IHIzYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAzKTtcclxuICAgIGNvbnN0IHI0YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA0KTtcclxuICAgIGNvbnN0IHI0YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA0KTtcclxuICAgIGNvbnN0IHI1YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA1KTtcclxuICAgIGNvbnN0IHI1YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA1KTtcclxuICAgIGNvbnN0IHI2YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA2KTtcclxuICAgIGNvbnN0IHI2YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA2KTtcclxuICAgIGNvbnN0IHI3YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA3KTtcclxuICAgIGNvbnN0IHI3YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA3KTtcclxuXHJcblxyXG4gICAgcjFhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMWIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIyYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHIzYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjNiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICByNGEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI0Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICByNWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI1Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjZhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI3YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjVhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI1Yi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjZiLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByN2IuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxufVxyXG5mdW5jdGlvbiBhY2NlcHRzTmV2ZXIobjogbmV2ZXIpIHt9XHJcbiovIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRFbGVtZW50KCk6IFQgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XHJcbiAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD47XHJcbiAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbiAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXHJcbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsIFxyXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cclxuICogXHJcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxyXG4gKiBcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJncz86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4ge1xyXG4gICAgY29uc3QgeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9ID0gKGFyZ3MgPz8ge30pO1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xyXG5cclxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxyXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xyXG4gICAgICAgIGlmIChwcmV2VmFsdWUpXHJcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xyXG5cclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xlYW51cDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXHJcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGw+KGhhbmRsZXIsIHJldHVybk51bGwsIHJ1bkltbWVkaWF0ZWx5KTtcclxuICAgIGNvbnN0IHVzZVJlZkVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1widXNlUmVmRWxlbWVudFByb3BzXCJdPigocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzPFQ+KHsgcmVmOiBzZXRFbGVtZW50IH0sIHByb3BzKSwgW10pO1xyXG5cclxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxyXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSZWZFbGVtZW50UHJvcHMsXHJcbiAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBydW5JbW1lZGlhdGVseShmOiAoKSA9PiB2b2lkKSB7XHJcbiAgICBmKCk7XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxyXG4gKiBhbmQgbm90IHRoZSBnZW5lcmljIFwiSSdsbCBhY2NlcHQgYW55IHN0cmluZyBhbmQgYW55IGhhbmRsZXJcIiBvbmUuXHJcbiAqIFxyXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cclxuICogbGliLmRvbS50cyBhbHdheXMgZ2l2ZWluZyB0aGUgdHdvIG92ZXJsb2FkcyBpbiB0aGUgc2FtZSBvcmRlciwgd2l0aCB0aGVcclxuICogdHlwZWQgb25lIGZpcnN0LiAqVGhhdCogcHJvYmFibHkgd29uJ3QgY2hhbmdlLCBidXQgaWYgbW9yZSBvdmVybG9hZHNcclxuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cclxuICogXHJcbiAqIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTI3NjExNTYgZm9yIGhvdyBzZWxlY3RpbmcgdGhlIGNvcnJlY3Qgb3ZlcmxvYWQgd29ya3MuXHJcbiAqL1xyXG50eXBlIEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPFQ+ID1cclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogaW5mZXIgUiB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFIpID0+IGFueSA/IFIgOiBbXTtcclxuXHJcbi8vIEdldCBqdXN0IHRoZSB0eXBlZCB2ZXJzaW9uIG9mIGFkZEV2ZW50TGlzdGVuZXIsIGlmIGl0IGV4aXN0c1xyXG50eXBlIFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKC4uLmFyZ3M6IEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPChUW1wiYWRkRXZlbnRMaXN0ZW5lclwiXSk+KSA9PiB2b2lkO1xyXG5cclxuLy8gUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgXCJhZGRFdmVudExpc3RlbmVyXCIgKHRoZSBldmVudCB0eXBlIGFzIGEgc3RyaW5nKVxyXG50eXBlIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4gZXh0ZW5kcyAoKHR5cGU6IGluZmVyIEsyLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEsyIDogc3RyaW5nO1xyXG5cclxuXHJcbi8vIFRPRE86IFRoaXMgaXNuJ3QgcXVpdGUgYWJsZSB0byBuYXJyb3cgZG93biB0aGUgZXhhY3QgZXZlbnQgdHlwZSBmb3IgdW5rbm93biByZWFzb25zLlxyXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXHJcbi8vIEkgZG9uJ3Qga25vdyB3aHkgYGluZmVyIEhgIGlzIGRvaW5nIHRoYXQgd2hlbiB0aGUgdHlwZSBzaG91bGQgYmUgbmFycm93ZWQgYnkgYFRgIHRob3VnaC4uLlxyXG4vLyBOb3RlIHRoYXQgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIHN0aWxsIHVzZWQsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3QgbmFycm93IGRvd24gdGhlIHR5cGUsXHJcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcclxudHlwZSBUeXBlZEV2ZW50SGFuZGxlcjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IGluZmVyIEgsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gTm9uTnVsbGFibGU8SD4gOiBuZXZlcjtcclxuLy8oKFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiAmICgodHlwZTogVCwgaGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSkgZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBpbmZlciBIKSA9PiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSCA6IEZ1bmN0aW9uKSAvKiYgKFQgZXh0ZW5kcyBrZXlvZiBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXA/IEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcFtUXSA6IChlOiBFdmVudCkgPT4gdm9pZCkqLztcclxuXHJcbnR5cGUgUGFyYW1ldGVyczI8VCBleHRlbmRzIChFdmVudExpc3RlbmVyT2JqZWN0IHwgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpPiA9XHJcbiAgICBUIGV4dGVuZHMgRXZlbnRMaXN0ZW5lck9iamVjdCA/IFBhcmFtZXRlcnM8VFtcImhhbmRsZUV2ZW50XCJdPiA6XHJcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcclxuXHJcblxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYXR0YWNoaW5nIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW55ICpub24tUHJlYWN0KiBlbGVtZW50LCBhbmQgcmVtb3ZpbmcgaXQgd2hlbiB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBob29rIHVubW91bnRzLiBUaGUgY2FsbGJhY2sgZG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXHJcbiAqIFxyXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcclxuICogXHJcbiAqIGB1c2VFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJpbnB1dFwiKTxJbnB1dEV2ZW50PihlID0+IHt9KWBcclxuICogXHJcbiAqIFRoZSB0eXBlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBidXQgbmFycm93cyBkb3duIHRoZSB0eXBlIGZyb20gXCJhIHVuaW9uIG9mIGFsbCBldmVudHNcIiB0byB3aGF0ZXZlciB5b3Ugc3BlY2lmeSwgYW5kIGVycm9ycyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gKiBcclxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuIFxyXG4gKiBJdCB0YWtlcyBkaWZmZXJlbnQgZXZlbnQgc3RyaW5nIHR5cGVzIChvbkV2ZW50IHZzIG9uZXZlbnQpLlxyXG4gKiBcclxuICogQHBhcmFtIHRhcmdldCBBICpub24tUHJlYWN0KiBub2RlIHRvIGF0dGFjaCB0aGUgZXZlbnQgdG8uXHJcbiAqIEByZXR1cm5zXHJcbiAqICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xyXG5cclxuICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXHJcbiAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxyXG4gICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cclxuICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXHJcblxyXG4gICAgbGV0IHN0YWJsZUhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlciA/PyAoKCkgPT4geyB9KSkgYXMgRXZlbnRMaXN0ZW5lcjtcclxuICAgIGlmIChoYW5kbGVyID09IG51bGwpXHJcbiAgICAgICAgc3RhYmxlSGFuZGxlciA9IG51bGw7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3RhYmxlSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cclxuICogXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gbW9kaWZ5IGEgc2V0IG9mIHByb3BzIHRvIGFwcGx5IHRoaXMgaGFuZGxlci5cclxuICogXHJcbiAqIEZvciB0eXBpbmcgcmVhc29ucywgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdCBpbnRvIHR3by4gIFVzYWdlIGlzIGxpa2UgdGhlIGZvbGxvd2luZzpcclxuICogXHJcbiAqIGBgYFxyXG4gKiBjb25zdCB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfSA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PigpKFwib25Nb3VzZURvd25cIiwgZSA9PiB7ICB9KTtcclxuICogY29uc3QgZGl2UHJvcHMgPSB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzKHByb3BzKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxIYW5kbGVyPEVsZW1lbnRUeXBlIGV4dGVuZHMgKEhUTUxFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXBdIHwgU1ZHRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXBdKT4oKSB7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgaC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIGtleW9mIFByZWFjdERPTUF0dHJpYnV0ZXM+Pih0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IE5vbk51bGxhYmxlPGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YWJsZUhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFbGVtZW50VHlwZT4oeyBbdHlwZV06IHN0YWJsZUhhbmRsZXIgfSBhcyB7IFtLIGluIEV2ZW50VHlwZV06IHR5cGVvZiBoYW5kbGVyIH0sIHByb3BzKSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT47XHJcbiAgICAgICAgfSwgW3R5cGVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9O1xyXG5cclxuICAgIH0sIFtdKTtcclxufVxyXG4iLCJjb25zdCBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICdpbnB1dCcsXG4gICdzZWxlY3QnLFxuICAndGV4dGFyZWEnLFxuICAnYVtocmVmXScsXG4gICdidXR0b24nLFxuICAnW3RhYmluZGV4XTpub3Qoc2xvdCknLFxuICAnYXVkaW9bY29udHJvbHNdJyxcbiAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsXG4gICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScsXG4gICdkZXRhaWxzJyxcbl07XG5jb25zdCBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xuXG5jb25zdCBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IG1hdGNoZXMgPSBOb0VsZW1lbnRcbiAgPyBmdW5jdGlvbiAoKSB7fVxuICA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuY29uc3QgZ2V0Um9vdE5vZGUgPVxuICAhTm9FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlXG4gICAgPyAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRSb290Tm9kZSgpXG4gICAgOiAoZWxlbWVudCkgPT4gZWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciB0byBjaGVja1xuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgbGV0IGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoXG4gICAgZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcilcbiAgKTtcbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEdldFNoYWRvd1Jvb3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVjayBmb3Igc2hhZG93IHJvb3RcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fGJvb2xlYW59IFNoYWRvd1Jvb3QgaWYgYXZhaWxhYmxlIG9yIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHNoYWRvd1Jvb3QgaXMgYXR0YWNoZWQgYnV0IG5vdCBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2hhZG93Um9vdEZpbHRlclxuICogQHBhcmFtIHtFbGVtZW50fSBzaGFkb3dIb3N0Tm9kZSB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyBzaGFkb3cgY29udGVudFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBzaGFkb3cgcm9vdCBjb3VsZCBwb3RlbnRpYWxseSBjb250YWluIHZhbGlkIGNhbmRpZGF0ZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW5kaWRhdGVzU2NvcGVcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gc2NvcGUgY29udGFpbnMgaW5uZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtFbGVtZW50W119IGNhbmRpZGF0ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEl0ZXJhdGl2ZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7R2V0U2hhZG93Um9vdHxib29sZWFufSBnZXRTaGFkb3dSb290IHRydWUgaWYgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZDsgZmFsc3kgaWYgbm90O1xuICogIGlmIGEgZnVuY3Rpb24sIGltcGxpZXMgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZCBhbmQgZWl0aGVyIHJldHVybnMgdGhlIHNoYWRvdyByb290IG9mIGFuIGVsZW1lbnRcbiAqICBvciBhIGJvb2xlYW4gc3RhdGluZyBpZiBpdCBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHJvb3RcbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBmbGF0dGVuIGlmIHRydWUgdGhlbiByZXN1bHQgd2lsbCBmbGF0dGVuIGFueSBDYW5kaWRhdGVzU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgbGlzdCBvZiBlbGVtZW50IGNvbnRhaW5lcnMgdG8gbWF0Y2ggY2FuZGlkYXRlcyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVzU2NvcGU+fVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiAoXG4gIGVsZW1lbnRzLFxuICBpbmNsdWRlQ29udGFpbmVyLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICBjb25zdCBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcbiAgd2hpbGUgKGVsZW1lbnRzVG9DaGVjay5sZW5ndGgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NMT1QnKSB7XG4gICAgICAvLyBhZGQgc2hhZG93IGRvbSBzbG90IHNjb3BlIChzbG90IGl0c2VsZiBjYW5ub3QgYmUgZm9jdXNhYmxlKVxuICAgICAgY29uc3QgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGNvbnRlbnQsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgY29uc3QgdmFsaWRDYW5kaWRhdGUgPSBtYXRjaGVzLmNhbGwoZWxlbWVudCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWxpZENhbmRpZGF0ZSAmJlxuICAgICAgICBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJlxuICAgICAgICAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpXG4gICAgICApIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPVxuICAgICAgICBlbGVtZW50LnNoYWRvd1Jvb3QgfHxcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICAodHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU2hhZG93Um9vdCA9XG4gICAgICAgICFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoc2hhZG93Um9vdCAmJiB2YWxpZFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2NvcGUgSUlGIGEgc2hhZG93IHJvb3Qgbm9kZSB3YXMgZ2l2ZW47IG90aGVyd2lzZSwgYW4gdW5kaXNjbG9zZWRcbiAgICAgICAgLy8gIHNoYWRvdyBleGlzdHMsIHNvIGxvb2sgYXQgbGlnaHQgZG9tIGNoaWxkcmVuIGFzIGZhbGxiYWNrIEJVVCBjcmVhdGUgYSBzY29wZSBmb3IgYW55XG4gICAgICAgIC8vICBjaGlsZCBjYW5kaWRhdGVzIGZvdW5kIGJlY2F1c2UgdGhleSdyZSBsaWtlbHkgc2xvdHRlZCBlbGVtZW50cyAoZWxlbWVudHMgdGhhdCBhcmVcbiAgICAgICAgLy8gIGNoaWxkcmVuIG9mIHRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgKHdoaWNoIGhhcyB0aGUgc2hhZG93KSwgaW4gdGhlIGxpZ2h0IGRvbSwgYnV0XG4gICAgICAgIC8vICBzbG90dGVkIHNvbWV3aGVyZSBfaW5zaWRlXyB0aGUgdW5kaXNjbG9zZWQgc2hhZG93KSAtLSB0aGUgc2NvcGUgaXMgY3JlYXRlZCBiZWxvdyxcbiAgICAgICAgLy8gIF9hZnRlcl8gd2UgcmV0dXJuIGZyb20gdGhpcyByZWN1cnNpdmUgY2FsbFxuICAgICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFxuICAgICAgICAgIHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm90IHNoYWRvdyBzbyBqdXN0IGRpZyBpbnRvIHRoZSBlbGVtZW50J3MgKGxpZ2h0IGRvbSkgY2hpbGRyZW5cbiAgICAgICAgLy8gIF9fd2l0aG91dF9fIGdpdmluZyB0aGUgZWxlbWVudCBzcGVjaWFsIHNjb3BlIHRyZWF0bWVudFxuICAgICAgICBlbGVtZW50c1RvQ2hlY2sudW5zaGlmdCguLi5lbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIChub2RlLCBpc1Njb3BlKSB7XG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gICAgLy8gb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwLlxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuICAgIC8vXG4gICAgLy8gaXNTY29wZSBpcyBwb3NpdGl2ZSBmb3IgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQgYnkgZGVmYXVsdFxuICAgIC8vIGhhdmUgdGFiSW5kZXggLTEsIGJ1dCBuZWVkIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgdGhlaXJcbiAgICAvLyBjb250ZW50IHRvIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgaWYgKFxuICAgICAgKGlzU2NvcGUgfHxcbiAgICAgICAgL14oQVVESU98VklERU98REVUQUlMUykkLy50ZXN0KG5vZGUudGFnTmFtZSkgfHxcbiAgICAgICAgbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkgJiZcbiAgICAgIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbmNvbnN0IHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXhcbiAgICA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlclxuICAgIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59O1xuXG5jb25zdCBpc0lucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG5cbmNvbnN0IGlzSGlkZGVuSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxuY29uc3QgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCByID1cbiAgICBub2RlLnRhZ05hbWUgPT09ICdERVRBSUxTJyAmJlxuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmFwcGx5KG5vZGUuY2hpbGRyZW4pXG4gICAgICAuc29tZSgoY2hpbGQpID0+IGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJyk7XG4gIHJldHVybiByO1xufTtcblxuY29uc3QgZ2V0Q2hlY2tlZFJhZGlvID0gZnVuY3Rpb24gKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIGNvbnN0IHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJ1xuICAgICk7XG4gIH07XG5cbiAgbGV0IHJhZGlvU2V0O1xuICBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUy5lc2NhcGUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdMb29rcyBsaWtlIHlvdSBoYXZlIGEgcmFkaW8gYnV0dG9uIHdpdGggYSBuYW1lIGF0dHJpYnV0ZSBjb250YWluaW5nIGludmFsaWQgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgYW5kIG5lZWQgdGhlIENTUy5lc2NhcGUgcG9seWZpbGw6ICVzJyxcbiAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59O1xuXG5jb25zdCBpc1JhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxuY29uc3QgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn07XG5cbi8vIGRldGVybWluZXMgaWYgYSBub2RlIGlzIHVsdGltYXRlbHkgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdydzIGRvY3VtZW50XG5jb25zdCBpc05vZGVBdHRhY2hlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIC8vIFRoZSByb290IG5vZGUgaXMgdGhlIHNoYWRvdyByb290IGlmIHRoZSBub2RlIGlzIGluIGEgc2hhZG93IERPTTsgc29tZSBkb2N1bWVudCBvdGhlcndpc2VcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xuICAvLyAgaXMgYXR0YWNoZWQsIGFuZCB0aGUgb25lIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBpbiB0aGUgZG9jdW1lbnQgb3Igbm90IChiZWNhdXNlIHRoZVxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxuICAvLyAgaXMgaGlkZGVuLCBvciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGl0c2VsZiBidXQgaXMgZGV0YWNoZWQsIGl0IHdpbGwgYWZmZWN0IHRoZSBzaGFkb3cnc1xuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgLy8gIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBub3QgdGhlIHNoYWRvdyByb290LCBub3IgYW55IG9mIGl0cyBjaGlsZHJlbiAoaS5lLiB0aGUgbm9kZSBiZWluZ1xuICAvLyAgdGVzdGVkKS5cbiAgLy8gVG8gZnVydGhlciBjb21wbGljYXRlIHRoaW5ncywgd2UgaGF2ZSB0byBsb29rIGFsbCB0aGUgd2F5IHVwIHVudGlsIHdlIGZpbmQgYSBzaGFkb3cgSE9TVFxuICAvLyAgdGhhdCBpcyBhdHRhY2hlZCAob3IgZmluZCBub25lKSBiZWNhdXNlIHRoZSBub2RlIG1pZ2h0IGJlIGluIG5lc3RlZCBzaGFkb3dzLi4uXG4gIC8vIElmIHJvb3ROb2RlIGlzIG5vdCBhIHNoYWRvdyByb290LCBpdCB3b24ndCBoYXZlIGEgaG9zdCwgYW5kIHNvIHJvb3ROb2RlIHNob3VsZCBiZSB0aGVcbiAgLy8gIGRvY3VtZW50IChwZXIgdGhlIGRvY3MpIGFuZCB3aGlsZSBpdCdzIGEgRG9jdW1lbnQtdHlwZSBvYmplY3QsIHRoYXQgZG9jdW1lbnQgZG9lcyBub3RcbiAgLy8gIGFwcGVhciB0byBiZSB0aGUgc2FtZSBhcyB0aGUgbm9kZSdzIGBvd25lckRvY3VtZW50YCBmb3Igc29tZSByZWFzb24sIHNvIGl0J3Mgc2FmZXJcbiAgLy8gIHRvIGlnbm9yZSB0aGUgcm9vdE5vZGUgYXQgdGhpcyBwb2ludCwgYW5kIHVzZSBgbm9kZS5vd25lckRvY3VtZW50YC4gT3RoZXJ3aXNlLFxuICAvLyAgdXNpbmcgYHJvb3ROb2RlLmNvbnRhaW5zKG5vZGUpYCB3aWxsIF9hbHdheXNfIGJlIHRydWUgd2UnbGwgZ2V0IGZhbHNlLXBvc2l0aXZlcyB3aGVuXG4gIC8vICBub2RlIGlzIGFjdHVhbGx5IGRldGFjaGVkLlxuICBsZXQgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZSkuaG9zdDtcbiAgbGV0IGF0dGFjaGVkID0gISEoXG4gICAgbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHxcbiAgICBub2RlLm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZSlcbiAgKTtcblxuICB3aGlsZSAoIWF0dGFjaGVkICYmIG5vZGVSb290SG9zdCkge1xuICAgIC8vIHNpbmNlIGl0J3Mgbm90IGF0dGFjaGVkIGFuZCB3ZSBoYXZlIGEgcm9vdCBob3N0LCB0aGUgbm9kZSBNVVNUIGJlIGluIGEgbmVzdGVkIHNoYWRvdyBET00sXG4gICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gZ2V0IHRoZSBob3N0J3MgaG9zdCBhbmQgY2hlY2sgaWYgdGhhdCBwYXJlbnQgaG9zdCBpcyBjb250YWluZWRcbiAgICAvLyAgaW4gKGkuZS4gYXR0YWNoZWQgdG8pIHRoZSBkb2N1bWVudFxuICAgIG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGVSb290SG9zdCkuaG9zdDtcbiAgICBhdHRhY2hlZCA9ICEhbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCk7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoZWQ7XG59O1xuXG5jb25zdCBpc1plcm9BcmVhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcbmNvbnN0IGlzSGlkZGVuID0gZnVuY3Rpb24gKG5vZGUsIHsgZGlzcGxheUNoZWNrLCBnZXRTaGFkb3dSb290IH0pIHtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIGNvbnN0IG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgICFkaXNwbGF5Q2hlY2sgfHxcbiAgICBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJyB8fFxuICAgIGRpc3BsYXlDaGVjayA9PT0gJ2xlZ2FjeS1mdWxsJ1xuICApIHtcbiAgICBpZiAodHlwZW9mIGdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZSBub2RlIHRvIGJlIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyBhbmQgdXNlIHRoZVxuICAgICAgLy8gICdub24temVyby1hcmVhJyBmYWxsYmFja1xuICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJlxuICAgICAgICAgIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkgPT09IHRydWUgLy8gY2hlY2sgaWYgdGhlcmUncyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbm9kZSBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHdoaWNoIG1lYW5zIHdlIGNhbiBvbmx5IHRyZWF0IGl0IGFzIGEgYmxhY2sgYm94LCBzbyB3ZVxuICAgICAgICAgIC8vICBmYWxsIGJhY2sgdG8gYSBub24temVyby1hcmVhIHRlc3RcbiAgICAgICAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgc2xvdFxuICAgICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgfSBlbHNlIGlmICghcGFyZW50RWxlbWVudCAmJiByb290Tm9kZSAhPT0gbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgLy8gY3Jvc3Mgc2hhZG93IGJvdW5kYXJ5XG4gICAgICAgICAgbm9kZSA9IHJvb3ROb2RlLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBub3JtYWwgZG9tXG4gICAgICAgICAgbm9kZSA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG9yaWdpbmFsTm9kZTtcbiAgICB9XG4gICAgLy8gZWxzZSwgYGdldFNoYWRvd1Jvb3RgIG1pZ2h0IGJlIHRydWUsIGJ1dCBhbGwgdGhhdCBkb2VzIGlzIGVuYWJsZSBzaGFkb3cgRE9NIHN1cHBvcnRcbiAgICAvLyAgKGkuZS4gaXQgZG9lcyBub3QgYWxzbyBwcmVzdW1lIHRoYXQgYWxsIG5vZGVzIG1pZ2h0IGhhdmUgdW5kaXNjbG9zZWQgc2hhZG93cyk7IG9yXG4gICAgLy8gIGl0IG1pZ2h0IGJlIGEgZmFsc3kgdmFsdWUsIHdoaWNoIG1lYW5zIHNoYWRvdyBET00gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxuICAgIC8vICBub3cgd2UgY2FuIGp1c3QgdGVzdCB0byBzZWUgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgdmlzaWJsZSBvciBub3QsIHByb3ZpZGVkIGl0J3NcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cbiAgICAvLyAgYGlzVGFiYmFibGUoKWAgb3IgYGlzRm9jdXNhYmxlKClgIC0tIHJlZ2FyZGxlc3Mgb2YgYGdldFNoYWRvd1Jvb3RgIG9wdGlvbiBzZXR0aW5nLlxuXG4gICAgaWYgKGlzTm9kZUF0dGFjaGVkKG5vZGUpKSB7XG4gICAgICAvLyB0aGlzIHdvcmtzIHdoZXJldmVyIHRoZSBub2RlIGlzOiBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBjbGllbnQgcmVjdCwgaXQnc1xuICAgICAgLy8gIHNvbWVob3cgZGlzcGxheWVkOyBpdCBhbHNvIGNvdmVycyB0aGUgQ1NTICdkaXNwbGF5OiBjb250ZW50cycgY2FzZSB3aGVyZSB0aGVcbiAgICAgIC8vICBub2RlIGl0c2VsZiBpcyBoaWRkZW4gaW4gcGxhY2Ugb2YgaXRzIGNvbnRlbnRzOyBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaFxuICAgICAgLy8gIHVwIHRoZSBoaWVyYXJjaHkgZWl0aGVyXG4gICAgICByZXR1cm4gIW5vZGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gRWxzZSwgdGhlIG5vZGUgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGUgYGdldENsaWVudFJlY3RzKClgXG4gICAgLy8gIEFQSSB3aWxsIF9fYWx3YXlzX18gcmV0dXJuIHplcm8gcmVjdHMgKHRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIFJlYWN0XG4gICAgLy8gIGlzIHVzZWQgdG8gcmVuZGVyIG5vZGVzIG9udG8gYSBkZXRhY2hlZCB0cmVlLCBhcyBjb25maXJtZWQgaW4gdGhpcyB0aHJlYWQ6XG4gICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTExNyNpc3N1ZWNvbW1lbnQtMjg0MjI4ODcwKVxuICAgIC8vXG4gICAgLy8gSXQgYWxzbyBtZWFucyB0aGF0IGV2ZW4gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSB3aWxsIHJldHVybiBgdW5kZWZpbmVkYFxuICAgIC8vICBiZWNhdXNlIHN0eWxlcyBhcmUgb25seSBjb21wdXRlZCBmb3Igbm9kZXMgdGhhdCBhcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgIC8vXG4gICAgLy8gTk9URTogVEhJUyBIQVMgQkVFTiBUSEUgQ0FTRSBGT1IgWUVBUlMuIEl0IGlzIG5vdCBuZXcsIG5vciBpcyBpdCBjYXVzZWQgYnkgdGFiYmFibGVcbiAgICAvLyAgc29tZWhvdy4gVGhvdWdoIGl0IHdhcyBuZXZlciBzdGF0ZWQgb2ZmaWNpYWxseSwgYW55b25lIHdobyBoYXMgZXZlciB1c2VkIHRhYmJhYmxlXG4gICAgLy8gIEFQSXMgb24gbm9kZXMgaW4gZGV0YWNoZWQgY29udGFpbmVycyBoYXMgYWN0dWFsbHkgaW1wbGljaXRseSB1c2VkIHRhYmJhYmxlIGluIHdoYXRcbiAgICAvLyAgd2FzIGxhdGVyIChhcyBvZiB2NS4yLjAgb24gQXByIDksIDIwMjEpIGNhbGxlZCBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBtb2RlIC0tIGVzc2VudGlhbGx5XG4gICAgLy8gIGNvbnNpZGVyaW5nIF9fZXZlcnl0aGluZ19fIHRvIGJlIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgaW5uYWJpbGl0eSB0byBkZXRlcm1pbmUgc3R5bGVzLlxuICAgIC8vXG4gICAgLy8gdjYuMC4wOiBBcyBvZiB0aGlzIG1ham9yIHJlbGVhc2UsIHRoZSBkZWZhdWx0ICdmdWxsJyBvcHRpb24gX19ubyBsb25nZXIgdHJlYXRzIGRldGFjaGVkXG4gICAgLy8gIG5vZGVzIGFzIHZpc2libGUgd2l0aCB0aGUgJ25vbmUnIGZhbGxiYWNrLl9fXG4gICAgaWYgKGRpc3BsYXlDaGVjayAhPT0gJ2xlZ2FjeS1mdWxsJykge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGhpZGRlblxuICAgIH1cbiAgICAvLyBlbHNlLCBmYWxsYmFjayB0byAnbm9uZScgbW9kZSBhbmQgY29uc2lkZXIgdGhlIG5vZGUgdmlzaWJsZVxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gJ25vbi16ZXJvLWFyZWEnKSB7XG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxuICAgIC8vICBjbGllbnQgcmVjdCwgd2UgZG9uJ3Qgc3BlY2lhbC1jYXNlIGZvciB3aGV0aGVyIHRoZSBub2RlIGlzIGF0dGFjaGVkIG9yIG5vdC4gSW5cbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXG4gICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gIH1cblxuICAvLyB2aXNpYmxlLCBhcyBmYXIgYXMgd2UgY2FuIHRlbGwsIG9yIHBlciBjdXJyZW50IGBkaXNwbGF5Q2hlY2s9bm9uZWAgbW9kZSwgd2UgYXNzdW1lXG4gIC8vICBpdCdzIHZpc2libGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gZm9ybSBmaWVsZHMgKG5lc3RlZCkgaW5zaWRlIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIG5vdCBmb2N1c2FibGUvdGFiYmFibGVcbi8vICB1bmxlc3MgdGhleSBhcmUgaW4gdGhlIF9maXJzdF8gPGxlZ2VuZD4gZWxlbWVudCBvZiB0aGUgdG9wLW1vc3QgZGlzYWJsZWRcbi8vICBmaWVsZHNldFxuY29uc3QgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICAvLyBsb29rIGZvciB0aGUgZmlyc3QgPGxlZ2VuZD4gYW1vbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IDxsZWdlbmQ+IChpbiBkb2N1bWVudCBvcmRlcikgaXMgZm91bmRcbiAgICAgICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHBhcmVudE5vZGUsICdmaWVsZHNldFtkaXNhYmxlZF0gKicpXG4gICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICA6ICFjaGlsZC5jb250YWlucyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRpc2FibGVkIDxmaWVsZHNldD4gY29udGFpbmluZyBgbm9kZWAgaGFzIG5vIDxsZWdlbmQ+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvLyBlbHNlLCBub2RlJ3MgdGFiYmFibGUvZm9jdXNhYmxlIHN0YXRlIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgYSBmaWVsZHNldCdzXG4gIC8vICBlbmFibGVkL2Rpc2FibGVkIHN0YXRlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgbm9kZS5kaXNhYmxlZCB8fFxuICAgIGlzSGlkZGVuSW5wdXQobm9kZSkgfHxcbiAgICBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fFxuICAgIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICAgIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHx8XG4gICAgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8XG4gICAgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8XG4gICAgIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIChzaGFkb3dIb3N0Tm9kZSkge1xuICBjb25zdCB0YWJJbmRleCA9IHBhcnNlSW50KHNoYWRvd0hvc3ROb2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICBpZiAoaXNOYU4odGFiSW5kZXgpIHx8IHRhYkluZGV4ID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBhIGN1c3RvbSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSB0YWJpbmRleCxcbiAgLy8gYnJvd3NlcnMgd2lsbCBub3QgYWxsb3cgdGFiIHRhcmdldGluZyBzYWlkIGVsZW1lbnQncyBjaGlsZHJlbi5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG5jb25zdCBzb3J0QnlPcmRlciA9IGZ1bmN0aW9uIChjYW5kaWRhdGVzKSB7XG4gIGNvbnN0IHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgY29uc3Qgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBjb25zdCBpc1Njb3BlID0gISFpdGVtLnNjb3BlO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBpc1Njb3BlID8gaXRlbS5zY29wZSA6IGl0ZW07XG4gICAgY29uc3QgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IGlzU2NvcGUgPyBzb3J0QnlPcmRlcihpdGVtLmNhbmRpZGF0ZXMpIDogZWxlbWVudDtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGVcbiAgICAgICAgPyByZWd1bGFyVGFiYmFibGVzLnB1c2goLi4uZWxlbWVudHMpXG4gICAgICAgIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzLFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlc1xuICAgIC5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKVxuICAgIC5yZWR1Y2UoKGFjYywgc29ydGFibGUpID0+IHtcbiAgICAgIHNvcnRhYmxlLmlzU2NvcGVcbiAgICAgICAgPyBhY2MucHVzaCguLi5zb3J0YWJsZS5jb250ZW50KVxuICAgICAgICA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcblxuY29uc3QgdGFiYmFibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IGZhbHNlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgICAgc2hhZG93Um9vdEZpbHRlcjogaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGlzVGFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5jb25zdCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnNcbiAgLmNvbmNhdCgnaWZyYW1lJylcbiAgLmpvaW4oJywnKTtcblxuY29uc3QgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuZXhwb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgaXNGb2N1c2FibGUgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnaW5lcnQnLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICAgKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICAgKi9cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zbGljZX0gKi9cbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiBJRSBoYXMgYSBub24tc3RhbmRhcmQgbmFtZSBmb3IgXCJtYXRjaGVzXCIuXG4gICAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgICAqL1xuICAgIHZhciBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgICAqIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtIHRvIGNyZWF0ZSBhbmQgbWFpbnRhaW4gYSBzZXQgb2YgbWFuYWdlZCBgSW5lcnROb2RlYHMsIGluY2x1ZGluZyB3aGVuIG11dGF0aW9ucyBvY2N1ciBpbiB0aGVcbiAgICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAgICogICBmb2N1c2FibGUgbm9kZXMgd2l0aGluIGluZXJ0IHN1YnRyZWVzLiBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWBcbiAgICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAgICpcbiAgICAgKiAtIHRvIG5vdGlmeSBhbGwgbWFuYWdlZCBgSW5lcnROb2RlYHMgd2hlbiB0aGlzIHN1YnRyZWUgc3RvcHMgYmVpbmcgaW5lcnQgKGkuZS4gd2hlbiB0aGUgYGluZXJ0YFxuICAgICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgICAqL1xuXG4gICAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50IFRoZSBIVE1MRWxlbWVudCBhdCB0aGUgcm9vdCBvZiB0aGUgaW5lcnQgc3VidHJlZS5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gaW5lcnRNYW5hZ2VyO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Um9vdCwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hbmFnZU5vZGUoaW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgIC8vIDEpIFdlIHdhbnQgdGhlIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZGVjbGFyZWQgYXMgbm9uLW51bGwsIG9yIGVsc2Ugd2VcbiAgICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAgIC8vIDIpIFdlIGRvbid0IHdhbnQgdG8gY2FzdCBcInRoaXNcIiwgYmVjYXVzZSB3ZSB3YW50IHR5cGUtYXdhcmUgb3B0aW1pemF0aW9uc1xuICAgICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl92aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc3RhcnROb2RlKSkge1xuICAgICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyFTaGFkb3dSb290fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgLy8gSW4gSUUxMSwgaWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFuZCB0aGVuIHNldCB0byB0YWJpbmRleD0tMVxuICAgICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ192aXNpdE5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VTdWJ0cmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0U3Vicm9vdC5tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc2F2ZWRJbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgIC8vIE1hbmFnZSBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnaW5lcnQnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ21hbmFnZWROb2RlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRSb290O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgICAqIFRoaXMgbWFrZXMgdGhlIG1hbmFnZWQgbm9kZSBmb2N1c2FibGUgYWdhaW4gYW5kIGRlbGV0ZXMgYWxsIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCBzdGF0ZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbm9kZSAmJiB0aGlzLl9ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5fc2F2ZWRUYWJJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZSBub3RlIGluIEluZXJ0Um9vdC5kZXN0cnVjdG9yIGZvciB3aHkgd2UgY2FzdCB0aGVzZSBudWxscyB0byBBTlkuXG4gICAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9ic29sZXRlIGJlY2F1c2UgdGhlIG1hbmFnZWQgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaHJvdyBpZiB1c2VyIHRyaWVzIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdlbnN1cmVVbnRhYmJhYmxlJyxcblxuXG4gICAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMubm9kZTtcbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIElmIHRoZSBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydCxcbiAgICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHshTm9kZX0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdub2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE5vZGU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgICAqXG4gICAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE1hbmFnZXIoZG9jdW1lbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDsgSW5lcnRNYW5hZ2VyIG5lZWRzIHRvIHdyYXAgYSBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Tm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl93YXRjaEZvckluZXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBiZSBsb2FkZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0TWFuYWdlciwgW3tcbiAgICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgICBpZiAoaW5lcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCdpbmVydCcsICcnKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgICAvLyBFbnN1cmUgaW5lcnQgc3R5bGVzIGFyZSBhZGRlZCB0aGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydFJvb3R8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIG5vZGUgaGFzIGEgcHJldmlvdXNseSBleGlzdGluZyBpbmVydCByb290LCB0aGlzIGluZXJ0IHJvb3Qgd2lsbFxuICAgICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgICAgaW5lcnROb2RlLmFkZEluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbmVydCByb290IGZyb20gdGhlIEluZXJ0Tm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cywgYW5kIHJlbW92ZSB0aGUgaW5lcnRcbiAgICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gZG9jdW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbkRvY3VtZW50TG9hZGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6XG4gICAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsICdbaW5lcnRdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lICE9PSAnaW5lcnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHs/U2hhZG93Um9vdD19IHNoYWRvd1Jvb3RBbmNlc3RvciBUaGUgbmVhcmVzdCBTaGFkb3dSb290IGFuY2VzdG9yLCBpZiBhbnkuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgICB2YXIgc2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSAvKiogQHR5cGUgeyFIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Rpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBuZWl0aGVyIHRoZSBwYXJlbnQgb2YgYSBTaGFkb3dSb290LCBhIDxjb250ZW50PiBlbGVtZW50LCBhIDxzbG90PlxuICAgICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0eWxlIGVsZW1lbnQgdG8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgaW5lcnQgc3BlY2lmaWMgc3R5bGVzXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEluZXJ0U3R5bGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAnXFxuJyArICdbaW5lcnRdIHtcXG4nICsgJyAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuJyArICcgIGN1cnNvcjogZGVmYXVsdDtcXG4nICsgJ31cXG4nICsgJ1xcbicgKyAnW2luZXJ0XSwgW2luZXJ0XSAqIHtcXG4nICsgJyAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICB1c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJ31cXG4nO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFIVE1MRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2luZXJ0JykpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2luZXJ0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pKCk7XG5cbn0pKSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJpbXBvcnQgXCJ3aWNnLWluZXJ0XCI7XG5pbXBvcnQgXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyB9IGZyb20gXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG5mdW5jdGlvbiBibG9ja2luZ0VsZW1lbnRzKCkgeyByZXR1cm4gKGdldERvY3VtZW50KCkgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgfVxuLyoqXG4gKiBBbGxvd3MgYW4gZWxlbWVudCB0byB0cmFwIGZvY3VzIGJ5IGFwcGx5aW5nIHRoZSBcImluZXJ0XCIgYXR0cmlidXRlIHRvIGFsbCBzaWJsaW5nLCBhdW50LCBhbmQgdW5jbGUgbm9kZXMuXG4gKiBcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBjb25zZWN1dGl2ZSBjYWxscyB3aXRoIGEgbG9vc2VseSBhcHBsaWVkIHN0YWNrIG9wZXJhdGlvbiBcbiAqIChzcGVjaWZpY2FsbHkgdmlhIGBibG9ja2luZ0VsZW1lbnRzYCwgd2l0aCBhIHNtYWxsIHBvbHlmaWxsIGJlY2F1c2UgSSdtIG5vdCBzdXJlIGhvdyBsb25nXG4gKiBpdCdsbCB0YWtlIHRvIGZpbmQgaXRzIHdheSBpbnRvIHRoZSBzcGVjLCBpZiBldmVyKVxuICogQHBhcmFtIHRhcmdldCBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2NraW5nRWxlbWVudDxFIGV4dGVuZHMgRWxlbWVudD4oZW5hYmxlZDogYm9vbGVhbiwgZ2V0VGFyZ2V0OiAoKSA9PiAoRSB8IG51bGwpKSB7XG5cbiAgICBjb25zdCBzdGFibGVHZXRUYXJnZXQgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRUYXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogUHVzaC9wb3AgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmdFbGVtZW50cyBzdGFjay5cbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBzdGFibGVHZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIGJsb2NraW5nRWxlbWVudHMgd2lsbCBmYWlsIGlmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgZWxlbWVudCBpc24ndCBjb25uZWN0ZWQgdG8gZG9jdW1lbnQuYm9keS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmFyZSwgYnV0IGl0J3MgYmV0dGVyIHRvIGZhaWwgc2lsZW50bHkgd2l0aCB3ZWlyZCB0YWJiaW5nIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyB0aGFuIHRvIGNyYXNoIHRoZSBlbnRpcmUgYXBwbGljYXRpb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5wdXNoKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucmVtb3ZlKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gV2VsbCwgc2VtaS1zaWxlbnRseS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtlbmFibGVkXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BFbGVtZW50KCkge1xuICAgIHJldHVybiBibG9ja2luZ0VsZW1lbnRzKCkudG9wO1xufVxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgaXNGb2N1c2FibGUgfSBmcm9tIFwidGFiYmFibGVcIjtcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcbmltcG9ydCB7IGdldFRvcEVsZW1lbnQsIHVzZUJsb2NraW5nRWxlbWVudCB9IGZyb20gXCIuL3VzZS1ibG9ja2luZy1lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUGFyYW1ldGVycyB7IHRyYXBBY3RpdmU6IGJvb2xlYW47IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+IHtcbiAgICAvKiogKlVuc3RhYmxlKiAocmVsaWVzIG9uIHRoZSBgdHJhcEFjdGl2ZWAgcHJvcCkgKi9cbiAgICB1c2VGb2N1c1RyYXBQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG59XG5cbmNvbnN0IGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUbyA9IG5ldyBNYXA8RWxlbWVudCB8IG51bGwsIChOb2RlICYgSFRNTE9yU1ZHRWxlbWVudCk+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1RyYXA8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHRyYXBBY3RpdmUgfTogVXNlRm9jdXNUcmFwUGFyYW1ldGVycyk6IFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RT4ge1xuICAgIFxuICAgIGNvbnN0IGhhbmRsZUFjdGl2ZUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFwQWN0aXZlOiBib29sZWFuLCBlbGVtZW50OiBFIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXh0cmEgcXVldWVNaWNyb3Rhc2sgaXMgbmVlZGVkIGZvclxuICAgICAgICAgICAgICAgIC8vIC4uLnJlYXNvbnM/XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBmb2N1cyB0byB0aGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gdGhhdCBoYXMgcmV0dXJuZWQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvLmdldChnZXRUb3BFbGVtZW50KCkpPy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oeyBvbkVsZW1lbnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCkgPT4gaGFuZGxlQWN0aXZlQ2hhbmdlKHRyYXBBY3RpdmUsIGVsZW1lbnQpKSB9KVxuICAgIGNvbnN0IHsgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoeyBnZXREb2N1bWVudDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gZ2V0RWxlbWVudCgpPy5vd25lckRvY3VtZW50ID8/IHdpbmRvdy5kb2N1bWVudCApIH0pO1xuXG5cbiAgICAvLyBXaGVuIHRoZSB0cmFwIGJlY29tZXMgYWN0aXZlLCBiZWZvcmUgd2UgbGV0IHRoZSBibG9ja2luZ0VsZW1lbnRzIGhvb2sgcnVuLFxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hhdGV2ZXIncyBjdXJyZW50bHkgZm9jdXNlZCBhbmQgc2F2ZSBpdC5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICAvLyB0byB3aGF0ZXZlcidzIGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvLnNldChnZXRUb3BFbGVtZW50KCksIChnZXRMYXN0QWN0aXZlRWxlbWVudCgpIGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkpID8/IGRvY3VtZW50LmJvZHkpO1xuICAgICAgICB9XG4gICAgfSwgW3RyYXBBY3RpdmVdKTtcblxuICAgIHVzZUJsb2NraW5nRWxlbWVudCh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KTtcblxuICAgIC8qKlxuICAgICAqIEFueSB0aW1lIHdlIGFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIHRyYXAsXG4gICAgICogY2hhbmdlIGZvY3VzIHRvIHNvbWV0aGluZyBlbHNlIChzb21ldGhpbmcgaW5cbiAgICAgKiB0aGUgdHJhcCBpZiBpdCdzIGFjdGl2ZSwgb3Igd2hhdGV2ZXIgd2UndmVcbiAgICAgKiB0cmFja2VkIGluIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUbyBpZiBub3QpXG4gICAgICovXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaGFuZGxlQWN0aXZlQ2hhbmdlKHRyYXBBY3RpdmUsIGdldEVsZW1lbnQoKSk7XG4gICAgfSwgW3RyYXBBY3RpdmVdKTtcblxuICAgIGNvbnN0IHVzZUZvY3VzVHJhcFByb3BzID0gKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IHtcbiAgICAgICAgY29uc3QgcDEgPSB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgICAgICBjb25zdCBwMiA9IHsgXCJhcmlhLW1vZGFsXCI6IHRyYXBBY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4ocDEsIHAyKTtcbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlRm9jdXNUcmFwUHJvcHMsXG4gICAgICAgIGdldEVsZW1lbnRcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGdpdmVuIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBhcmUgZm91bmQuXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQ6IE5vZGUpIHtcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSlcbiAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IHRyZWVXYWxrZXIuZmlyc3RDaGlsZCgpIGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsO1xuICAgIHJldHVybiBmaXJzdEZvY3VzYWJsZTtcbn1cblxuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsLCB3aGVuIGNhbGxlZCwgZm9yY2UgdGhlIGNvbXBvbmVudFxuICogdGhhdCB1c2VzIHRoaXMgaG9vayB0byByZS1yZW5kZXIgaXRzZWxmLlxuICogXG4gKiBJdCdzIGEgYml0IHNtZWxseSwgc28gYmVzdCB0byB1c2Ugc3BhcmluZ2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgWywgc2V0XSA9IHVzZVN0YXRlKDApO1xuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcbn0iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGl0c2VsZiBjdXJyZW50bHkgaGFzIGZvY3VzLlxyXG4gICAgICogXHJcbiAgICAgKiBgcHJldkZvY3VzZWRgIGlzIGdlbmVyYWxseSB0aGUgb3Bwb3NpdGUgb2YgYGZvY3VzZWRgLCBidXQgb24gbW91bnQgaXQncyBgdW5kZWZpbmVkYCB3aGlsZSBgZm9jdXNlZGAgaXMgcHJvYmFibHkgZmFsc2UgKGJvdGggZmFsc3kpXHJcbiAgICAgKi9cclxuICAgIG9uRm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpa2UgYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgYWxzbyAqYWRkaXRpb25hbGx5KiBpZiBhbnkgY2hpbGQgZWxlbWVudHMgYXJlIGZvY3VzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBzZWUgdGhpcy5vbkZvY3VzZWRDaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZD8oZm9jdXNlZDogYm9vbGVhbiwgcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltaWxhciB0byBgb25Gb2N1c2VkQ2hhbmdlZGAsIGJ1dCBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LCBpcyBgdHJ1ZWAgaWYgdGhpcyBlbGVtZW50IHRoYXQgKmRpZCogaGF2ZSBmb2N1cyBsYXN0LlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIGlzIGFsd2F5cyBgdHJ1ZWAgd2hpbGUgYGZvY3VzZWRgIGlzIGB0cnVlYC4gSWYgYGZvY3VzZWRgIGlzIGBmYWxzZWAsIHRoaXMgbWF5IGJlIGB0cnVlYCBvciBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZD8oZm9jdXNlZDogYm9vbGVhbiwgcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZXMgdGhlIGltcGxpY2F0aW9ucyBvZiBgb25Gb2N1c2VkQ2hhbmdlZGAgYW5kIGBvbkZvY3VzZWRDaGFuZ2VkYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8oZm9jdXNlZDogYm9vbGVhbiwgcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUhhc0ZvY3VzUmV0dXJuVHlwZTxUIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiwgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZpZXMgdGhlIGVsZW1lbnQgdG8gYmUgYWJsZSB0byB0cmFjayBpdHMgb3duIGZvY3VzIHN0YXRlXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgdXNlSGFzRm9jdXNQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcblxyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0Rm9jdXNlZCgpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRMYXN0Rm9jdXNlZCgpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlSGFzRm9jdXM8VCBleHRlbmRzIE5vZGU+KHsgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH06IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUPik6IFVzZUhhc0ZvY3VzUmV0dXJuVHlwZTxUPiB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlSGFzRm9jdXNcIiwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UpO1xyXG5cclxuICAgIGNvbnN0IFtnZXRGb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZElubmVyLCBzZXRGb2N1c2VkSW5uZXJdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldExhc3RGb2N1c2VkLCBzZXRMYXN0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZENoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZElubmVyLCBzZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9KTtcclxuXHJcbiAgICBjb25zdCB7IGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH0gPSB1c2VBY3RpdmVFbGVtZW50KHtcclxuICAgICAgICBnZXREb2N1bWVudCxcclxuICAgICAgICBnZXRXaW5kb3csXHJcbiAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcIm9uQWN0aXZlRWxlbWVudENoYW5nZVwiXT4+KChhY3RpdmVFbGVtZW50LCBwcmV2QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBhY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRJbm5lciA9ICghIXNlbGZFbGVtZW50Py5jb250YWlucyhhY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWRJbm5lcihmb2N1c2VkSW5uZXIpO1xyXG4gICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/LihhY3RpdmVFbGVtZW50LCBwcmV2QWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfSwgW10pLFxyXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE5vbk51bGxhYmxlPFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wib25MYXN0QWN0aXZlRWxlbWVudENoYW5nZVwiXT4+KChsYXN0QWN0aXZlRWxlbWVudCwgcHJldkxhc3RBY3RpdmVFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZFbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkID0gKHNlbGZFbGVtZW50ICE9IG51bGwgJiYgKHNlbGZFbGVtZW50ID09IGxhc3RBY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRJbm5lciA9ICghIXNlbGZFbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRMYXN0Rm9jdXNlZChmb2N1c2VkKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWRJbm5lcihmb2N1c2VkSW5uZXIpO1xyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPy4obGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfSwgW10pLFxyXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlSGFzRm9jdXNQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IHsgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcyk7IH0sIFtdKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VIYXNGb2N1c1Byb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0Rm9jdXNlZCxcclxuICAgICAgICBnZXRGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0TGFzdEZvY3VzZWQsXHJcbiAgICAgICAgZ2V0TGFzdEZvY3VzZWRJbm5lcixcclxuICAgICAgICBnZXRBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIGdldFdpbmRvd0ZvY3VzZWRcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIG5ldmVyPiB7XHJcbiAgICBjaGlsZHJlbkhhdmVGb2N1czoge1xyXG4gICAgICAgIG9uQW55R2FpbmVkRm9jdXM/KCk6IHZvaWQ7XHJcbiAgICAgICAgb25BbGxMb3N0Rm9jdXM/KCk6IHZvaWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgRm9jdXNJbmZvLCBuZXZlciwgXCJzdWJJbmZvXCI+LCBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT4ge1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+LCBPbWl0PFVzZUhhc0ZvY3VzUmV0dXJuVHlwZTxFPiwgXCJ1c2VIYXNGb2N1c1Byb3BzXCI+IHtcclxuICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxufVxyXG5cclxuaW50ZXJmYWNlIEZvY3VzSW5mbyB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIEZvY3VzSW5mbywgbmV2ZXI+IHtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlV2l0aEhvb2tzIGV4dGVuZHMgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkOiA8RSBleHRlbmRzIEVsZW1lbnQ+KHBhcmFtZXRlcnM6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQYXJhbWV0ZXJzPEU+KSA9PiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuSGF2ZUZvY3VzKHsgY2hpbGRyZW5IYXZlRm9jdXM6IHsgb25BbGxMb3N0Rm9jdXMsIG9uQW55R2FpbmVkRm9jdXMgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfTogVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzKTogVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlV2l0aEhvb2tzIHtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuLCB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEZvY3VzSW5mbywgbmV2ZXI+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSk7XHJcbiAgICBjb25zdCBhbGxFbGVtZW50c1JlZiA9IHVzZVJlZjxTZXQ8Tm9kZT4+KG5ldyBTZXQoKSk7XHJcbiAgICBjb25zdCBbX2dldEZvY3VzQ291bnQsIHNldEZvY3VzQ291bnRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKGFueUZvY3VzZWQ6IG51bWJlciwgYW55UHJldmlvdXNseUZvY3VzZWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBDaGFuZ2luZyBmb2N1cyBjb3VudCBmcm9tICR7YW55UHJldmlvdXNseUZvY3VzZWR9IHRvICR7YW55Rm9jdXNlZH1gKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChhbnlGb2N1c2VkID49IDAgJiYgYW55Rm9jdXNlZCA8PSAxKTtcclxuXHJcbiAgICAgICAgaWYgKGFueUZvY3VzZWQgJiYgIWFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFueUdhaW5lZEZvY3VzPy4oKTtcclxuICAgICAgICBpZiAoIWFueUZvY3VzZWQgJiYgYW55UHJldmlvdXNseUZvY3VzZWQpXHJcbiAgICAgICAgICAgIG9uQWxsTG9zdEZvY3VzPy4oKTtcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkID0gdXNlQ2FsbGJhY2soPEUgZXh0ZW5kcyBFbGVtZW50Pih7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50LCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9IH06IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQYXJhbWV0ZXJzPEU+KTogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT4gPT4ge1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgc3ViSW5mbzoge30sIGZsYWdzIH0gfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCAuLi5oYXNGb2N1cyAgfSA9IHVzZUhhc0ZvY3VzPEU+KHtcclxuICAgICAgICAgICAgZ2V0RG9jdW1lbnQsXHJcbiAgICAgICAgICAgIGdldFdpbmRvdyxcclxuICAgICAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlOiBFIHwgbnVsbCwgcHJldjogRSB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCByID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbEVsZW1lbnRzUmVmLmN1cnJlbnQuYWRkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHI/LigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxFbGVtZW50c1JlZi5jdXJyZW50LmRlbGV0ZShlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIFtvbkVsZW1lbnRDaGFuZ2VdKSxcclxuICAgICAgICAgICAgb25Nb3VudCxcclxuICAgICAgICAgICAgb25Vbm1vdW50LFxyXG4gICAgICAgICAgICBvbkZvY3VzZWRDaGFuZ2VkLFxyXG4gICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQsXHJcbiAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsXHJcbiAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLFxyXG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2hpbGQgJHtpbmRleH0gaXMgZm9jdXNlZGApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZvY3VzZWQgJiYgcHJldikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDaGlsZCAke2luZGV4fSBpcyB1bmZvY3VzZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFByb3BzOiB1c2VIYXNGb2N1c1Byb3BzLFxyXG4gICAgICAgICAgICAuLi5oYXNGb2N1c1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwiLi91c2UtZXZlbnQtaGFuZGxlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cbmludGVyZmFjZSBVc2VQcmVzc1BhcmFtZXRlcnM8RSBleHRlbmRzIE5vZGU+IHtcbiAgICBvbkNsaWNrU3luYzogKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH07XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgdG8gY3JlYXRlIGEgXCJwcmVzc1wiLWxpa2UgZXZlbnQgZm9yXG4gKiBhbnkgZWxlbWVudCwgd2hldGhlciBpdCdzIGEgbmF0aXZlIDxCVVRUT04+IG9yIHJlZ3VsYXIgPERJVj4uXG4gKiBcbiAqIE5vdGFibHksIHRoZSBmb2xsb3dpbmcgY2FzZXMgYXJlIGNvdmVyZWQ6XG4gKiAqIFRoZSB0YXJnZXQgZWxlbWVudCBpcyBwcm9wZXJseSBmb2N1c2VkLCBldmVuIG9uIGlPUyBTYWZhcmkgKCplc3BlY2lhbGx5KiBvbiBpT1MgU2FmYXJpKVxuICogKiBEb3VibGUtY2xpY2tzIHdvbid0IHNlbGVjdCB0ZXh0LiBcbiAqICogQ29udmVyc2VseSwgbWFudWFsbHkgc2VsZWN0aW5nIHRleHQgd29uJ3QgaW52b2tlIGEgcHJlc3MuXG4gKiAqIEtleWJvYXJkIGV2ZW50cyAmbWRhc2g7IGBlbnRlcmAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgaGFuZGxlciwgd2hpbGUgYHNwYWNlYCBpbnZva2VzIGl0IG9uIGtleXVwLlxuICogKiBIYXB0aWMgZmVlZGJhY2sgKG9uLCBsaWtlLCB0aGUgb25lIGJyb3dzZXIgY29tYmluYXRpb24gdGhhdCBzdXBwb3J0cyBpdCAmbWRhc2g7IHRoaXMgY2FuIGJlIGRpc2FibGVkIGFwcC13aWRlIHdpdGggYHNldEJ1dHRvblZpYnJhdGVgKVxuICogXG4gKiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgQ1NTIGA6YWN0aXZlYCBwc2V1ZG8tY2xhc3Mgd291bGQgYXBwbHkgdG8gYSBub3JtYWwgYnV0dG9uXG4gKiAoaS5lLiB3aGVuIGhvbGRpbmcgdGhlIHNwYWNlYmFyIG9yIGR1cmluZyBtb3VzZWRvd24pLCBgeyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBcInRydWVcIiB9YFxuICogaXMgYWRkZWQgdG8gdGhlIHByb3BzLiAgWW91IGNhbiBlaXRoZXIgbGV0IGl0IHBhc3MgdGhyb3VnaCBhbmQgc3R5bGUgaXQgdGhyb3VnaCBuZXcgQ1NTLFxuICogb3IgaW5zcGVjdCB0aGUgcmV0dXJuZWQgcHJvcHMgZm9yIGl0IGFuZCBhZGQgZS5nLiBhbiBgLmFjdGl2ZWAgY2xhc3MgZm9yIGV4aXN0aW5nIENTU1xuICogXG4gKiBAcGFyYW0gb25DbGlja1N5bmMgXG4gKiBAcGFyYW0gZXhjbHVkZSBXaGV0aGVyIHRoZSBwb2x5ZmlsbCBzaG91bGRuJ3QgYXBwbHkgKGNhbiBzcGVjaWZ5IGZvciBzcGVjaWZpYyBpbnRlcmFjdGlvbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVzczxFIGV4dGVuZHMgTm9kZT4oeyBleGNsdWRlLCBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0sIG9uQ2xpY2tTeW5jIH06IFVzZVByZXNzUGFyYW1ldGVyczxFPikge1xuXG4gICAgLy8gQSBidXR0b24gY2FuIGJlIGFjdGl2YXRlZCBpbiBtdWx0aXBsZSB3YXlzLCBzbyBvbiB0aGUgb2ZmIGNoYW5jZVxuICAgIC8vIHRoYXQgbXVsdGlwbGUgYXJlIHRyaWdnZXJlZCBhdCBvbmNlLCB3ZSBvbmx5ICphY3R1YWxseSogcmVnaXN0ZXJcbiAgICAvLyBhIHByZXNzIG9uY2UgYWxsIG9mIG91ciBcIm9uXCIgc2lnbmFscyBoYXZlIHR1cm5lZCBiYWNrIHRvIFwib2ZmXCIuXG4gICAgLy8gV2UgYXBwcm94aW1hdGUgdGhpcyBieSBqdXN0IGluY3JlbWVudGluZyB3aGVuIGFjdGl2ZSwgYW5kXG4gICAgLy8gZGVjcmVtZW50aW5nIHdoZW4gZGVhY3RpdmF0ZWQuXG4gICAgLy9cbiAgICAvLyBBcyBhbiBlbWVyZ2VuY3kgZmFpbHNhZmUsIHdoZW4gdGhlIGVsZW1lbnQgbG9zZXMgZm9jdXMsXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlLCBnZXRBY3RpdmVdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXMoe1xuICAgICAgICAuLi5oYXNGb2N1cyxcbiAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZjogYm9vbGVhbiwgcDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZiwgcCk7XG4gICAgICAgICAgICBpZiAoIWYpIHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICAvLyBJZiB3ZSB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzIHRvIGluY2x1ZGUgdGhpcyBlbGVtZW50XG4gICAgLy8gRFVSSU5HIGUuZy4gYSBtb3VzZWRvd24sIHRoZW4gd2UgZG9uJ3Qgd2FudCB0aGUgbW91c2V1cCB0byBcImNvdW50XCIsIGFzIGl0IHdlcmUsXG4gICAgLy8gYmVjYXVzZSBpdHMgb25seSBwdXJwb3NlIHdhcyBzZWxlY3RpbmcgdGV4dCwgbm90IGNsaWNraW5nIGJ1dHRvbnMuXG4gICAgLy9cbiAgICAvLyBUbyBjYXRjaCB0aGlzLCBhbnkgdGltZSB0aGUgdGV4dCBzZWxlY3Rpb24gaW5jbHVkZXMgdXMgd2hpbGUgaW4gdGhlIG1pZGRsZVxuICAgIC8vIG9mIGEgY2xpY2ssIHRoaXMgZmxhZyBpcyBzZXQsIHdoaWNoIGNhbmNlbHMgdGhlIGFjdGl2YXRpb24gb2YgYSBwcmVzcy5cbiAgICAvLyBUaGUgZmxhZyBpcyByZXNldCBhbnkgdGltZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IG9yIHRoZSBidXR0b24gaXNcbiAgICAvLyBubyBsb25nZXIgYWN0aXZlLlxuICAgIGNvbnN0IFt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lLCBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBwc2V1ZG9BY3RpdmUgPSAoYWN0aXZlICYmICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwpKTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIF8gPT4ge1xuICAgICAgICBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKHByZXYgPT4gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpID09IDAgPyBudWxsIDogcHJldiAhPSBudWxsID8gcHJldiA6IG5ldyBEYXRlKCkpO1xuICAgIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShudWxsKTtcblxuICAgIH0sIFthY3RpdmUgPT0gMF0pO1xuXG4gICAgY29uc3Qgb25BY3RpdmVTdGFydCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChfKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZShhID0+ICsrYSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkFjdGl2ZVN0b3AgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoZSkgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoYSA9PiBNYXRoLm1heCgwLCAtLWEpKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmZXJlbmNlID0gKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgPT0gbnVsbCA/IG51bGwgOiArY3VycmVudFRpbWUgLSArdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSk7XG4gICAgICAgIGNvbnN0IGNoYXJhY3RlcnNTZWxlY3RlZCA9IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIHNlbGVjdGluZyB0ZXh0IChoZXVyaXN0aWNhbGx5IGRldGVybWluZWQgYnkgc2VsZWN0aW5nIGZvciBsb25nZXIgdGhhbiAxLzQgYSBzZWNvbmQsIG9yIG1vcmUgdGhhbiAyIGNoYXJhY3RlcnMpXG4gICAgICAgIC8vIHRoZW4gdGhpcyBpc24ndCBhIHByZXNzIGV2ZW50LlxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtZWFzdXJlIGdseXBocyBpbnN0ZWFkIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaGFyYWN0ZXJzU2VsZWN0ZWQgPiAxIHx8ICgodGltZURpZmZlcmVuY2UgPz8gMCkgPiAyNTAgJiYgY2hhcmFjdGVyc1NlbGVjdGVkID49IDEpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0QWN0aXZlKCkgPD0gMCkge1xuICAgICAgICAgICAgaGFuZGxlUHJlc3MoZSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpOyAgLy8gVE9ETzogUmVtb3ZlIHdoZW4gaXNzdWUgcmVzb2x2ZWQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMzczMVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBoYW5kbGVQcmVzcyA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU3luYykge1xuXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgZWxlbWVudCBpcyBmb2N1c2VkIGhlcmUgYmVjYXVzZSBvZiBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEl0J3MgYWx3YXlzIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaU9TIFNhZmFyaSAodGVzdGVkIG9uIDEyKSBkb3ducmlnaHQgcmVmdXNlcyB0byBhbGxvdyBcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQgVU5MRVNTIGl0IGhhcHBlbnMgd2l0aGluXG4gICAgICAgICAgICAvLyBhbiBldmVudCBoYW5kbGVyIGxpa2UgdGhpcy4gIEl0IGFsc28gZG9lc24ndCBmb2N1c1xuICAgICAgICAgICAgLy8gYnV0dG9ucyBieSBkZWZhdWx0IHdoZW4gY2xpY2tlZCwgdGFwcGVkLCBldGMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgaXQgYmVjb21lcyBwcm9ibGVtYXRpYyB0aGF0IGJ1dHRvbi1saWtlcyBleHBsaWNpdGx5IGJlY29tZVxuICAgICAgICAgICAgLy8gZm9jdXNlZCB3aGVuIHRoZXkgYXJlIHByZXNzZWQsIHRoZW4gYW4gYWx0ZXJuYXRpdmUgc29sdXRpb24gZm9yXG4gICAgICAgICAgICAvLyB0aGUgcXVlc3Rpb24gb2YgXCJob3cgZG8gbWVudSBidXR0b25zIGtlZXAgdGhlaXIgbWVudXMgb3BlblwiXG4gICAgICAgICAgICAvLyBhbmQgb3RoZXIgZm9jdXMtcmVsYXRlZCBub25zZW5zZSBuZWVkcyB0byBiZSBmaWd1cmVkIG91dC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgXCJmb2N1c1wiIGluIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KSlcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xuXG4gICAgICAgICAgICAvLyBXaGF0ZXZlciB0aGUgYnJvd3NlciB3YXMgZ29pbmcgdG8gZG8gd2l0aCB0aGlzIGV2ZW50LFxuICAgICAgICAgICAgLy8gZm9yZ2V0IGl0LiBXZSdyZSB0dXJuaW5nIGl0IGludG8gYSBcInByZXNzXCIgZXZlbnQuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIEFsc28gc3RvcCBhbnlvbmUgZWxzZSBmcm9tIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50LFxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgZXhwbGljaXRseSBoYW5kbGluZyBpdC5cbiAgICAgICAgICAgIC8vIChOb3RhYmx5LCB0aGlzIGFsbG93cyBsYWJlbHMgdG8gd3JhcCBpbnB1dHMsIHdpdGggdGhlbVxuICAgICAgICAgICAgLy8gYm90aCBoYXZpbmcgcHJlc3MgZXZlbnQgaGFuZGxlcnMsIHdpdGhvdXQgZG91YmxlLWZpcmluZylcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIEhhcHRpYyBmZWVkYmFjayBmb3IgdGhpcyBwcmVzcyBldmVudFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHRocm93LFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgZ3VhcmQgYWdhaW5zdCB1c2VyIGltcGxlbWVudGF0aW9ucyB0aGF0IGNvdWxkLlxuICAgICAgICAgICAgICAgIHB1bHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBjYWxsIG91ciBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgLy8gU3RvcCBkb3VibGUgY2xpY2tzIGZyb20gc2VsZWN0aW5nIHRleHQgaW4gYW4gY29tcG9uZW50IHRoYXQncyAqc3VwcG9zZWQqIHRvIGJlIGFjdGluZyBsaWtlIGEgYnV0dG9uLFxuICAgICAgICAvLyBidXQgYWxzbyBkb24ndCBwcmV2ZW50IHRoZSB1c2VyIGZyb20gc2VsZWN0aW5nIHRoYXQgdGV4dCBtYW51YWxseSBpZiB0aGV5IHJlYWxseSB3YW50IHRvXG4gICAgICAgIC8vICh3aGljaCB1c2VyLXNlbGVjdDogbm9uZSB3b3VsZCBkbywgYnV0IGNhbmNlbGxpbmcgYSBkb3VibGUgY2xpY2sgb24gbW91c2VEb3duIGRvZXNuJ3QpXG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cblxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDApXG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdXNlVXAgPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgYWN0aXZlID4gMClcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICB9O1xuXG5cbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICghZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSlcbiAgICAgICAgICAgIHNldEFjdGl2ZSgwKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgJiYgZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBkbyBwcmV2ZW50RGVmYXVsdCB0byBzdG9wIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nLlxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgIWV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbktleVVwID0gZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKVxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlUHJlc3NQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pIHtcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHByb3BzLCB1c2VIYXNGb2N1c1Byb3BzKCh7XG4gICAgICAgICAgICBvbktleURvd24sXG4gICAgICAgICAgICBvbktleVVwLFxuICAgICAgICAgICAgb25Nb3VzZURvd24sXG4gICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cbiAgICAgICAgfSkpKTtcbiAgICB9XG59XG5cblxuXG5cbi8qKlxuICogc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSBkb2Vzbid0IGFjY291bnQgZm9yIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCxcbiAqIHNvIGhlcmUncyBhIHdvcmthcm91bmQgZm9yIHRoYXQuXG4gKiBcbiAqIFdlIGFsc28gb25seSBsb29rIGZvciB0aGUgc2VsZWN0aW9uIGVuZCB0byBvbmx5IGNhdGNoIHRoZSBcbiAqIGVzc2Vuc2Ugb2YgYSBub24tZXhpc3RhbnQgXCJzZWxlY3Rpb25zdG9wXCIgZXZlbnQuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlbGVjdGlvbj8ucmFuZ2VDb3VudCA/PyAwKTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbiEuZ2V0UmFuZ2VBdChpKSE7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiEudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuXG5sZXQgcHVsc2UgPSAoKFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcikgJiYgKG5hdmlnYXRvci52aWJyYXRlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxuICogKERlZmF1bHQgaXMgYCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKWAgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LCBhIG5vb3Agb3RoZXJ3aXNlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJlc3NWaWJyYXRlKGZ1bmM6ICgpID0+IHZvaWQpIHtcbiAgICBwdWxzZSA9IGZ1bmM7XG59XG5cblxuXG5mdW5jdGlvbiBleGNsdWRlcyh0YXJnZXQ6IFwiY2xpY2tcIiB8IFwic3BhY2VcIiB8IFwiZW50ZXJcIiwgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBpZiAoZXhjbHVkZT8uW3RhcmdldF0pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRpbWVvdXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC4gIFxuICAgICAqIElmIGBudWxsYCwgY2FuY2VscyB0aGUgdGltZW91dCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0byB0aGlzIHByb3AgYmV0d2VlbiByZW5kZXJzIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBjdXJyZW50IHRpbWVvdXQgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdHJpZ2dlckluZGV4PzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKiBcbiAgICAgKiBEb2VzICpub3QqIG5lZWQgdG8gYmUgc3RhYmxlLiBHbyBhaGVhZCBhbmQgcGFzcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9OiBVc2VUaW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7IHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gbnVsbDsgY2FsbGJhY2soKTsgfSk7XG4gICAgY29uc3QgZ2V0VGltZW91dCA9IHVzZVN0YWJsZUdldHRlcih0aW1lb3V0KTtcblxuICAgIC8vIFNldCBhbnkgdGltZSB3ZSBzdGFydCB0aW1lb3V0LlxuICAgIC8vIFVuc2V0IGFueSB0aW1lIHRoZSB0aW1lb3V0IGNvbXBsZXRlc1xuICAgIGNvbnN0IHN0YXJ0VGltZVJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IHRpbWVvdXRJc051bGwgPSAodGltZW91dCA9PSBudWxsKTtcblxuICAgIC8vIEFueSB0aW1lIHRoZSB0cmlnZ2VySW5kZXggY2hhbmdlcyAoaW5jbHVkaW5nIG9uIG1vdW50KVxuICAgIC8vIHJlc3RhcnQgdGhlIHRpbWVvdXQuICBUaGUgdGltZW91dCBkb2VzIE5PVCByZXNldFxuICAgIC8vIHdoZW4gdGhlIGR1cmF0aW9uIG9yIGNhbGxiYWNrIGNoYW5nZXMsIG9ubHkgdHJpZ2dlckluZGV4LlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdGltZW91dElzTnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRpbWVvdXRJc051bGwgPT0gKHRpbWVvdXQgPT0gbnVsbCkpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gKyhuZXcgRGF0ZSgpKTtcbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KHN0YWJsZUNhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSwgW3RyaWdnZXJJbmRleCwgdGltZW91dElzTnVsbF0pXG5cbiAgICBjb25zdCBnZXRFbGFwc2VkVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgrKG5ldyBEYXRlKCkpKSAtICgrKHN0YXJ0VGltZVJlZi5jdXJyZW50ID8/IG5ldyBEYXRlKCkpKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSZW1haW5pbmdUaW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0VGltZW91dCgpO1xuICAgICAgICByZXR1cm4gdGltZW91dCA9PSBudWxsID8gbnVsbCA6IE1hdGgubWF4KDAsIHRpbWVvdXQgLSBnZXRFbGFwc2VkVGltZSgpKVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGdldEVsYXBzZWRUaW1lLCBnZXRSZW1haW5pbmdUaW1lIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VMb2dpY2FsRGlyZWN0aW9uIH0gZnJvbSBcIi4vdXNlLWxvZ2ljYWwtZGlyZWN0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIGxpbmVhck5hdmlnYXRpb246IHt9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqIFxuICAgICAqIFRoZXNlIHByb3BzIGNhbiBiZSBhdHRhdGNoZWQgZWl0aGVyIHRvIHRoZSBwYXJlbnQgb3IgdG8gZWFjaCBpbmRpdmlkdWFsIGNoaWxkLlxuICAgICAqIFdoaWNoZXZlciB3b3JrcyBiZXR0ZXIgZm9yIHlvdXIgc2NlbmFyaW8uXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiBcbiAgICAgKiAqL1xuICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuaW50ZXJmYWNlIExOUCB7XG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvUHJldigpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9GaXJzdCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggYXJyb3cga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICogTm90IHJlbGF0aXZlIHRvIHRoZSB3cml0aW5nIG1vZGUgLS0gdGhlc2UgYXJlIHRoZSBsaXRlcmFsIGtleXMgdGhhdCBuZWVkIHRvIGJlIHByZXNzZWQuXG4gICAgICogXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICAgICAqIFxuICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPzogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgfCBcImVpdGhlclwiIHwgXCJub25lXCI7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmUgXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZVxuICAgICAqIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzPzogYm9vbGVhbjtcbn1cbmV4cG9ydCB0eXBlIExpbmVhck5hdmlnYXRpb25PbWl0cyA9IGtleW9mIExOUDtcblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBhcmVudCBgdXNlTGluZWFyTmF2aWdhdGlvbmAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHM+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBPbWl0PExOUCwgT21pdHM+XG59XG5cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRgICovXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcbiAqIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICogXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvRmlyc3Q6IG50ZiwgbmF2aWdhdGVUb0xhc3Q6IG50bCwgbmF2aWdhdGVUb05leHQ6IG50biwgbmF2aWdhdGVUb1ByZXY6IG50cCwgbmF2aWdhdGlvbkRpcmVjdGlvbjogbmQsIGRpc2FibGVBcnJvd0tleXM6IGRhaywgZGlzYWJsZUhvbWVFbmRLZXlzOiBkaGVrIH0gfTogVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuICAgIG5kID8/PSBcImVpdGhlclwiO1xuXG4gICAgLy9jb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMgfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHt9KTtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50Zik7XG4gICAgY29uc3QgbmF2aWdhdGVUb0xhc3QgPSB1c2VTdGFibGVDYWxsYmFjayhudGwpO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRuKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZVN0YWJsZUNhbGxiYWNrKG50cCk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUFycm93S2V5cyA9IHVzZVN0YWJsZUdldHRlcihkYWspO1xuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihkaGVrKTtcbiAgICBjb25zdCBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uID0gdXNlU3RhYmxlR2V0dGVyKG5kKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvL2NvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25EaXJlY3Rpb24gPSBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUFycm93S2V5cyA9IGdldERpc2FibGVBcnJvd0tleXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlSG9tZUVuZEtleXMgPSBnZXREaXNhYmxlSG9tZUVuZEtleXMoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwidmVydGljYWxcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzVmVydGljYWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NIb3Jpem9udGFsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biB9LCBwcm9wcyk7XG4gICAgICAgIH0sIFtdKSxcbiAgICB9XG5cblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQ6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgb24gZWl0aGVyIHRoZSBwYXJlbnQgb3IgZWFjaCBjaGlsZCBlbGVtZW50LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG5cbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkO1xuXG59XG5cbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUgPSB2b2lkO1xuXG5pbnRlcmZhY2UgVE5QIHtcbiAgICAvKipcbiAgICAgKiBBIGNvbGxhdG9yIHRvIHVzZSB3aGVuIGNvbXBhcmluZy4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdXNlcyBgbG9jYWxlQ29tcGFyZWAgYWZ0ZXIgdHJhbnNmb3JtaW5nIGVhY2ggdG8gbG93ZXJjYXNlLCB3aGljaCB3aWxsLCBhdCBiZXN0LCB3b3JrIG9rYXkgaW4gRW5nbGlzaC5cbiAgICAgKi9cbiAgICBjb2xsYXRvcj86IEludGwuQ29sbGF0b3I7XG5cbiAgICBub1R5cGVhaGVhZD86IGJvb2xlYW47XG5cbiAgICB0eXBlYWhlYWRUaW1lb3V0PzogbnVtYmVyO1xuICAgIGdldEluZGV4KCk6IG51bWJlciB8IG51bGw7XG4gICAgc2V0SW5kZXgodmFsdWU6IG51bWJlciB8IG51bGwgfCAoKHByZXZpb3VzVmFsdWU6IG51bWJlciB8IG51bGwpID0+IChudW1iZXIgfCBudWxsKSkpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMgPSBrZXlvZiBUTlA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHM+IHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBPbWl0PFROUCwgT21pdHM+XG59XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkYCAqL1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIGFsbG93cyB0aGlzIGNvbXBvbmVudCB0byBiZSBuYXZpZ2F0ZWQgdG8gYnkgdHlwaW5nIHRoaXMgc3RyaW5nLiBcbiAgICAgKiBJdCBzaG91bGQgYmUgdGhlIHNhbWUgdGV4dCBjb250ZW50IGFzIHdoYXRldmVyJ3MgZGlzcGxheWVkLCBpZGVhbGx5LlxuICAgICAqL1xuICAgIHRleHQ6IHN0cmluZyB8IG51bGw7XG5cbiAgICBpbmRleDogbnVtYmVyO1xufVxuXG4vKiogVHlwZSBvZiB0aGUgY2hpbGQncyBzdWItaG9vayAqL1xuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gKGFyZ3M6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMpID0+IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU7XG5cblxuLyoqXG4gKiBBbGxvd3MgZm9yIHRoZSBzZWxlY3Rpb24gb2YgYSBtYW5hZ2VkIGNoaWxkIGJ5IHR5cGluZyB0aGUgZ2l2ZW4gdGV4dCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXgsIG5vVHlwZWFoZWFkIH0gfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuXG4gICAgLy8gRm9yIHR5cGVhaGVhZCwga2VlcCB0cmFjayBvZiB3aGF0IG91ciBjdXJyZW50IFwic2VhcmNoXCIgc3RyaW5nIGlzIChpZiB3ZSBoYXZlIG9uZSlcbiAgICAvLyBhbmQgYWxzbyBjbGVhciBpdCBldmVyeSAxMDAwIG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgY2hhbmdlZC5cbiAgICAvLyBOZXh0LCBrZWVwIGEgbWFwcGluZyBvZiB0eXBlYWhlYWQgdmFsdWVzIHRvIGluZGljZXMgZm9yIGZhc3RlciBzZWFyY2hpbmcuXG4gICAgLy8gQW5kLCBmb3IgdGhlIHVzZXIncyBzYWtlLCBsZXQgdGhlbSBrbm93IHdoZW4gdGhlaXIgdHlwZWFoZWFkIGNhbid0IG1hdGNoIGFueXRoaW5nIGFueW1vcmVcbiAgICBjb25zdCBbY3VycmVudFR5cGVhaGVhZCwgc2V0Q3VycmVudFR5cGVhaGVhZCwgZ2V0Q3VycmVudFR5cGVhaGVhZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dDogdHlwZWFoZWFkVGltZW91dCA/PyAxMDAwLCBjYWxsYmFjazogKCkgPT4geyBzZXRDdXJyZW50VHlwZWFoZWFkKG51bGwpOyBzZXRJbnZhbGlkVHlwZWFoZWFkKG51bGwpOyB9LCB0cmlnZ2VySW5kZXg6IGN1cnJlbnRUeXBlYWhlYWQgfSk7XG4gICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5mbyA9IHVzZVJlZjx7IHRleHQ6IHN0cmluZywgdW5zb3J0ZWRJbmRleDogbnVtYmVyIH1bXT4oW10pO1xuICAgIGNvbnN0IFtpbnZhbGlkVHlwZWFoZWFkLCBzZXRJbnZhbGlkVHlwZWFoZWFkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihmYWxzZSk7XG5cbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXG4gICAgLy8gRXNzZW50aWFsbHksIHdoZW4gYWN0aXZlLCBpZ25vcmUgZnVydGhlciBrZXlzIFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgd2FpdGluZyBmb3IgYSBDb21wb3NpdGlvbkVuZCBldmVudFxuICAgIGNvbnN0IFssIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vIEJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzIGZpcmUgKmFmdGVyKiBrZXlkb3duIGV2ZW50cyBcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxuICAgIC8vIHdlIGNhbiB1c2UgdGhpcyB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50IHdlJ3JlIGxpc3RlbmluZyBmb3Igb24gdGhlIGZpcnN0IGtleWRvd24uXG4gICAgY29uc3QgW25leHRUeXBlYWhlYWRDaGFyLCBzZXROZXh0VHlwZWFoZWFkQ2hhcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobmV4dFR5cGVhaGVhZENoYXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodHlwZWFoZWFkID0+ICgodHlwZWFoZWFkID8/IFwiXCIpICsgbmV4dFR5cGVhaGVhZENoYXIpKTtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW25leHRUeXBlYWhlYWRDaGFyXSk7XG5cblxuICAgIGNvbnN0IGNvbXBhcmF0b3JTaGFyZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoc2FmZUxoczogc3RyaW5nLCBzYWZlUmhzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGNvbXBhcmU6IG51bWJlcjtcbiAgICAgICAgLy8gRm9yIHRoZSBwdXJwb3NlcyBvZiB0eXBlYWhlYWQsIG9ubHkgY29tcGFyZSBhIHN0cmluZyBvZiB0aGUgc2FtZSBzaXplIGFzIG91ciBjdXJyZW50bHkgdHlwZWQgc3RyaW5nLlxuICAgICAgICAvLyBCeSBub3JtYWxpemluZyB0aGVtIGZpcnN0LCB3ZSBlbnN1cmUgdGhpcyBieXRlLWJ5LWJ5dGUgaGFuZGxpbmcgb2YgcmF3IGNoYXJhY3RlciBkYXRhIHdvcmtzIG91dCBva2F5LlxuICAgICAgICBzYWZlTGhzID0gc2FmZUxocy5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgIHNhZmVSaHMgPSBzYWZlUmhzLm5vcm1hbGl6ZShcIk5GRFwiKVxuXG4gICAgICAgIGlmIChjb2xsYXRvcilcbiAgICAgICAgICAgIGNvbXBhcmUgPSBjb2xsYXRvci5jb21wYXJlKHNhZmVMaHMsIHNhZmVSaHMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnNlcnRpbmdDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB0eXBlYWhlYWQsIGFsbCBzdHJpbmdzIGxvbmdlciB0aGFuIG91cnMgc2hvdWxkIGJlIHRydW5jYXRlZFxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5J3JlIGFsbCBjb25zaWRlcmVkIGVxdWFsbHkgYnkgdGhhdCBwb2ludC5cbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQuc3Vic3RyaW5nKDAsIGxocy5sZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHVzZVN0YWJsZUdldHRlcihub1R5cGVhaGVhZCk7XG5cblxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvblN0YXJ0ID0gKF9lOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKSB9O1xuICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uRW5kID0gKGU6IENvbXBvc2l0aW9uRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGUuZGF0YSk7XG4gICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgaW1lQWN0aXZlID0gZ2V0SW1lQWN0aXZlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xuXG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgd2F5IHRoYXQgZG9lc24ndCBzcGxpdCBVVEYtMTYgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG9uZS1jaGFyYWN0ZXIgbmFtZXMsIGFuZCB0aGVyZSBhcmUgbm8gbm9uLUFTQ0lJLWFscGhhIG5hbWVzLlxuICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyS2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGJlY2F1c2UgYSBzcGFjZWJhciBjYW4ndCBldmVyIFxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhIHR5cGVhaGVhZCwgb25seSBjb250aW51ZSBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKFNwZWNpZmljYWxseSwgbGV0IHRoZSBldmVudCBjb250aW51ZSBwcm9wYWdhdGlvbiBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXb24ndCBiZSB0cnVlIGZvciB0aGUgZmlyc3Qga2V5ZG93blxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhY3R1YWxseSBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1lQWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25FbmQsIH0sIHByb3BzKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhbmdlcyBpbiB0eXBlYWhlYWQgdGhhdCBjYXVzZSBjaGFuZ2VzIHRvIHRoZSB0YWJiYWJsZSBpbmRleFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VHlwZWFoZWFkICYmIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGgpIHtcblxuXG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgdHlwZWFoZWFkQ29tcGFyYXRvcik7XG5cbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gKG9yIG1vcmUgc3BlY2lmaWNhbGx5IFwiZm9yIHdoaWNoIHRoZXJlIGlzIG5vIGVudHJ5IHRoYXQgc3RhcnRzIHdpdGggdGhhdCBpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICBXZSBrbm93IHJvdWdobHkgd2hlcmUsIGluIHRoZSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncywgb3VyIG5leHQgdHlwZWFoZWFkIGxvY2F0aW9uIGlzLlxuICAgICAgICAgICAgICAgICAgQnV0IHJvdWdobHkgaXNuJ3QgZ29vZCBlbm91Z2ggaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICBUbyBjb252ZXJ0IG91ciBzb3J0ZWQgaW5kZXggdG8gdGhlIHVuc29ydGVkIGluZGV4IHdlIG5lZWQsIHdlIGhhdmUgdG8gZmluZCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHVzICphbmQqIChpZiBhbnkgc3VjaCBleGlzdCkgaXMgKmFmdGVyKiBvdXIgY3VycmVudCBzZWxlY3Rpb24uXG5cbiAgICAgICAgICAgICAgICAgIEluIG90aGVyIHdvcmRzLCB0aGUgb25seSB3YXkgdHlwZWFoZWFkIG1vdmVzIGJhY2t3YXJkcyByZWxhdGl2ZSB0byBvdXIgY3VycmVudFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gaXMgaWYgdGhlIG9ubHkgb3RoZXIgb3B0aW9uIGlzIGJlaGluZCB1cy5cblxuICAgICAgICAgICAgICAgICAgSXQncyBub3Qgc3BlY2lmaWVkIGluIFdBSS1BUklBIHdoYXQgdG8gZG8gaW4gdGhhdCBjYXNlLiAgSSBzdXBwb3NlIHdyYXAgYmFjayB0byB0aGUgc3RhcnQ/XG4gICAgICAgICAgICAgICAgICBUaG91Z2ggdGhlcmUncyBhbHNvIGEgY2FzZSBmb3IganVzdCBnb2luZyB1cHdhcmRzIHRvIHRoZSBuZWFyZXN0IHRvIHByZXZlbnQganVtcGluZXNzLlxuICAgICAgICAgICAgICAgICAgQnV0IGlmIHlvdSdyZSBhbHJlYWR5IGRvaW5nIHR5cGVhaGVhZCBvbiBhbiB1bnNvcnRlZCBsaXN0LCBsaWtlLCBqdW1waW5lc3MgY2FuJ3QgYmUgYXZvaWRlZC5cbiAgICAgICAgICAgICAgICAgIEkgZHVubm8uIEdvaW5nIGJhY2sgdG8gdGhlIHN0YXJ0IGlzIHRoZSBzaW1wbGlzdCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgICAgIEJhc2ljYWxseSB3aGF0IHRoaXMgZG9lczogU3RhcnRpbmcgZnJvbSB3aGVyZSB3ZSBmb3VuZCBvdXJzZWx2ZXMgYWZ0ZXIgb3VyIGJpbmFyeSBzZWFyY2gsXG4gICAgICAgICAgICAgICAgICBzY2FuIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMgdGhyb3VnaCBhbGwgYWRqYWNlbnQgZW50cmllcyB0aGF0IGFsc28gY29tcGFyZSBlcXVhbGx5IHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgIHdlIGNhbiBmaW5kIHRoZSBvbmUgd2hvc2UgYHVuc29ydGVkSW5kZXhgIGlzIHRoZSBsb3dlc3QgYW1vbmdzdCBhbGwgb3RoZXIgZXF1YWwgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgKGFuZCBhbHNvIHRoZSBsb3dlc3QgYHVuc29ydGVkSW5kZXhgIHlhZGRhIHlhZGRhIGV4Y2VwdCB0aGF0IGl0IGNvbWVzIGFmdGVyIHVzKS5cblxuICAgICAgICAgICAgICAgICAgVE9ETzogVGhlIGJpbmFyeSBzZWFyY2ggc3RhcnRzIHRoaXMgb2ZmIHdpdGggYSBzb2xpZCBPKGxvZyBuKSwgYnV0IG9uZS1jaGFyYWN0ZXIgXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZSBcbiAgICAgICAgICAgICAgICAgIE8obipsb2cgbikuIFRoaXMgaXMgYW5ub3lpbmcgYnV0IHByb2JhYmx5IG5vdCBlYXNpbHkgc29sdmFibGU/IFRoZXJlIGNvdWxkIGJlIGFuIFxuICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uIGZvciBvbmUtY2hhcmFjdGVyIHN0cmluZ3MsIGJ1dCB0aGF0J3MganVzdCBraWNraW5nIHRoZSBjYW4gZG93biBcbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxuICAgICAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNhbmRpZGF0ZXMnIHBvc2l0aW9ucyBpbiBib3RoIG91ciBzb3J0ZWQgYXJyYXkgYW5kIHRoZSB1bnNvcnRlZCBET00uXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhBbGw6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgdHdvIGFyZSBvbmx5IHNldCBmb3IgZWxlbWVudHMgdGhhdCBhcmUgYWhlYWQgb2YgdXMsIGJ1dCB0aGUgcHJpbmNpcGxlJ3MgdGhlIHNhbWUgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCZXN0Rml0ID0gKHU6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4QWxsID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0KSAmJiB1ID4gKGdldEluZGV4KCkgPz8gLUluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleEFsbF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pO1xuXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPigoeyBpbmRleCwgdGV4dCB9KSA9PiB7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIGluc2VydCB0aGlzIGl0ZW0uXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBhbGwgaW5kZXggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUsIHRoZSByZXR1cm5lZCBzb3J0ZWRJbmRleFxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgcmVmZXIgdG8gYSBuZXcgbG9jYXRpb24gKGkuZS4gYmUgbmVnYXRpdmUpICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc29ydGVkSW5kZXggPCAwIHx8IGluc2VydGluZ0NvbXBhcmF0b3Ioc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W3NvcnRlZEluZGV4XS50ZXh0LCB7IHVuc29ydGVkSW5kZXg6IGluZGV4LCB0ZXh0IH0pID09IDApO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVubW91bnRpbmcsIGZpbmQgd2hlcmUgd2Ugd2VyZSBhbmQgcmVtb3ZlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWdhaW4sIHdlIHNob3VsZCBhbHdheXMgZmluZCBvdXJzZWx2ZXMgYmVjYXVzZSB0aGVyZSBzaG91bGQgYmUgbm8gZHVwbGljYXRlIHZhbHVlcyBpZiBlYWNoIGluZGV4IGlzIHVuaXF1ZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc29ydGVkSW5kZXggPCAwIHx8IGluc2VydGluZ0NvbXBhcmF0b3Ioc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W3NvcnRlZEluZGV4XS50ZXh0LCB7IHVuc29ydGVkSW5kZXg6IGluZGV4LCB0ZXh0IH0pID09IDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RleHRdKTtcblxuICAgICAgICByZXR1cm47XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cbiAqIFxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB3YW50ZWQgVGhlIHZhbHVlIHlvdSdkIGxpa2UgdG8gZmluZFxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuIFxuICogVGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgbnVtYmVyLCBtaW51cyBvbmUsIGlzIHdoZXJlIGB3YW50ZWRgICp3b3VsZCogYmUgZm91bmQgaWYgaXQgKndhcyogaW4gYGFycmF5YFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQsIFUsIEYgZXh0ZW5kcyAobGhzOiBVLCByaHM6IFQpID0+IG51bWJlcj4oYXJyYXk6IFRbXSwgd2FudGVkOiBVLCBjb21wYXJhdG9yOiBGKTogbnVtYmVyIHtcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGxhc3RJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRlc3RJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSA+PiAxO1xuICAgICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyYXRvcih3YW50ZWQsIGFycmF5W3Rlc3RJbmRleF0pO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHRlc3RJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlc3RJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cywgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+ID0gUmVxdWlyZWQ8ST4gJiBGbGFnZ2FibGVDaGlsZEluZm88XCJ0YWJiYWJsZVwiPiAmIHtcbi8vfTtcblxuZXhwb3J0IHR5cGUgT25UYWJiYWJsZUluZGV4Q2hhbmdlID0gKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPEUgZXh0ZW5kcyBFbGVtZW50LCBDPiB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGFiYmluZyB0aHJvdWdoIHRoaXMgY29tcG9uZW50IHdpbGwgY2F1c2UgdGhlIHJlZmVyZW5jZWQgZWxlbWVudCB0byBiZSBmb2N1c2VkLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50IGlmIHlvdSdkIGxpa2UuXG4gICAgICovXG4gICAgZm9jdXNTZWxmKCk6IHZvaWQ7XG5cbiAgICAvL2JsdXJTZWxmKCk6IHZvaWQ7XG5cbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xuXG4gICAgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgc3ViSW5mbzogQztcbn1cblxuaW50ZXJmYWNlIFJUSVAge1xuICAgIC8vIENhbGxlZCBkdXJpbmcgYW4gZWZmZWN0IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIHJlbmRlcmVkIGl0c2VsZiBpbiBhIHRhYmJhYmxlIHN0YXRlXG4gICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPzogT25UYWJiYWJsZUluZGV4Q2hhbmdlO1xuXG4gICAgLy9vblRhYmJlZEluVG8/OiAoKSA9PiB2b2lkO1xuICAgIC8vb25UYWJiZWRPdXRPZj86ICgpID0+IHZvaWQ7XG5cbiAgICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG59XG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIFJUSVA7XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIE1jT21pdHM+IHtcbiAgICByb3ZpbmdUYWJJbmRleDogT21pdDxSVElQLCBSdGlPbWl0cz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXg6ICh1cGRhdGVyOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0sIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlSW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGZvY3VzU2VsZjogKCkgPT4gdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPlxue1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZDogVXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+O1xufVxuXG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMgPSBrZXlvZiBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmcsIFJ0aWNPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kc1xuICAgIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIiwgTWNPbWl0cyB8IFwic3ViSW5mb1wiPiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UGFydGlhbDxPbWl0PFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxhbnksIGFueT4sIFwiZ2V0RWxlbWVudFwiIHwgXCJzdWJJbmZvXCI+PiwgUnRpY09taXRzPjtcbiAgICBzdWJJbmZvOiBTdWJiZXN0SW5mbztcbn1cblxuZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzLCBuZXZlciwgbmV2ZXIsIFJ0aVN1YkluZm8+KSA9PiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgdGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldEVsZW1lbnQoKTogQ2hpbGRFbGVtZW50IHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG59XG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgcm92aW5nIHRhYmluZGV4IHN5c3RlbSB3aGVyZSBvbmx5IG9uZSBcImZvY3VzYWJsZVwiXG4gKiBjb21wb25lbnQgaW4gYSBzZXQgaXMgYWJsZSB0byByZWNlaXZlIGEgdGFiIGZvY3VzLiAqV2hpY2gqXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcbiAqIHJlY29tbWVuZGVkIHRvIG9mZmxvYWQgdGhhdCBsb2dpYyB0aGVuIHRvIGFub3RoZXIgaG9vaywgbGlrZVxuICogYHVzZUxpbmVhck5hdmlnYXRpb25gLCB3aGljaCBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcbiAqIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0eXBlYWhlYWQsIG9yXG4gKiBgdXNlTGlzdE5hdmlnYXRpb25gIGlmIHlvdSBqdXN0IHdhbnQgZXZlcnl0aGluZyBidW5kbGVkIHRvZ2V0aGVyLlxuICogXG4gKiBOb3RlIHRoYXQgdGhlIGNoaWxkIGhvb2sgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWRcbiAqIGJ5IGV2ZXJ5IGNoaWxkIHRoYXQgdXNlcyB0aGlzIHJvdmluZyB0YWJpbmRleCBsb2dpYy4gIFRoZVxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcbiAqIG9uIHRoZSBjaGlsZCdzIGVsZW1lbnQsIGFzIHdlbGwgYXMgYW55IG90aGVyIGVsZW1lbnRzIHlvdSdkIGxpa2VcbiAqIHRvIGJlIGV4cGxpY2l0bHkgbWFkZSB1bnRhYmJhYmxlIHRvby5cbiAqIFxuICogYHNob3VsZEZvY3VzT25DaGFuZ2VgIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBmb2N1cyBpcyBcbiAqIGNvbnRhaW5lZCB3aXRoaW4gd2hhdGV2ZXIgZWxlbWVudCBjb250YWlucyB0aGUgcm92aW5nIHRhYiBpbmRleC5cbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcbiAqIGBgYFxuICogY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oeyBzZXRGb2N1c2VkSW5uZXIgfSk7XG4gKiBjb25zdCBmb2N1c09uQ2hhbmdlID0gKGZvY3VzZWRJbm5lciAhPSBmYWxzZSk7XG4gKiBgYGBcbiAqIEl0J3Mgbm90IGluY2x1ZGVkIGhlcmUgYmVjYXVzZSBgdXNlUm92aW5nVGFiSW5kZXhgIGRvZXNuJ3Qga25vdyBcbiAqIGFueXRoaW5nIGFib3V0IHRoZSBjb250YWluZXIgZWxlbWVudCwgb25seSBjaGlsZHJlbiBlbGVtZW50cy5cbiAqIEFuZCBqdXN0IGFzIHdlbGwhIENoaWxkcmVuIHNob3VsZCBiZSBhbGxvd2VkIGF0IHRoZSByb290LCBcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyPik6IFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcblxuICAgIGxldCB7IHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiYWJsZUluZGV4Q2hhbmdlIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xuXG4gICAgaW5pdGlhbEluZGV4ID8/PSAwO1xuICAgIGNvbnN0IHN0YWJsZU9uVGFiYmFibGVSZW5kZXIgPSB1c2VTdGFibGVDYWxsYmFjayhvblRhYmJhYmxlUmVuZGVyID8/ICgoKSA9PiB7IH0pKTtcbiAgICAvKmNvbnN0IFtfZ2V0QW55Rm9jdXNlZCwgc2V0QW55Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyPih1c2VTdGFibGVDYWxsYmFjaygobmV3Q291bnQ6IG51bWJlciwgb2xkQ291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAob2xkQ291bnQgPT0gMCAmJiBuZXdDb3VudCA+IDApIHtcbiAgICAgICAgICAgIG9uVGFiYmVkSW5Ubz8uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3Q291bnQgPT0gMCAmJiAob2xkQ291bnQgPz8gMCkgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZE91dE9mPy4oKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5aZXJvKTsqL1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aHJlZSB0aGluZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnQncyBpbmRleDpcbiAgICAvLyBXaGF0IGl0IGlzLCBhbmQgd2hldGhlciwgd2hlbiB3ZSByZW5kZXIgdGhpcyBjb21wb25lbnQgYW5kIGl0J3MgY2hhbmdlZCwgdG8gYWxzbyBmb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBtYWRlIHRhYmJhYmxlLlxuICAgIGNvbnN0IFtnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4Ml0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4ob25UYWJiYWJsZUluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBpbml0aWFsSW5kZXggPz8gMCB9LCBbXSkpO1xuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VDYWxsYmFjaygodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgyKChwcmV2SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXIocHJldkluZGV4ID8/IG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXI7XG5cbiAgICAgICAgICAgIG5leHRJbmRleCA9IGNoYW5nZUluZGV4KG5leHRJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT0gbmV4dEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQobmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHByZXZDaGlsZCA9IHByZXZJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KHByZXZJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIChwcmV2Q2hpbGQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAvLyAgICBwcmV2Q2hpbGQuc3ViSW5mby5ibHVyU2VsZigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIGZyb21Vc2VySW50ZXJhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5zdWJJbmZvLmZvY3VzU2VsZigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMsXG4gICAgLy8gbm90aWZ5IHRoZSBwcmV2aW91cyBjaGlsZCB0aGF0IGl0J3Mgbm8gbG9uZ2VyIHRhYmJhYmxlLFxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG1vdW50ZWQsIHVubW91bnRlZCk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7IGluaXRpYWxJbmRleCwgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiB0cnVlLCBrZXk6IFwidGFiYmFibGVcIiB9KTtcblxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN1YkluZm8sIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBmb2N1c1NlbGY6IGZvY3VzU2VsZk92ZXJyaWRlIH0gfSA9IGNoaWxkUGFyYW1ldGVycztcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTtcbiAgICAgICAgfSwgWyEhaGlkZGVuXSlcblxuXG4gICAgICAgIGNvbnN0IGZzT3ZlcnJpZGUgPSB1c2VTdGFibGVHZXR0ZXIoZm9jdXNTZWxmT3ZlcnJpZGUpO1xuICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcyA9IGZzT3ZlcnJpZGUoKTtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpIGFzIChFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgICAgICAvKmNvbnN0IGJsdXJTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnMgPSBic092ZXJyaWRlKCk7XG4gICAgICAgICAgICBpZiAoYnMpIHtcbiAgICAgICAgICAgICAgICBicygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5ibHVyPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pOyovXG5cbiAgICAgICAgY29uc3Qgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIF9wcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENoaWxkRWxlbWVudD4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIGdldERvY3VtZW50OiB1c2VDYWxsYmFjaygoKTogRG9jdW1lbnQgPT4geyByZXR1cm4gKGdldEVsZW1lbnQoKT8ub3duZXJEb2N1bWVudCkgPz8gKHdpbmRvdy5kb2N1bWVudCkgfSwgW10pIH0pO1xuXG4gICAgICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUsIGdldFRhYmJhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFiYmFibGVGbGFncyA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0VGFiYmFibGUsIHNldDogc2V0VGFiYmFibGUsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFoaWRkZW4pIH0pO1xuXG4gICAgICAgIGNvbnN0IF86IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHsgLi4uZmxhZ3MsIHRhYmJhYmxlOiB0YWJiYWJsZUZsYWdzLmN1cnJlbnQgfSBhcyBQYXJ0aWFsPFJlY29yZDxFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4sXG4gICAgICAgICAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAvL2JsdXJTZWxmLFxuICAgICAgICAgICAgICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgICAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogISFoaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgIHN1YkluZm9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxuICAgICAgICAgICAgICAgIHN0YWJsZU9uVGFiYmFibGVSZW5kZXIoaW5kZXgpO1xuICAgICAgICB9LCBbdGFiYmFibGUsIGluZGV4XSlcbiAgICAgICAgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChwcm9wcy50YWJJbmRleCA9PSBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KHVzZUhhc0ZvY3VzUHJvcHMoeyB0YWJJbmRleDogdGFiYmFibGUgPyAwIDogLTEgfSksIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZmApO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldFRhYmJhYmxlSW5kZXgoKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChpbmRleCk/LnN1YkluZm8uZm9jdXNTZWxmPy4oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChudWxsLCB0cnVlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgZ2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qZnVuY3Rpb24gdGVzdCgpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXgsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIH0gPSB1c2VSb3ZpbmdUYWJJbmRleDxIVE1MRGl2RWxlbWVudCwgeyBcImZvb1wiOiBcImJhclwiIH0sIFwiZmxhZzJcIj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHt9LCByb3ZpbmdUYWJJbmRleDoge30gfSk7XG4gICAgY29uc3QgeyB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7IG1hbmFnZWRDaGlsZHJlbjogeyBpbmRleDogMCwgZmxhZ3M6IHt9IH0sIHJ0aTogeyBpbmZvMzogeyBmb286IFwiYmFyXCIgfSB9IH0pO1xufSovXG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSYW5kb207XG4iLCJpbXBvcnQgYmFzZVJhbmRvbSBmcm9tICcuL19iYXNlUmFuZG9tLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgfVxuICBhcnJheS5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNodWZmbGVTZWxmO1xuIiwiaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IHNodWZmbGVTZWxmIGZyb20gJy4vX3NodWZmbGVTZWxmLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTaHVmZmxlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlNYXA7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVZhbHVlcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsImltcG9ydCBiYXNlSXNUeXBlZEFycmF5IGZyb20gJy4vX2Jhc2VJc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzVHlwZWRBcnJheTtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzO1xuIiwiaW1wb3J0IHNodWZmbGVTZWxmIGZyb20gJy4vX3NodWZmbGVTZWxmLmpzJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTaHVmZmxlO1xuIiwiaW1wb3J0IGFycmF5U2h1ZmZsZSBmcm9tICcuL19hcnJheVNodWZmbGUuanMnO1xuaW1wb3J0IGJhc2VTaHVmZmxlIGZyb20gJy4vX2Jhc2VTaHVmZmxlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNodWZmbGU7XG4iLCJpbXBvcnQgKiBhcyBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTXV0YWJsZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSBcIi4vdXNlLWZvcmNlLXVwZGF0ZVwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IGxvZGFzaFNodWZmbGUgZnJvbSBcImxvZGFzaC1lcy9zaHVmZmxlXCI7XG5cbmV4cG9ydCB0eXBlIEdldEluZGV4PEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHJvdzogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+KSA9PiAobnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCk7XG5leHBvcnQgdHlwZSBHZXRWYWx1ZTxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+ID0gKHJvdzogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+LCAuLi5hcmdzOiBHKSA9PiBWO1xuZXhwb3J0IHR5cGUgQ29tcGFyZTxWPiA9IChsaHM6IFYsIHJoczogVikgPT4gbnVtYmVyO1xuXG4vKipcbiAqIEFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgKipNVVNUKiogYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4ge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4sIGUuZy4sIHRoZSByb3cgaW5kZXggb2YgdGhpcyBjaGlsZFxuICAgICAqIChVc3VhbGx5IGp1c3QgYW4gYGluZGV4YCBwcm9wKVxuICAgICAqL1xuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogR2V0SW5kZXg8QywgSz47IH1cbn1cblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPiB7XG4gICAgc29ydGFibGVDaGlsZHJlbjoge1xuICAgICAgICAvKipcbiAgICAgICAgICogTXVzdCByZXR1cm4gdGhlIHZhbHVlIHRoaXMgY2hpbGQgdXNlcyBSRTogc29ydGluZy5cbiAgICAgICAgICogSWYgeW91IGRvbid0IGNhcmUgYWJvdXQgc29ydGluZyAoeW91IGp1c3QgdXNlIFxuICAgICAgICAgKiB5b3VyIG93bmFyYml0cmFyeSByZW9yZGVyaW5nKSwgdGhpcyB3aWxsIG5ldmVyXG4gICAgICAgICAqIGJlIHVzZWQsIHNvIGl0IGNhbiByZXR1cm4gYW55dGhpbmcuXG4gICAgICAgICAqIEBwYXJhbSByb3cgXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsdWU6IEdldFZhbHVlPEMsIEssIEcsIFY+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBob3cgdmFsdWVzIGNvbXBhcmUgYWdhaW5zdCBlYWNoIG90aGVyLlxuICAgICAgICAgKiBAcGFyYW0gbGhzIFxuICAgICAgICAgKiBAcGFyYW0gcmhzIFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZTogQ29tcGFyZTxWPjtcbiAgICB9XG59XG5cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqXG4gKiBcbiAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb25gOyBpdCB0YWtlcyB0aGUgc2FtZSBgaW5kZXhNYW5nbGVyYCBhbmQgYGluZGV4RGVtYW5nbGVyYCBcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcbiAqIHRoaXMgaG9vayBpbXBvc2VzIHNlcmlvdXMgcmVzdHJpY3Rpb25zIG9uIGNoaWxkIHN0cnVjdHVyZSwgd2hpbGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBhbGxvd3MgYW55dGhpbmcuXG4gKiBcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXG4gKiBzb3J0IGFsbCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlaXIgdmFsdWUgZnJvbSB0aGUgYGdldFZhbHVlYCBhcmd1bWVudCB5b3UgcGFzcyBpbi5cbiAqIFxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XG4gKiByZS1tYXAgZWFjaCBjaGlsZCdzIHBvc2l0aW9uIHVzaW5nIGBtYW5nbGVNYXBgIGFuZCBgZGVtYW5nbGVNYXBgLCB3aGljaCBjb252ZXJ0IGJldHdlZW5cbiAqIHNvcnRlZCBhbmQgdW5zb3J0ZWQgaW5kZXggcG9zaXRpb25zLlxuICogXG4gKiBBZ2FpbiwgdW5saWtlIHNvbWUgb3RoZXIgaG9va3MsICoqdGhlc2UgY2hpbGRyZW4gbXVzdCBiZSBkaXJlY3QgZGVzY2VuZGFudHMqKi4gVGhpcyBpcyBiZWNhdXNlXG4gKiB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayBpbnNwZWN0cyB0aGUgZ2l2ZW4gY2hpbGRyZW4sIHRoZW4gcmUtY3JlYXRlcyB0aGVtIHdpdGggbmV3IGBrZXlgcy5cbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcbiAqIHRoZXJlJ3Mgbm8gb3RoZXIgdGltZSBvciBwbGFjZSB0aGlzIGNhbiBoYXBwZW4gb3RoZXIgdGhhbiBleGFjdGx5IHdpdGhpbiB0aGUgcGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9OiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+KTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLPiB7XG5cbiAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGEgbWFwcGluZyBiZXR3ZWVuIHVuc29ydGVkIGluZGV4IDwtLS0+IHNvcnRlZCBpbmRleC5cbiAgICAvLyBUaGVzZSBhcmUgbmVlZGVkIGZvciBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMuXG4gICAgY29uc3QgbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xuICAgIGNvbnN0IGRlbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xuICAgIGNvbnN0IGluZGV4TWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcbiAgICBjb25zdCBpbmRleERlbWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChkZW1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuXG4gICAgLy8gVGhlIHNvcnQgZnVuY3Rpb24gbmVlZHMgdG8gYmUgYWJsZSB0byB1cGRhdGUgd2hvZXZlciBoYXMgYWxsIHRoZSBzb3J0YWJsZSBjaGlsZHJlbi5cbiAgICAvLyBCZWNhdXNlIHRoYXQgbWlnaHQgbm90IGJlIHRoZSBjb25zdW1lciBvZiAqdGhpcyogaG9vayBkaXJlY3RseSAoZS5nLiBhIHRhYmxlIHVzZXNcbiAgICAvLyB0aGlzIGhvb2ssIGJ1dCBpdCdzIHRib2R5IHRoYXQgYWN0dWFsbHkgbmVlZHMgdXBkYXRpbmcpLCB3ZSBuZWVkIHRvIHJlbW90ZWx5XG4gICAgLy8gZ2V0IGFuZCBzZXQgYSBmb3JjZVVwZGF0ZSBmdW5jdGlvbi5cbiAgICAvL2NvbnN0IFtnZXRGb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRGb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwsIHJldHVybk51bGwpO1xuXG4gICAgY29uc3QgcmVhcnJhbmdlID0gdXNlQ2FsbGJhY2soKHNvcnRlZFJvd3M6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB7XG5cbiAgICAgICAgLy8gVXBkYXRlIG91ciBzb3J0ZWQgPC0tPiB1bnNvcnRlZCBpbmRpY2VzIG1hcCBcbiAgICAgICAgLy8gYW5kIHJlcmVuZGVyIHRoZSB3aG9sZSB0YWJsZSwgYmFzaWNhbGx5XG4gICAgICAgIGZvciAobGV0IGluZGV4QXNTb3J0ZWQgPSAwOyBpbmRleEFzU29ydGVkIDwgc29ydGVkUm93cy5sZW5ndGg7ICsraW5kZXhBc1NvcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhBc1Vuc29ydGVkID0gc29ydGVkUm93c1tpbmRleEFzU29ydGVkXS5pbmRleDtcblxuICAgICAgICAgICAgbWFuZ2xlTWFwLmN1cnJlbnQuc2V0KGluZGV4QXNVbnNvcnRlZCwgaW5kZXhBc1NvcnRlZCk7XG4gICAgICAgICAgICBkZW1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzU29ydGVkLCBpbmRleEFzVW5zb3J0ZWQpO1xuICAgICAgICB9XG5cblxuICAgICAgICBnZXRGb3JjZVVwZGF0ZSgpPy4oKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VSZWFycmFuZ2VhYmxlUHJvcHMgPSB1c2VDYWxsYmFjaygoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0Rm9yY2VVcGRhdGUoX3ByZXYgPT4gZm9yY2VVcGRhdGUpOyB9LCBbZm9yY2VVcGRhdGVdKVxuXG4gICAgICAgIHJldHVybiAodXNlTWVyZ2VkUHJvcHM8UGFyZW50RWxlbWVudD4oe1xuICAgICAgICAgICAgY2hpbGRyZW46XG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuIGFzIFZOb2RlPE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPj5bXSlcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAgICAgLm1hcChjaGlsZCA9PiAoeyBjaGlsZCwgbWFuZ2xlZEluZGV4OiBpbmRleE1hbmdsZXIoZ2V0SW5kZXgoY2hpbGQucHJvcHMhKSEpLCBkZW1hbmdsZWRJbmRleDogZ2V0SW5kZXgoY2hpbGQucHJvcHMpIH0pKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocy5tYW5nbGVkSW5kZXggLSByaHMubWFuZ2xlZEluZGV4IH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHsgY2hpbGQsIG1hbmdsZWRJbmRleCwgZGVtYW5nbGVkSW5kZXggfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoY2hpbGQudHlwZSBhcyBhbnksIHsgLi4uY2hpbGQucHJvcHMsIGtleTogZGVtYW5nbGVkSW5kZXgsIFwiZGF0YS1tYW5nbGVkLWluZGV4XCI6IG1hbmdsZWRJbmRleCwgXCJkYXRhLXVubWFuZ2xlZC1pbmRleFwiOiBkZW1hbmdsZWRJbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgcHJvcHMpKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyB1c2VSZWFycmFuZ2VhYmxlUHJvcHMsIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyLCBtYW5nbGVNYXAsIGRlbWFuZ2xlTWFwLCByZWFycmFuZ2UgfSB9O1xufVxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISogXG4gKiBcbiAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb25gOyBpdCB0YWtlcyB0aGUgc2FtZSBgaW5kZXhNYW5nbGVyYCBhbmQgYGluZGV4RGVtYW5nbGVyYCBcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcbiAqIHRoaXMgaG9vayBpbXBvc2VzIHNlcmlvdXMgcmVzdHJpY3Rpb25zIG9uIGNoaWxkIHN0cnVjdHVyZSwgd2hpbGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBhbGxvd3MgYW55dGhpbmcuXG4gKiBcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXG4gKiBzb3J0IGFsbCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlaXIgdmFsdWUgZnJvbSB0aGUgYGdldFZhbHVlYCBhcmd1bWVudCB5b3UgcGFzcyBpbi5cbiAqIFxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XG4gKiByZS1tYXAgZWFjaCBjaGlsZCdzIHBvc2l0aW9uIHVzaW5nIGBtYW5nbGVNYXBgIGFuZCBgZGVtYW5nbGVNYXBgLCB3aGljaCBjb252ZXJ0IGJldHdlZW5cbiAqIHNvcnRlZCBhbmQgdW5zb3J0ZWQgaW5kZXggcG9zaXRpb25zLlxuICogXG4gKiBBZ2FpbiwgdW5saWtlIHNvbWUgb3RoZXIgaG9va3MsICoqdGhlc2UgY2hpbGRyZW4gbXVzdCBiZSBkaXJlY3QgZGVzY2VuZGFudHMqKi4gVGhpcyBpcyBiZWNhdXNlXG4gKiB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayBpbnNwZWN0cyB0aGUgZ2l2ZW4gY2hpbGRyZW4sIHRoZW4gcmUtY3JlYXRlcyB0aGVtIHdpdGggbmV3IGBrZXlgcy5cbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcbiAqIHRoZXJlJ3Mgbm8gb3RoZXIgdGltZSBvciBwbGFjZSB0aGlzIGNhbiBoYXBwZW4gb3RoZXIgdGhhbiBleGFjdGx5IHdpdGhpbiB0aGUgcGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSwgc29ydGFibGVDaGlsZHJlbjogeyBjb21wYXJlOiB1c2VyQ29tcGFyZSwgZ2V0VmFsdWUgfSB9OiBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLLCBHLCBWPik6IFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIEMsIEssIEc+IHtcblxuICAgIGNvbnN0IGNvbXBhcmUgPSAodXNlckNvbXBhcmUgPz8gZGVmYXVsdENvbXBhcmUpO1xuXG4gICAgY29uc3QgeyB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IHVzZVNvcnRhYmxlUHJvcHMsIC4uLnJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUgfSA9IHVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9IH0pO1xuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IHJlYXJyYW5nZSB9IH0gPSByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlO1xuICAgIC8vIFRoZSBhY3R1YWwgc29ydCBmdW5jdGlvbi5cbiAgICBjb25zdCBzb3J0ID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPiwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIsIC4uLmFyZ3M6IEcpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG5cbiAgICAgICAgY29uc3Qgc29ydGVkUm93cyA9IG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKS5zb3J0KChsaHNSb3csIHJoc1JvdykgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGdldFZhbHVlKGxoc1JvdywgLi4uYXJncykgYXMgYW55O1xuICAgICAgICAgICAgY29uc3QgcmhzVmFsdWUgPSBnZXRWYWx1ZShyaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmUobGhzVmFsdWUsIHJoc1ZhbHVlKSAvLyBsaHNSb3cuZ2V0TWFuYWdlZENlbGxzKCk/Lltjb2x1bW5dPy52YWx1ZSwgcmhzUm93LmdldE1hbmFnZWRDZWxscygpPy5bY29sdW1uXT8udmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblswXSA9PSBcImRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlYXJyYW5nZShzb3J0ZWRSb3dzKTtcblxuICAgIH0sIFsgLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBzaHVmZmxlID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPik6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2h1ZmZsZWRSb3dzID0gbG9kYXNoU2h1ZmZsZShtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkpXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc2h1ZmZsZWRSb3dzKTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiB7IHNvcnQsIHNodWZmbGUgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnJlYXJyYW5nZWFibGVDaGlsZHJlblxuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyBhbiBhcnJheSBvZiBub3Qtc29ydGVkIGNoaWxkIGluZm9ybWF0aW9uIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICogYW5kIHRoZSBjaGlsZHJlbiB3aWxsIHJlLWFycmFuZ2UgdGhlbXNlbHZlcyB0byBtYXRjaC5cbiAgICAgICAgICogIFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqICBcbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICByZWFycmFuZ2U6IChyb3dzSW5PcmRlcjogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+W10pID0+IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBtYW5nbGVNYXA6IE11dGFibGVSZWY8TWFwPG51bWJlciwgbnVtYmVyPj47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGRlbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEs+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJlYXJyYW5nZWFibGVQcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB8IHVuZGVmaW5lZDsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEs+IHtcbiAgICBzb3J0YWJsZUNoaWxkcmVuOiB7LyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc29ydDogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPiwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIsIC4uLmFyZ3M6IEcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzaHVmZmxlOiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHNcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlU29ydGFibGVQcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB8IHVuZGVmaW5lZDsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUxKGxocywgcmhzKTtcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmUzKGxoczogc3RyaW5nIHwgbnVtYmVyLCByaHM6IHN0cmluZyB8IG51bWJlcikge1xuXG4gICAgICAgIC8vIENvZXJjZSBzdHJpbmdzIHRvIG51bWJlcnMgaWYgdGhleSBzZWVtIHRvIHN0YXkgdGhlIHNhbWUgd2hlbiBzZXJpYWxpemVkXG4gICAgICAgIGlmIChgJHsrbGhzfWAgPT09IGxocylcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XG4gICAgICAgIGlmIChgJHsrcmhzfWAgPT09IHJocylcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XG5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgaWYgZWl0aGVyIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0dXJuIHRoZSBvdGhlciBvbmUgaW50byBvbmUgdG9vXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmhzID0gYCR7cmhzfWA7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgbGhzID0gYCR7bGhzfWA7XG5cbiAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIGxocyA9PT0gdHlwZW9mIHJocyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gbGhzLmxvY2FsZUNvbXBhcmUocmhzIGFzIHN0cmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuICtsaHMgLSArcmhzO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlMihsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcImJvb2xlYW5cIiB8fCBsaHMgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgbGhzID0gK2xocztcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwiYm9vbGVhblwiIHx8IHJocyBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICByaHMgPSArcmhzO1xuICAgICAgICByZXR1cm4gY29tcGFyZTMobGhzLCByaHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlMShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggbnVsbFxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGhzID09IG51bGwgfHwgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE9uZSBvZiB0aGUgdHdvIGlzIG51bGwgLS0gZWFzeSBjYXNlXG4gICAgICAgICAgICByZXR1cm4gbGhzICE9IG51bGwgPyAxIDogLTFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZTIobGhzLCByaHMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VQcmVzcyB9IGZyb20gXCIuL3VzZS1wcmVzc1wiO1xuaW1wb3J0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXMsIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbiwgTWFuYWdlZENoaWxkcmVuT21pdHMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgdXNlQ2hpbGRyZW5GbGFnIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIHVzZVJvdmluZ1RhYkluZGV4LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcbmltcG9ydCB7IHVzZVNvcnRhYmxlQ2hpbGRyZW4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxuICogXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XG4gKiB8LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXxcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcbiAqIHxFTnxIaXzvvKjvvYl84pyFfOKchXzinIV84p2MfFxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGFhfOKdjHzinYx84p2MfOKdjHxcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfEFhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfOOBi3zinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB844KrfOOCrHzinIV84p2MfOKdjHzinYx8XG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XG4gKiBcbiAqIFxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15OiBhbnkgPSBudWxsO1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5PFQ+KHQ6IFQpIHsgcmV0dXJuIHQ7IH1cbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4ge1xuICAgIHRleHQ6IHN0cmluZztcblxuICAgIHN1YkluZm86IEM7XG59XG5cbi8qKlxuICogQHBhcmFtIGZyb21Vc2VySW50ZXJhY3Rpb24gV2hldGhlciB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhpcyBjaGlsZCBhcyBhIG1lYW5zIG9mIG5hdmlnYXRpbmcgdG8gaXQuICBJbiB0aGF0IHdhcyB0aGUgY2FzZSwgdGhlIGNoaWxkIGlzIGFsc28gZm9jdXNlZC4gT3RoZXJ3aXNlLCBmb2N1cyBtb3ZlcyBhcyB0aGUgYnJvd3NlciBkZXRlcm1pbmVzLlxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0ZVRvSW5kZXggPSAoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcblxuXG5pbnRlcmZhY2UgTFNQIHtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYW5kIGluZGV4RGVtYW5nbGVyIGFyZSB1c2VkIHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG5hdmlnYXRlZCBpbiBhbiBvcmRlclxuICAgICAqIHRoYXQgZG9lc24ndCBuZWNlc3NhcmlseSBtYXRjaCB0aGVpciBjaGlsZCBvcmRlciwgbGlrZSBpZiBhIGxpc3QgaXMgc29ydGVkLlxuICAgICAqIFxuICAgICAqIFVzZWQgdG8gdHVybiBhbiBcImFic29sdXRlXCIgaW5kZXggaW50byBhIFwic29ydGVkL2ZpbHRlcmVkL21hbmdsZWRcIiBvbmUuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXG4gICAgICogQHBhcmFtIHJhd0luZGV4IFxuICAgICAqL1xuICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHVybiBhIFwibWFuZ2xlZFwiIGluZGV4IGludG8gaXQncyBcInVuc29ydGVkXCIgb3IgXCJ1bm1hbmdsZWRcIiBpbmRleC5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXgsXG4gICAgICogaXQgbmVlZHMgdG8gYmUgZGVtYW5nbGVkIHRvIGRvIFwibm9ybWFsXCIgbWF0aCBvbiBpdCwgYW5kIHRoZW4gcmUtbWFuZ2xlZCAoYWJvdmUpXG4gICAgICogdG8gdHVybiB0aGF0IGFic29sdXRlIHJvdyBpbmRleCBiYWNrIGludG8gYSBtYW5nbGVkIG9uZS5cbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtZWRJbmRleCBcbiAgICAgKi9cbiAgICBpbmRleERlbWFuZ2xlcj8odHJhbnNmb3JtZWRJbmRleDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIExTUDtcblxuLy8gKioqIFBhcmFtZXRlcnMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFJ0aU9taXRzLCBNY09taXRzPixcbiAgICBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxUbk9taXRzIHwgXCJnZXRJbmRleFwiIHwgXCJzZXRJbmRleFwiPixcbiAgICBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxMbk9taXRzIHwgXCJuYXZpZ2F0ZVRvRmlyc3RcIiB8IFwibmF2aWdhdGVUb0xhc3RcIiB8IFwibmF2aWdhdGVUb05leHRcIiB8IFwibmF2aWdhdGVUb1ByZXZcIj4ge1xuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PExTUCwgTHNPbWl0cz47XG59XG5cbmludGVyZmFjZSBTU1Age1xuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgb25TZWxlY3RlZEluZGV4Q2hhbmdlOiAoZXZlbnQ6IEV2ZW50LCBuZXdJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICAgIHNlbGVjdGlvbk1vZGU6IFwiZm9jdXNcIiB8IFwiYWN0aXZhdGlvblwiO1xufVxuZXhwb3J0IHR5cGUgU2luZ2xlU2VsZWN0aW9uT21pdHMgPSBrZXlvZiBTU1A7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzIHwgXCJpbml0aWFsSW5kZXhcIiwgTWNPbWl0cz4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjogT21pdDxTU1AsIFNTT21pdHM+O1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBQYXJ0aWFsPFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyc1tcImNoaWxkcmVuSGF2ZUZvY3VzXCJdPjtcbn1cbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyA9IGtleW9mIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxhbnk+O1xuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIFJ0aU9taXRzLCBNY09taXRzLCBTdWJiZXN0SW5mbz4ge1xuICAgIC8vcm92aW5nVGFiSW5kZXg6IE9taXQ8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIG5ldmVyPltcInJvdmluZ1RhYkluZGV4XCJdLCBcInN1YkluZm9cIj47XG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIExzT21pdHMgfCBcInN1YkluZm9cIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEsgfCBcInNlbGVjdGVkXCIsIExzT21pdHMsIFJ0aU9taXRzLCBNY09taXRzLCBTdWJiZXN0SW5mbz4ge1xuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4+LCBcInRhYmJhYmxlXCIgfCBFeHRyYUZsYWdLZXlzPiwgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleDogTmF2aWdhdGVUb0luZGV4IH07XG59XG5cbi8vICoqKiBSZXR1cm4gdHlwZXMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+W1widXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7XG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuO1xuICAgICAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHM6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD5bXCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNcIl07XG59XG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHByb3BlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBjb21wb25lbnRzIGxpa2UgbGlzdGJveGVzLCBidXR0b24gZ3JvdXBzLCBtZW51cywgZXRjLlxuICogXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXG4gKiBOYXZpZ2F0aW5nIGZvcndhcmRzL2JhY2t3YXJkcyBjYW4gYmUgZG9uZSB3aXRoIHRoZSBhcnJvdyBrZXlzLCBIb21lL0VuZCBrZXlzLCBvciBhbnkgYW55IHRleHQgZm9yIHR5cGVhaGVhZCB0byBmb2N1cyB0aGUgbmV4dCBpdGVtIHRoYXQgbWF0Y2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgLi4ubWMgfSxcbiAgICByb3ZpbmdUYWJJbmRleCxcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBpbmRleE1hbmdsZXIgPz89IGlkZW50aXR5O1xuICAgIGluZGV4RGVtYW5nbGVyID8/PSBpZGVudGl0eTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxpc3ROYXZpZ2F0aW9uXCIsIGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIpO1xuXG5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgICAgIC4uLm1jLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG0sIHUpO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LCByb3ZpbmdUYWJJbmRleDogeyBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0gfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0cnlOYXZpZ2F0ZVRvSW5kZXgoe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgICAgIHRhcmdldDogaSxcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaSA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWRcbiAgICAgICAgfVxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldjogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKChjID8/IDApKSAtIDEpLCBzZWFyY2hEaXJlY3Rpb246IC0xLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0OiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoYyA/PyAwKSArIDEpLCBzZWFyY2hEaXJlY3Rpb246IDEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKDApLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyIShjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSksIHRydWUpOyB9LCBbXSksXG4gICAgICAgICAgICAuLi5saW5lYXJOYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHModXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzKHByb3BzKSk7XG4gICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25Qcm9wcywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzXSk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9LCBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sIHN1YkluZm8gfSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkKHsgdGV4dCwgaW5kZXggfSk7XG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VGFiYmFibGVJbmRleCgpID09IGdldEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbjogISFoaWRkZW4gfSxcbiAgICAgICAgICAgIHN1YkluZm86IHsgdGV4dCwgc3ViSW5mbyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMoKCh7IGluZXJ0OiBoaWRkZW4gfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSkpLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBuYXZpZ2F0ZVRvSW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG5cbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH1cbiAgICAgICAgLypsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfSovXG4gICAgfVxufVxuXG5cblxuXG5cblxuLyoqXG4gKiBJdCdzIHZlcnkgY29tbW9uIHRvIGNvbWJpbmUgYSB0YWJiYWJsZSBsaXN0IG9mIHRoaW5ncyBhbmQgXCJzZWxlY3Rpb25cIiBvZiBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICogXG4gKiBMaXN0cywgcmFkaW8gYnV0dG9ucywgdGFicywgZXRjLiBldGMuXG4gKiBcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCB0aGF0IGNvbWJpbmVzIHRoZSB0d28gd2l0aCB0aGUgY29ycmVjdCB0eXBpbmcuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgb25TZWxlY3RlZEluZGV4Q2hhbmdlIH0sXG4gICAgbGlzdE5hdmlnYXRpb24sXG4gICAgbWFuYWdlZENoaWxkcmVuLFxuICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLnJvdmluZ1RhYkluZGV4IH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cbn06IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgIGluaXRpYWxJbmRleDogKHNlbGVjdGVkSW5kZXggPz8gdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIC4uLnJvdmluZ1RhYkluZGV4XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCB9ID0gdXNlQ2hpbGRyZW5IYXZlRm9jdXMoe1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czoge1xuICAgICAgICAgICAgb25BbGxMb3N0Rm9jdXM6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQW55R2FpbmVkRm9jdXNcbiAgICAgICAgfSwgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3RhYmxlT25DaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdGVkSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0UmVzdFxuICAgIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSwgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9IH0gPSBsaXN0UmVzdDtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hhbmdlSW5kZXg6IGNoYW5nZVNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGdldEN1cnJlbnRJbmRleDogZ2V0U2VsZWN0ZWRJbmRleCxcbiAgICAgICAgLy9yZWV2YWx1YXRlQ2xvc2VzdEZpdFxuICAgIH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSyB8IFwic2VsZWN0ZWRcIj4oe1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGluaXRpYWxJbmRleDogc2VsZWN0ZWRJbmRleCxcbiAgICAgICAga2V5OiBcInNlbGVjdGVkXCIsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aSwgbGlzdE5hdmlnYXRpb246IGxzLCBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0sIHN1YkluZm8gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldElzU2VsZWN0ZWQsIGdldElzU2VsZWN0ZWRdID0gdXNlU3RhdGUoZ2V0U2VsZWN0ZWRJbmRleCgpID09IGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUmVmID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRJc1NlbGVjdGVkLCBzZXQ6IHNldElzU2VsZWN0ZWQsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFydGkuaGlkZGVuKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkKHtcbiAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSA9PSAnZm9jdXMnICYmIGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFibGVPbkNoYW5nZSh7IHRhcmdldDogZ2V0RWxlbWVudCgpLCBjdXJyZW50VGFyZ2V0OiBnZXRFbGVtZW50KCkgfSBhcyBFdmVudCwgZ2V0SW5kZXgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmhhc0ZvY3VzLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1xuICAgICAgICAgICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBQYXJ0aWFsPFJlY29yZDxLIHwgXCJzZWxlY3RlZFwiIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IGxzLFxuICAgICAgICAgICAgICAgIHN1YkluZm8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcblxuICAgICAgICAgICAgY29uc3QgdXNlUHJlc3NQcm9wcyA9IHVzZVByZXNzPENoaWxkRWxlbWVudD4oeyBvbkNsaWNrU3luYzogKGUpID0+IHsgc3RhYmxlT25DaGFuZ2UoZSwgZ2V0SW5kZXgoKSk7IH0sIGV4Y2x1ZGU6IHt9LCBoYXNGb2N1cyB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gdXNlUHJlc3NQcm9wcyh1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHModXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKSkpLFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZDogaXNTZWxlY3RlZCwgZ2V0U2VsZWN0ZWQ6IGdldElzU2VsZWN0ZWQgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW3NlbGVjdGlvbk1vZGVdKSxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKC4uLnA6IFBhcmFtZXRlcnM8dHlwZW9mIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM+KSA9PiB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKC4uLnApIH0sIFtdKSxcbiAgICAgICAgLi4ubGlzdFJlc3QsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge31cbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFYsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4ge1xufVxuXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHMsIEM+O1xuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+KHsgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbiwgcm92aW5nVGFiSW5kZXgsIHR5cGVhaGVhZE5hdmlnYXRpb24sIHJlYXJyYW5nZWFibGVDaGlsZHJlbiwgc29ydGFibGVDaGlsZHJlbiB9OiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxDLCBLLCBHLCBWLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSywgRywgVj4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW4sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgLi4ubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzID0gKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiB7XG4gICAgICAgIHJldHVybiAodXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VTb3J0YWJsZVByb3BzKHByb3BzKSkpXG4gICAgfVxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz4gPSAocCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChwKVxuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGUsXG4gICAgICAgIC4uLnNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlXG4gICAgICAgIC8qbWFuYWdlZENoaWxkcmVuOiBsaXN0TmF2UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3ROYXZSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5zb3J0YWJsZUNoaWxkcmVuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnJlYXJyYW5nZWFibGVDaGlsZHJlbiovXG4gICAgfSk7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGFyZ3M6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cywgTHNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiwgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHNcbiAgICBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbiwgcm92aW5nVGFiSW5kZXgsIHNpbmdsZVNlbGVjdGlvbiwgdHlwZWFoZWFkTmF2aWdhdGlvbiwgY2hpbGRyZW5IYXZlRm9jdXMgfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIFtdPiB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEssIFtdLCBudW1iZXI+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XG4gICAgICAgICAgICBnZXRWYWx1ZTogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSksXG4gICAgICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjaygobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocyAtIHJoczsgfSwgW10pLFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc2luZ2xlU2VsZWN0aW9uLFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogY2hpbGRyZW5IYXZlRm9jdXNcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlU29ydGFibGVQcm9wcyhwcm9wcykpKTtcbiAgICB9XG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkID0gKHA6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh7XG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxuICAgICAgICAvL3NvcnRhYmxlOiB7IHNvcnQsIHNodWZmbGUsIHJlYXJyYW5nZSwgZGVtYW5nbGVNYXAsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIG1hbmdsZU1hcCB9LFxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGUsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSk7XG5cbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEs+O1xuICAgIGRlZmF1bHQ6IG51bWJlcjtcbiAgICB0YXJnZXQ6IG51bWJlcjtcbiAgICBzZWFyY2hEaXJlY3Rpb246IDEgfCAtMTtcbiAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlOYXZpZ2F0ZVRvSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbiwgc2VhcmNoRGlyZWN0aW9uLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCB0YXJnZXQgfTogVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEs+KSB7XG4gICAgY29uc3QgdXBwZXIgPSBjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKTtcbiAgICBjb25zdCBsb3dlciA9IDA7XG5cbiAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICB3aGlsZSAoKHRhcmdldCA+PSBsb3dlciAmJiAoY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKSlcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpIC0gMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA8IGxvd2VyID8gaW5kZXhEZW1hbmdsZXIobG93ZXIpIDogdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPD0gdXBwZXIgJiYgY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgKyAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0ID4gdXBwZXIgPyBpbmRleERlbWFuZ2xlcih1cHBlcikgOiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG93ZXI7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzIH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuaW1wb3J0IHsgdXNlSGFzRm9jdXMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cbi8qKlxuICogR3JpZHMgYXJlIGltcGxlbWVudGVkIHVzaW5nIHR3byBzZXRzIG9mIGxpc3QgbmF2aWdhdGlvbi5cbiAqIFxuICogVGhpcyByZXN1bHRzIGluIGEgbG90IG9mIHRoaW5ncyB3aXRoIHZlcnkgc2ltaWxhciBuYW1lcyBhbmQganVzdCBjb25mdXNpb24gYWxsIGFyb3VuZC4gUGxlYXNlIHVzZSBjYXV0aW9uLlxuICovXG5cbi8vIFBhcmFtZXRlcnMgKHBhcmVudCwgcm93LCBjZWxsKVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHsgXG4gICAgICAgIHJvd0luZGV4TWFuZ2xlcj86IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wibGlzdE5hdmlnYXRpb25cIl1bXCJpbmRleE1hbmdsZXJcIl07XG4gICAgICAgIHJvd0luZGV4RGVtYW5nbGVyPzogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJsaXN0TmF2aWdhdGlvblwiXVtcImluZGV4RGVtYW5nbGVyXCJdO1xuICAgICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxcbiAgICBDUixcbiAgICBLUiBleHRlbmRzIHN0cmluZyxcbiAgICBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsXG4gICAgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cyxcbiAgICBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLFxuICAgIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsXG4gICAgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzLFxuXG4gICAgTHNDaGlsZE9taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLFxuICAgIFJ0aUNoaWxkT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsXG4gICAgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsXG5cbiAgICBTdWJiZXN0SW5mb1xuICAgID4ge1xuICAgIGFzUGFyZW50Um93T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMgfCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiwgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+O1xuICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENSLCBLUiwgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPlxuICAgICAgICBcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZywgTHNDaGlsZE9taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQywgS0MsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4ge1xuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Sb3c6IFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSLCBLQz47XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGFzQ2hpbGRSb3c6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxSb3c+O1xuICAgIGFzUGFyZW50T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDZWxsLCBDQywgS0M+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93LCBDZWxsLCBDQywgS0M+IHtcbiAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGw6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsLCBDQywgS0M+O1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIC8vcm93SXNUYWJiYWJsZTogYm9vbGVhbjtcbiAgICAgICAgLy9nZXRSb3dJc1RhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPENSLCBLUiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDUj4pID0+IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3csIENlbGwsIENDLCBLQz47XG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsLCBDQywgS0MsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIENDPikgPT4gVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsPjtcblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb248XG4gICAgUGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93U3ViSW5mbyxcbiAgICBDZWxsU3ViSW5mbyxcbiAgICBSb3dFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nLFxuICAgIENlbGxFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nXG4+KHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgbGlzdE5hdmlnYXRpb246IGxzLFxuICAgIGxpbmVhck5hdmlnYXRpb246IGxuLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuLFxuICAgIGdyaWROYXZpZ2F0aW9uOiB7IHJvd0luZGV4RGVtYW5nbGVyLCByb3dJbmRleE1hbmdsZXIgfVxufTogVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUm93U3ViSW5mbywgQ2VsbFN1YkluZm8sIFJvd0V4dHJhRmxhZ3MsIENlbGxFeHRyYUZsYWdzPiB7XG4gICAgY29uc3QgW2N1cnJlbnRDb2x1bW4sIHNldEN1cnJlbnRDb2x1bW4sIGdldEN1cnJlbnRDb2x1bW5dID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4ocnRpLmluaXRpYWxJbmRleCA/PyAwKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcbiAgICAgICAgLi4ucGFyZW50THNSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgUm93U3ViSW5mbywgUm93RXh0cmFGbGFncz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlcjogcm93SW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlcjogcm93SW5kZXhNYW5nbGVyLCAuLi5scyB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IG5hdmlnYXRpb25EaXJlY3Rpb246IFwidmVydGljYWxcIiwgLi4ubG4gfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG4sXG4gICAgfSk7XG5cblxuICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uUm93ID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb246IGFzQ2hpbGQsIGFzUGFyZW50Um93T2ZDZWxsczogYXNQYXJlbnQgfSkgPT4ge1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgZm9jdXNTZWxmIHRoYXQgcm92aW5nVGFiSW5kZXggZG9lcy5cbiAgICAgICAgLy8gSW5zdGVhZCBvZiBmb2N1c2luZyB0aGUgZW50aXJlIHJvdywgd2UgYXNrIHRoZSBjZWxsIHRoYXQgY29ycmVzcG9uZHNcbiAgICAgICAgLy8gdG8gb3VyIGN1cnJlbnQgY29sdW1uIHRvIGZvY3VzIGl0c2VsZi5cbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYzIgPSBnZXRDdXJyZW50Q29sdW1uKCk7XG4gICAgICAgICAgICBpZiAoYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYpIHtcbiAgICAgICAgICAgICAgICBhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGMyID8/IDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByb3dMc0NoaWxkUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3coe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiBhc0NoaWxkLm1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzQ2hpbGQubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzQ2hpbGQucm92aW5nVGFiSW5kZXgsIGZvY3VzU2VsZiB9LFxuICAgICAgICAgICAgc3ViSW5mbzogYXNDaGlsZC5zdWJJbmZvLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHJvd0xzQ2hpbGRSZXR1cm5UeXBlO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0YWJiYWJsZSkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPENlbGxFbGVtZW50LCBDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPih7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4uYXNQYXJlbnQubWFuYWdlZENoaWxkcmVuIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc1BhcmVudC5yb3ZpbmdUYWJJbmRleCB9LFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgICAgIC4uLmFzUGFyZW50LmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC50eXBlYWhlYWROYXZpZ2F0aW9uLCBub1R5cGVhaGVhZDogdHJ1ZSB9LFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4uYXNQYXJlbnQubGlzdE5hdmlnYXRpb24gfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlR3JpZE5hdmlnYXRpb25Db2x1bW4yLCB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtblByb3BzLCBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSB9ID0gcm93THNSZXR1cm5UeXBlO1xuXG4gICAgICAgIC8vY29uc3Qgcm93SGlkZGVuID0gISFhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmhpZGRlbjtcblxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDYWxsYmFjazxVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4+KCh7IHN1YkluZm8sIGhhc0ZvY3VzOiB7IG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0sIG1hbmFnZWRDaGlsZCwgbGlzdE5hdmlnYXRpb246IGxzLCByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGY6IGZzLCAuLi5ydGkgfSB9KSA9PiB7XG4gICAgICAgICAgICAvL3J0aS5oaWRkZW4gfHwgcm93SGlkZGVuO1xuXG4gICAgICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZzKVxuICAgICAgICAgICAgICAgICAgICBmcygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHJ0aV9jZWxsX3JldC5nZXRFbGVtZW50KCkgYXMgRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KT8uZm9jdXM/LigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKmNvbnN0IGJsdXJTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChicylcbiAgICAgICAgICAgICAgICAgICAgYnMoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIChydGlfY2VsbF9yZXQuZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik/LmJsdXI/LigpO1xuICAgICAgICAgICAgfSk7Ki9cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldFxuICAgICAgICAgICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMih7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiBtYW5hZ2VkQ2hpbGQsXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIC4uLnJ0aSB9LFxuICAgICAgICAgICAgICAgIHN1YkluZm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENlbGxFbGVtZW50Pih7XG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmhhc0ZvY3VzXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+ID0ge1xuICAgICAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7IGdldEN1cnJlbnRDb2x1bW4gfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0LFxuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50Pj4ocHJvcHM6IFApIHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VHcmlkTmF2aWdhdGlvbkNvbHVtblByb3BzKHVzZUhhc0ZvY3VzUHJvcHMocHJvcHMpKSk7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4gPSB7XG4gICAgICAgICAgICBhc1BhcmVudE9mQ2VsbHM6IHtcbiAgICAgICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcm93THNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcm93THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNDaGlsZFJvdzogcm93THNDaGlsZFJldHVyblR5cGUsXG5cbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICByZXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBncmlkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgZ2V0Q3VycmVudENvbHVtbixcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW5cbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRMc1JldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudExzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH0gZnJvbSBcIi4vdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5leHBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnMgPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8XCJpZFwiPjtcbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSYW5kb21JZFByb3BzUGFyYW1ldGVycz4gPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGU8UCwgXCJpZFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFwicmVmZXJlbmNlclwiIHwgXCJzb3VyY2VcIiwgbmV2ZXI+IHtcbiAgICByYW5kb21JZDoge1xuICAgICAgICBwcmVmaXg/OiBzdHJpbmc7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUGFyYW1ldGVyczxLIGV4dGVuZHMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pj4gPSBQYXJ0aWFsPFJlY29yZDxLLCBhbnk+PjsvLzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7IH07XG5cblxuZXhwb3J0IHR5cGUgVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8YW55PiwgSyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gT21pdDxQLCBLPiAmIFJlY29yZDxLLCBzdHJpbmc+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIHt9LCBuZXZlcj4ge1xuICAgIHJhbmRvbUlkOiB7XG4gICAgICAgIHVzZWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGVXaXRoSG9va3M8UyBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmFuZG9tSWRSZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ7XG59XG5cbmludGVyZmFjZSBSYW5kb21JZENoaWxkSW5mb0Jhc2Uge1xuICAgIHNldFVzZWRJZChpZDogc3RyaW5nKTogdm9pZDtcbiAgICAvL3NlbmRTb3VyY2VJZFRvUmVmZXJlbmNlckVsZW1lbnQoc291cmNlSWQ6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkU291cmNlRWxlbWVudFJldHVyblR5cGU8UyBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+KSA9PiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8UiBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj47XG59XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBob29rIHRoYXQgbW9kaWZpZXMgYSBzZXQgb2YgcHJvcHMgdG8gcHJvdmlkZSBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqIFxuICogSWYgeW91J2QgbGlrZSB0byB1c2UgdGhlIElEIGluIGEgcHJvcGVydHkgdGhhdCdzICpub3QqIG5hbWVkIGBpZGAgKGxpa2UgYGZvcmAgb3IgYGFyaWEtbGFiZWxsZWRieWAgb3Igd2hhdG5vdCksIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaXMgYWxzbyBwcm92aWRlZC5cbiAqIFxuICogQW5kIHRoZSByYW5kb21seS1nZW5lcmF0ZWQgaWQgaXRzZWxmIGlzIGFsc28gcHJvdmlkZWQgaW4gY2FzZSB5b3Ugd2FudCB0byBoYW5kbGUgdGhlIGxvZ2ljIHlvdXJzZWxmIHdpdGhvdXQgYHVzZU1lcmdlZFByb3BzYC5cbiAqIFxuICogVW5saWtlIG1vc3Qgb3RoZXIgYHVzZSpQcm9wc2AgaG9va3MsIHRoZXNlIGFyZSBtb3N0bHkgc3RhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tSWQ8UyBleHRlbmRzIEVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZVJhbmRvbUlkUGFyYW1ldGVycyk6IFVzZVJhbmRvbUlkUmV0dXJuVHlwZVdpdGhIb29rczxTPiB7XG4gICAgY29uc3QgW2JhY2t1cFJhbmRvbUlkLCAsIGdldEJhY2t1cFJhbmRvbUlkXSA9IHVzZVN0YXRlPHN0cmluZz4oKCkgPT4gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXgpKTtcbiAgICBjb25zdCBbdXNlZElkLCBzZXRVc2VkSWQsIGdldFVzZWRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KCgpID0+IGdldEJhY2t1cFJhbmRvbUlkKCkpO1xuICAgIGNvbnN0IG1pc21hdGNoRXJyb3JSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJhbmRvbUlkXCIsIHByZWZpeCk7XG5cbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgLi4ubWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPFwicmVmZXJlbmNlclwiIHwgXCJzb3VyY2VcIiwgUmFuZG9tSWRDaGlsZEluZm9CYXNlLCBuZXZlcj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9KTtcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50ID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50PFM+PigoKSA9PiB7XG4gICAgICAgIGNvbnN0IFt1c2VkSWRMb2NhbCwgc2V0VXNlZElkTG9jYWwsIGdldFVzZWRJZExvY2FsXSA9IHVzZVN0YXRlKGdldFVzZWRJZCgpKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8Uz4oKTtcbiAgICAgICAgLy8gRXZlcnkgdGltZSB0aGUgc291cmNlIGVsZW1lbnQgcmVuZGVycywgaW5zcGVjdCB0aGUgSUQgaXQgYWN0dWFsbHkgdXNlZFxuICAgICAgICAvLyAod2hldGhlciBpdCB3YXMgb3VycyBvciBub3QgaXNuJ3QgdXAgdG8gdXMsIGl0J3MgdXAgdG8gdGhlIGNvbXBvbmVudClcbiAgICAgICAgLy8gc28gdGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSByZWZlcmVuY2VyIGNvbXBvbmVudCBvZiBjaGFuZ2VzXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KFwicmVmZXJlbmNlclwiKSEuc3ViSW5mby5zZXRVc2VkSWQoZWxlbWVudC5pZCk7XG4gICAgICAgICAgICAgICAgc2V0VXNlZElkKGVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4OiBcInNvdXJjZVwiLCBzdWJJbmZvOiB7IHNldFVzZWRJZDogc2V0VXNlZElkTG9jYWwgfSB9IH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPltcInVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzXCJdPihmdW5jdGlvbiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz4pIHtcbiAgICAgICAgICAgIHAuaWQgfHw9IGJhY2t1cFJhbmRvbUlkO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyhwKTtcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZWRJZDogdXNlZElkTG9jYWwsXG4gICAgICAgICAgICBnZXRVc2VkSWQ6IGdldFVzZWRJZExvY2FsLFxuICAgICAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHNcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudD4oPFIgZXh0ZW5kcyBFbGVtZW50PihpZFByb3BOYW1lOiBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIC8vIFdoYXRldmVyIElEIHdhcyBtb3N0IHJlY2VudGx5IHVzZWQgYnkgdGhlIGFjdHVhbCBcImlkXCIgcHJvcCBvZiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgdXNlRW5zdXJlU3RhYmlsaXR5KGlkUHJvcE5hbWUpO1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4OiBcInJlZmVyZW5jZXJcIiwgc3ViSW5mbzogeyBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSB9KTtcblxuICAgICAgICBjb25zdCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPltcInVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wc1wiXT4oZnVuY3Rpb24gPFIgZXh0ZW5kcyBFbGVtZW50Pih7IFtpZFByb3BOYW1lXTogZ2l2ZW5JZCwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikge1xuICAgICAgICAgICAgaWYgKGdpdmVuSWQgJiYgdXNlZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdpdmVuSWQgIT0gdXNlZElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWlzbWF0Y2hFcnJvclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNtYXRjaEVycm9yUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgbWlzLW1hdGNoZWQgSURzIHdlcmUgcHJvdmlkZWQgZm9yIHRoZSAke2lkUHJvcE5hbWV9IHByb3A6IHRoZSBjaGlsZCBleHBsaWNpdGx5IHNwZWNpZmllZCAke2dpdmVuSWR9IGluIGl0cyAgJHtpZFByb3BOYW1lfSBwcm9wLCBidXQgdGhlIHBhcmVudCB0b2xkIHRoaXMgY2hpbGQgdG8gdXNlICR7dXNlZElkfSAodGhlIHBhcmVudCdzIElEKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxSPihwLCB7IFtpZFByb3BOYW1lXTogdXNlZElkIH0pO1xuICAgICAgICB9LCBbdXNlZElkXSk7XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlZElkOiB1c2VkSWRMb2NhbCxcbiAgICAgICAgICAgIGdldFVzZWRJZDogZ2V0VXNlZElkTG9jYWwsXG4gICAgICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHNcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmRvbUlkOiB7XG4gICAgICAgICAgICB1c2VkSWQsXG4gICAgICAgICAgICBnZXRVc2VkSWRcbiAgICAgICAgfSxcbiAgICAgICAgLi4ubWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSxcbiAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LFxuICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCBFbmhhbmNlZEV2ZW50LCBlbmhhbmNlRXZlbnQgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5cbmV4cG9ydCB0eXBlIEJ1dHRvblByZXNzRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQgfCBFdmVudCwgeyBwcmVzc2VkOiBib29sZWFuIHwgbnVsbCB9PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VCdXR0b25QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBOb2RlPiB7XG4gICAgYnV0dG9uOiB7XG4gICAgICAgIHRhZ0J1dHRvbjogRWxlbWVudFRvVGFnPEU+O1xuICAgICAgICBkaXNhYmxlZD86IGJvb2xlYW4gfCBcInNvZnRcIiB8IFwiaGFyZFwiO1xuICAgICAgICBwcmVzc2VkPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgICAgIG9uUHJlc3M/KGV2ZW50OiBCdXR0b25QcmVzc0V2ZW50PEU+KTogdm9pZDtcbiAgICB9XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VCdXR0b25SZXR1cm5UeXBlPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlQnV0dG9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbjxFIGV4dGVuZHMgTm9kZT4oeyBidXR0b246IHsgdGFnQnV0dG9uLCBkaXNhYmxlZCwgb25QcmVzcywgcHJlc3NlZCB9LCBoYXNGb2N1cyB9OiBVc2VCdXR0b25QYXJhbWV0ZXJzPEU+KTogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPiB7XG4gICAgZGVidWdMb2coXCJ1c2VCdXR0b25cIik7XG5cbiAgICBmdW5jdGlvbiB1c2VCdXR0b25Qcm9wcyh7IFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkLCB0YWJJbmRleCwgcm9sZSwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcblxuICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8RT4oe1xuICAgICAgICAgICAgb25DbGlja1N5bmM6IChlKSA9PiAoZGlzYWJsZWQgPyBudWxsIDogb25QcmVzcyk/LihlbmhhbmNlRXZlbnQoZSwgeyBwcmVzc2VkOiBwcmVzc2VkID09IG51bGwgPyBudWxsIDogIXByZXNzZWQgfSkpLFxuICAgICAgICAgICAgZXhjbHVkZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGFzRm9jdXNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdXNlUHJlc3NQcm9wcyhwKTtcblxuICAgICAgICBjb25zdCBiYXNlUHJvcHMgPSB7IHJvbGUsIHRhYkluZGV4LCBcImFyaWEtcHJlc3NlZFwiOiBhcmlhUHJlc3NlZCA/PyAocHJlc3NlZCA9PT0gdHJ1ZSA/IFwidHJ1ZVwiIDogcHJlc3NlZCA9PT0gZmFsc2UgPyBcImZhbHNlXCIgOiB1bmRlZmluZWQpIH07XG4gICAgICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyAuLi5iYXNlUHJvcHMsIGRpc2FibGVkOiAoZGlzYWJsZWQgJiYgZGlzYWJsZWQgIT0gXCJzb2Z0XCIpID8gdHJ1ZSA6IGZhbHNlLCBcImFyaWEtZGlzYWJsZWRcIjogKGRpc2FibGVkID09PSAnc29mdCcgPyAndHJ1ZScgOiB1bmRlZmluZWQpIH07XG4gICAgICAgIGNvbnN0IGRpdlByb3BzID0geyAuLi5iYXNlUHJvcHMsIHRhYkluZGV4OiB0YWJJbmRleCA/PyAoZGlzYWJsZWQgPT09IFwiaGFyZFwiID8gLTEgOiAwKSwgcm9sZTogcm9sZSA/PyBcImJ1dHRvblwiLCBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9O1xuICAgICAgICBzd2l0Y2ggKHRhZ0J1dHRvbikge1xuICAgICAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihidXR0b25Qcm9wcywgcHJvcHMpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihkaXZQcm9wcywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQnV0dG9uUHJvcHNcbiAgICB9XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmV0dXJuVHJ1ZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUJ1dHRvbiwgVXNlQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcblxuZXhwb3J0IHR5cGUgVXNlQWNjb3JkaW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFjY29yZGlvblBhcmFtZXRlcnMpID0+IFVzZUFjY29yZGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xuZXhwb3J0IHR5cGUgVXNlQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PikgPT4gVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIG5ldmVyPiB7XG4gICAgYWNjb3JkaW9uOiB7IGluaXRpYWxJbmRleD86IG51bWJlciB8IG51bGw7IH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCI+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGFjY29yZGlvbjogeyBjaGFuZ2VFeHBhbmRlZEluZGV4OiAoYXJnOiBudW1iZXIgfCAoKHByZXZTdGF0ZTogbnVtYmVyIHwgbnVsbCkgPT4gbnVtYmVyIHwgbnVsbCkgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsOyB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFjY29yZGlvblJldHVyblR5cGVJbmZvIHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUFjY29yZGlvblNlY3Rpb246IFVzZUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSB7XG4gICAgc2V0T3BlbkZyb21QYXJlbnQob3BlbjogYm9vbGVhbik6IHZvaWQ7XG4gICAgZ2V0T3BlbkZyb21QYXJlbnQoKTogYm9vbGVhbiB8IG51bGw7XG4gICAgZm9jdXMoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIG1hbmFnZWRDaGlsZHJlbjogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSwgXCJ0YWJiZWRcIiB8IFwib3BlblwiLCBcInN1YkluZm9cIiB8IFwiZmxhZ3NcIj5bXCJtYW5hZ2VkQ2hpbGRcIl07XG4gICAgYWNjb3JkaW9uU2VjdGlvbjogeyBvcGVuPzogYm9vbGVhbiB8IHVuZGVmaW5lZDsgfVxuICAgIGJ1dHRvbjogT21pdDxVc2VCdXR0b25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+W1wiYnV0dG9uXCJdLCBcInByZXNzZWRcIiB8IFwib25QcmVzc1wiPjtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgYWNjb3JkaW9uU2VjdGlvbjoge1xuICAgICAgICBleHBhbmRlZDogYm9vbGVhbjtcbiAgICAgICAgZm9jdXNlZDogYm9vbGVhbjtcbiAgICAgICAgaGVhZGVySWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgYm9keUlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIGdldEhlYWRlcklkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgZ2V0Qm9keUlkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PjtcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xuICAgIHVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47XG59XG5cblxuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VCdXR0b25QYXJhbWV0ZXJzPEU+KSA9PiBVc2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUmV0dXJuVHlwZTxFPjtcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4geyB1c2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9XG4vL2V4cG9ydCB0eXBlIFVzZUFjY29yZGlvblNlY3Rpb25Cb2R5PEUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IFVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UmV0dXJuVHlwZTxFPjtcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uQm9keVJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHsgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjY29yZGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50Pih7IGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXggfSwgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfTogVXNlQWNjb3JkaW9uUGFyYW1ldGVycyk6IFVzZUFjY29yZGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZUFjY29yZGlhblwiKTtcbiAgICBjb25zdCBbX2N1cnJlbnRGb2N1c2VkSW5kZXgsIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgsIGdldEN1cnJlbnRGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mb0Jhc2UsIFwidGFiYmVkXCIgfCBcIm9wZW5cIj4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtLCB1KSA9PiB7IG9jbWMyKCk7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG0sIHUpOyB9KSxcbiAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0gfSA9IG1jUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoMCk7IH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkpOyB9LCBbXSk7XG4gICAgY29uc3QgbmF2aWdhdGVUb1ByZXYgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGkgPT4gKChpID8/IDApIC0gMSkpIH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaSA9PiAoKGkgPz8gMCkgKyAxKSkgfSwgW10pO1xuICAgIGNvbnN0IGxpbmVhclJldHVyblR5cGUgPSB1c2VMaW5lYXJOYXZpZ2F0aW9uPEhlYWRlckVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0LFxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QsXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2LFxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb246IG5hdmlnYXRpb25EaXJlY3Rpb24gPz8gXCJ2ZXJ0aWNhbFwiICAvLyBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UncyBsb2dpY2FsIGRpcmVjdGlvblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gbGluZWFyUmV0dXJuVHlwZTtcblxuXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlRXhwYW5kZWRJbmRleCwgZ2V0Q3VycmVudEluZGV4OiBfZ2V0Q3VycmVudEV4cGFuZGVkSW5kZXggfSA9IHVzZUNoaWxkcmVuRmxhZyh7XG4gICAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGtleTogXCJvcGVuXCIsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGNoYW5nZUluZGV4OiBjaGFuZ2VUYWJiZWRJbmRleCwgZ2V0Q3VycmVudEluZGV4OiBfZ2V0VGFiYmVkSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiBvY21jMiB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAga2V5OiBcInRhYmJlZFwiLFxuICAgICAgICBjbG9zZXN0Rml0OiB0cnVlLFxuICAgICAgICBvbkluZGV4Q2hhbmdlOiB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGkpPy5zdWJJbmZvLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pXG5cbiAgICBjb25zdCB1c2VBY2NvcmRpb25TZWN0aW9uOiBVc2VBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PiA9IHVzZUNhbGxiYWNrPFVzZUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+PigoeyBidXR0b246IHsgZGlzYWJsZWQsIHRhZ0J1dHRvbiB9LCBhY2NvcmRpb25TZWN0aW9uOiB7IG9wZW46IG9wZW5Gcm9tVXNlciB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXggfSwgaGFzRm9jdXM6IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9IH0pID0+IHtcblxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFjY29yZGlhblNlY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IFtvcGVuRnJvbVBhcmVudCwgc2V0T3BlbkZyb21QYXJlbnQsIGdldE9wZW5Gcm9tUGFyZW50XSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihudWxsKTtcblxuXG5cbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUJvZHlBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBib2R5SWQsIGdldFVzZWRJZDogZ2V0Qm9keUlkIH0gfSA9IHVzZVJhbmRvbUlkPEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWJvZHktXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VIZWFkZXJBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VCb2R5QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaGVhZGVySWQsIGdldFVzZWRJZDogZ2V0SGVhZGVySWQgfSB9ID0gdXNlUmFuZG9tSWQ8SGVhZGVyRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1oZWFkZXItXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUJvZHlBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUJvZHlBc1NvdXJjZUlkKCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlQm9keUFzUmVmZXJlbmNlcklkPEJvZHlFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiIGFzIG5ldmVyKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlSGVhZGVyQXNTb3VyY2VJZFByb3BzIH0gPSB1c2VIZWFkZXJBc1NvdXJjZUlkKCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzIH0gPSB1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZDxIZWFkZXJFbGVtZW50PihcImFyaWEtY29udHJvbHNcIiBhcyBuZXZlcik7XG5cbiAgICAgICAgY29uc3Qgb3BlbiA9ICgob3BlbkZyb21Vc2VyID8/IG9wZW5Gcm9tUGFyZW50KSA/PyBmYWxzZSk7XG4gICAgICAgIC8vY29uc3QgZ2V0T3BlbiA9IHVzZVN0YWJsZUdldHRlcighIW9wZW4pO1xuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG5cbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRIZWFkZXJFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUhlYWRlclJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxIZWFkZXJFbGVtZW50Pih7fSk7XG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0Qm9keUVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlQm9keVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxCb2R5RWxlbWVudD4oe30pO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAoZ2V0SGVhZGVyRWxlbWVudCgpIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQpPy5mb2N1cygpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGNvbnN0IG9wZW5SZWYgPSB1c2VSZWYoe1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldE9wZW5Gcm9tUGFyZW50KCksXG4gICAgICAgICAgICBzZXQ6IChvcGVuOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0T3BlbkZyb21QYXJlbnQob3Blbik7XG5cbiAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5RWxlbWVudCA9IGdldEJvZHlFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgoZ2V0SW5kZXgoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gYm9keUVsZW1lbnQuZm9jdXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWYWxpZDogcmV0dXJuVHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGFiYmVkUmVmID0gdXNlUmVmKHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBnZXRJbmRleCgpKSxcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3BlbilcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiByZXR1cm5UcnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgb3Blbjogb3BlblJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB0YWJiZWQ6IHRhYmJlZFJlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWJJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBnZXRPcGVuRnJvbVBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgc2V0T3BlbkZyb21QYXJlbnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGluZm86IHsgaW5kZXgsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudCwgZm9jdXMsIGZsYWdzOiB7IG9wZW46IG9wZW5SZWYuY3VycmVudCwgdGFiYmVkOiB0YWJiZWRSZWYuY3VycmVudCB9IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4ge1xuXG4gICAgICAgICAgICAvL2NvbnN0IG9uRm9jdXMgPSAoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGluZGV4KTsgfVxuICAgICAgICAgICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0T3BlbkZyb21QYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChudWxsKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3QgeyB1c2VCdXR0b25Qcm9wcyB9ID0gdXNlQnV0dG9uPEhlYWRlckVsZW1lbnQ+KHtcbiAgICAgICAgICAgICAgICBidXR0b246IHsgdGFnQnV0dG9uLCBkaXNhYmxlZCwgb25QcmVzcyB9LCBoYXNGb2N1czoge1xuICAgICAgICAgICAgICAgICAgICAuLi5oYXNGb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXRCID0gdXNlQnV0dG9uUHJvcHMocHJvcHMpO1xuXG5cblxuXG4gICAgICAgICAgICAvL2NvbnN0IHJldDM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+XG4gICAgICAgICAgICAvLyAgICA9IHVzZU1lcmdlZFByb3BzPEhlYWRlckVsZW1lbnQ+KHJldEQsIHsgb25Gb2N1cyB9KTtcblxuXG4gICAgICAgICAgICByZXR1cm4gdXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyh1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzKHtcbiAgICAgICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGFyaWFFeHBhbmRlZCA/PyBvcGVuID8/IGZhbHNlKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgICAgICAuLi51c2VIZWFkZXJSZWZFbGVtZW50UHJvcHMocmV0QilcbiAgICAgICAgICAgIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMoeyByb2xlLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4ge1xuICAgICAgICAgICAgY29uc3QgcmV0MSA9IHVzZUJvZHlBc1JlZmVyZW5jZXJJZFByb3BzKHsgcm9sZTogcm9sZSA/PyBcInJlZ2lvblwiLCAuLi5wcm9wcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJldDIgPSB1c2VCb2R5QXNTb3VyY2VJZFByb3BzKHJldDEpO1xuICAgICAgICAgICAgcmV0Mi50YWJJbmRleCA/Pz0gLTE7XG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keVJlZkVsZW1lbnRQcm9wcyhyZXQyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvcmRpb25TZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWQ6IG9wZW4sXG4gICAgICAgICAgICAgICAgZm9jdXNlZDogKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBpbmRleCksXG4gICAgICAgICAgICAgICAgYm9keUlkLFxuICAgICAgICAgICAgICAgIGhlYWRlcklkLFxuICAgICAgICAgICAgICAgIGdldEJvZHlJZCxcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJJZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyxcbiAgICAgICAgICAgIHVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMsXG5cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgYWNjb3JkaW9uOiB7IGNoYW5nZUV4cGFuZGVkSW5kZXggfSxcbiAgICAgICAgdXNlQWNjb3JkaW9uU2VjdGlvbixcbiAgICB9XG59XG5cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuaW50ZXJmYWNlIFVMSTxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcHJlZml4TGFiZWw6IHN0cmluZztcbiAgICBwcmVmaXhJbnB1dDogc3RyaW5nO1xuICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8SW5wdXRFbGVtZW50PjtcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIExhYmVsT21pdHMgPSBrZXlvZiBVTEk8YW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMT21pdHMgZXh0ZW5kcyBMYWJlbE9taXRzPiB7XG4gICAgbGFiZWw6IE9taXQ8VUxJPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgTE9taXRzPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xuICAgIGxhYmVsOiB7XG4gICAgICAgIGxhYmVsSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgaW5wdXRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAvKiogKipTdGFibGUqKiAqL1xuICAgICAgICBnZXRMYWJlbElkOiAoKSA9PiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIC8qKiAqKlN0YWJsZSoqICovXG4gICAgICAgIGdldElucHV0SWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGFiZWxSZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUxhYmVsSW5wdXQ6ICgpID0+IHsgdXNlTGFiZWxJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47IH07XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUxhYmVsTGFiZWw6ICgpID0+IHsgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH07XG59XG5cbi8qKlxuICogQWRkcyBhbiBJRCBhbmQgXCJhcmlhLWxhYmVsbGVkYnlcIiBmb3IgdHdvIGVsZW1lbnRzLCBhbiBcImlucHV0XCIgZWxlbWVudCBhbmQgYSBcImxhYmVsXCIgZWxlbWVudC5cbiAqIFxuICogUmV0dXJucyB0aGUgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBob29rcyBpZiB5b3UgbmVlZCB0byBhbHNvIGFkZCBvdGhlciBJRC1yZWZlcmVuY2VyIGF0dHJpYnV0ZXMsIGxpa2UgYGZvcmBcbiAqIFxuICogQHNlZSB1c2VJbnB1dExhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYWJlbDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsOiB7IHByZWZpeElucHV0LCBwcmVmaXhMYWJlbCwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfTogVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBuZXZlcj4pOiBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VMYWJlbEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogbGFiZWxJZCwgZ2V0VXNlZElkOiBnZXRMYWJlbElkIH0gfSA9IHVzZVJhbmRvbUlkPExhYmVsRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeExhYmVsIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VJbnB1dEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUlucHV0QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaW5wdXRJZCwgZ2V0VXNlZElkOiBnZXRJbnB1dElkIH0gfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeElucHV0IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNTb3VyY2VJZFByb3BzIH0gPSB1c2VMYWJlbEFzU291cmNlSWQoKTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VJbnB1dEFzU291cmNlSWRQcm9wcyB9ID0gdXNlSW5wdXRBc1NvdXJjZUlkKCk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZDxJbnB1dEVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUlucHV0QXNSZWZlcmVuY2VySWQ8TGFiZWxFbGVtZW50PihcImZvclwiKTtcblxuICAgIGNvbnN0IGlzU3ludGhldGljTGFiZWwgPSAodGFnSW5wdXQgIT0gXCJpbnB1dFwiIHx8IHRhZ0xhYmVsICE9IFwibGFiZWxcIik7XG5cbiAgICBjb25zdCB1c2VMYWJlbExhYmVsOiAoKCkgPT4geyB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfSkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbExhYmVsKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRGb3IgPSB1c2VMYWJlbEFzU291cmNlSWRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRoRm9yID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEZvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ0xhYmVsID09IFwibGFiZWxcIiAmJiB0YWdJbnB1dCA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhGb3I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRob3V0Rm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2lzU3ludGhldGljTGFiZWxdKTtcblxuICAgIGNvbnN0IHVzZUxhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbElucHV0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGFiZWxJbnB1dFByb3BzOiAoeyBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFhcmlhTGFiZWxsZWRieSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSA9IHVzZUlucHV0QXNTb3VyY2VJZFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeSA9IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyhwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3ludGhldGljTGFiZWwgJiYgIXByb3BzW1wiYXJpYS1sYWJlbFwiXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbaXNTeW50aGV0aWNMYWJlbF0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMYWJlbElucHV0LFxuICAgICAgICB1c2VMYWJlbExhYmVsLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgICAgIGlucHV0SWQsXG4gICAgICAgICAgICBnZXRMYWJlbElkLFxuICAgICAgICAgICAgZ2V0SW5wdXRJZFxuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuXG5cbmV4cG9ydCB0eXBlIENoZWNrYm94Q2hlY2tlZFR5cGUgPSBib29sZWFuIHwgXCJtaXhlZFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGxhYmVsOiBVc2VMYWJlbFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGUsIFwicHJlZml4TGFiZWxcIiB8IFwicHJlZml4SW5wdXRcIj5bXCJsYWJlbFwiXTtcbiAgICBjaGVja2JveExpa2U6IHtcbiAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiO1xuICAgICAgICAvKiogVGhlIHJvbGUgYXR0cmlidXRlIHRvIHVzZSwgd2hlbiBhcHBsaWNhYmxlICovXG4gICAgICAgIHJvbGU6IHN0cmluZztcbiAgICAgICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgICAgIGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGU7XG4gICAgICAgIG9uQ2hlY2tlZENoYW5nZT8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik6IHZvaWQ7XG4gICAgICAgIC8vb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8TGFiZWxUeXBlPik6IHZvaWQ7XG4gICAgfVxuICAgIGhhc0ZvY3VzSW5wdXQ6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJbnB1dFR5cGU+O1xuICAgIGhhc0ZvY3VzTGFiZWw6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxMYWJlbFR5cGU+O1xufVxuXG5jb25zdCBoYW5kbGVzSW5wdXQgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KHRhZzogRWxlbWVudFRvVGFnPEU+LCBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCIsIHdoaWNoOiBcImlucHV0LWVsZW1lbnRcIiB8IFwibGFiZWwtZWxlbWVudFwiKSA9PiB7XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgICBpZiAod2hpY2ggPT09IFwiaW5wdXQtZWxlbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHdoaWNoID09PSBcImxhYmVsLWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiB0YWcgIT0gXCJpbnB1dFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSBcIndyYXBwaW5nXCIpIHtcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHdoaWNoID09IFwibGFiZWwtZWxlbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4ge1xuICAgIGdldElucHV0RWxlbWVudDogKCkgPT4gSW5wdXRUeXBlIHwgbnVsbDtcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xuICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQ8TGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xuICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRMYWJlbEVsZW1lbnQ6ICgpID0+IExhYmVsVHlwZSB8IG51bGw7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldElucHV0RWxlbWVudDogKCkgPT4gSW5wdXRUeXBlIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT47XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDogKCkgPT4geyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjsgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGxhYmVsIHR5cGUgKHdyYXBwaW5nIG9yIHNlcGFyYXRlKSBmb3IgY2hlY2tib3hlcywgcmFkaW9zLCBzd2l0Y2hlcywgZXRjLlxuICogXG4gKiBJZiBpdCdzIGEgdG9nZ2xlYWJsZSBjbGljay10aGluZyB3aXRoIGEgbGFiZWwgKHRoYXQgY2FuIGFsc28gYmUgY2xpY2tlZCksIHRoZW4gaXQncyBhIGNoZWNrYm94LWxpa2UuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveExpa2U8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIHJvbGUsIG9uQ2hlY2tlZENoYW5nZSB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSwgaGFzRm9jdXNJbnB1dCwgaGFzRm9jdXNMYWJlbCB9OiBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPik6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRUeXBlLCBMYWJlbFR5cGU+IHtcblxuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGU+IHwgaC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbFR5cGU+KSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25DaGVja2VkQ2hhbmdlPy4oZSBhcyBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VJTElucHV0LCB1c2VMYWJlbExhYmVsOiB1c2VJTExhYmVsLCBsYWJlbCB9ID0gdXNlTGFiZWw8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHsgbGFiZWw6IHsgcHJlZml4TGFiZWw6IFwiYXJpYS1jaGVja2JveC1sYWJlbC1cIiwgcHJlZml4SW5wdXQ6IFwiYXJpYS1jaGVja2JveC1pbnB1dC1cIiwgdGFnSW5wdXQ6IHRhZ0lucHV0LCB0YWdMYWJlbDogdGFnTGFiZWwgfSB9KTtcblxuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRMYWJlbEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTGFiZWxSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8TGFiZWxUeXBlPigpO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SW5wdXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUlucHV0UmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PElucHV0VHlwZT4oKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnSW5wdXQ7XG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzOiB1c2VJTElucHV0UHJvcHMgfSA9IHVzZUlMSW5wdXQoKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRUeXBlPih7fSk7XG5cbiAgICAgICAgLy8gb25DbGljayBhbmQgb25DaGFuZ2UgYXJlIGEgYml0IG1lc3N5LCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vICphbHdheXMqIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aXNpYmxlIHN0YXRlIGlzIGNvcnJlY3RcbiAgICAgICAgLy8gYWZ0ZXIgYWxsIHRoZSBldmVudCBkdXN0IHNldHRsZXMuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8yNzQ1LFxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTg5OSNpc3N1ZWNvbW1lbnQtNTI1NjkwMTk0XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFnID09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuaW5kZXRlcm1pbmF0ZSA9IChjaGVja2VkID09PSBcIm1peGVkXCIpO1xuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGFnLCBjaGVja2VkXSlcblxuICAgICAgICByZXR1cm4geyBnZXRJbnB1dEVsZW1lbnQ6IGdldEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH07XG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+IHtcblxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBDaHJvbWUgd29uJ3QgZmlyZSBvbklucHV0IGV2ZW50cyBmb3IgcmFkaW8gYnV0dG9ucyB0aGF0IGFyZSB0YWJJbmRleD0tMT8/XG4gICAgICAgICAgICAvLyBOZWVkcyBpbnZlc3RpZ2F0aW5nLCBidXQgb25JbnB1dCB3b3JrcyBmaW5lIGluIEZpcmVmb3hcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxJbnB1dFR5cGU+KHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYzogZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwiaW5wdXQtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsXG4gICAgICAgICAgICAgICAgZXhjbHVkZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhhc0ZvY3VzOiBoYXNGb2N1c0lucHV0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiA9IHVzZVByZXNzUHJvcHMocDApO1xuXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICBwcm9wcy5vbklucHV0ID0gKGU6IEV2ZW50KSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHByb3BzID0gdXNlUmVmRWxlbWVudFByb3BzKHVzZUlMSW5wdXRQcm9wcyhwcm9wcykpO1xuXG5cbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIHdyYXBwZWQgbGFiZWwgaGFuZGxlcyBhbGwgaW50ZXJhY3Rpb25zLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgZWxlbWVudCBjYW4ndCBiZSBpbnRlcmFjdGVkIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0J3MgYW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBwcm9wcy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtaGlkZGVuXCJdID0gXCJ0cnVlXCI7XG4gICAgICAgICAgICAgICAgcHJvcHMub25Gb2N1cyA9IF8gPT4gKGdldExhYmVsRWxlbWVudCgpIGFzIEhUTUxFbGVtZW50IHwgbnVsbCk/LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZCA9PT0gXCJtaXhlZFwiID8gXCJtaXhlZFwiIDogY2hlY2tlZCA9PT0gdHJ1ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBwcm9wcy5vbkNsaWNrO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlSW5wdXRSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8SW5wdXRUeXBlPihwMCwgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH0sIFt1c2VJTElucHV0LCByb2xlLCBsYWJlbFBvc2l0aW9uLCBkaXNhYmxlZCwgY2hlY2tlZCwgdGFnSW5wdXRdKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdMYWJlbDtcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHM6IHVzZUlMTGFiZWxQcm9wcyB9ID0gdXNlSUxMYWJlbCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4ge1xuXG4gICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8TGFiZWxUeXBlPih7XG4gICAgICAgICAgICAgICAgb25DbGlja1N5bmM6IGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoYXNGb2N1czogaGFzRm9jdXNMYWJlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiA9IHVzZVByZXNzUHJvcHMocDApO1xuXG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3UHJvcHMudGFiSW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChuZXdQcm9wcy5yb2xlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnJvbGUgPSByb2xlO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGNhc2Ugd2hlcmUgdGhlcmUncyBhbG1vc3Qgbm90aGluZyB0byBkb1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IG5vcm1hbCBjYXNlIHdoZXJlIGV2ZXJ5dGhpbmcgYWN0cyBhY2NvcmRpbmcgbm9ybWFsIEhUTUwgbWVjaGFuaWNzLlxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEp1c3QgbWFrZSBzdXJlIHRoYXQgbGFiZWwgY2xpY2tzIGNhbid0IGFmZmVjdCB0aGUgY2hlY2tib3ggd2hpbGUgaXQncyBkaXNhYmxlZFxuICAgICAgICAgICAgbmV3UHJvcHMub25DbGljayA9IGRpc2FibGVkID8gKChlKSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9KSA6IG5ld1Byb3BzLm9uQ2xpY2s7XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VJTExhYmVsUHJvcHModXNlTGFiZWxSZWZFbGVtZW50UHJvcHMobmV3UHJvcHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH07XG5cbiAgICB9LCBbdXNlSUxMYWJlbCwgZGlzYWJsZWQsIGNoZWNrZWQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIHRhZ0xhYmVsXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCxcbiAgICAgICAgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50LFxuICAgICAgICBjaGVja2JveExpa2U6IHtcbiAgICAgICAgICAgIGdldExhYmVsRWxlbWVudCxcbiAgICAgICAgICAgIGdldElucHV0RWxlbWVudCxcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxcbiAgICB9O1xuXG5cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbywgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgQ2hlY2tib3hDaGVja2VkVHlwZSB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgQ2hlY2tib3hDaGFuZ2VFdmVudCwgdXNlQ2hlY2tib3gsIFVzZUNoZWNrYm94UGFyYW1ldGVycywgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGVja2JveFwiO1xuXG5leHBvcnQgdHlwZSBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgY2hpbGRyZW5DaGVja2VkOiBib29sZWFuIHwgTWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBhcmVudCBjaGVja2JveCBpcyBjaGFuZ2VkIGFuZCBhbiB1cGRhdGUgb2ZcbiAgICAgKiBhbGwgdGhlIGNoaWxkcmVuIG5lZWRzIHRvIG9jY3VyLlxuICAgICAqIFxuICAgICAqIGBldmVudFtFdmVudERldGFpbF0uY2hpbGRyZW5DaGVja2VkYCB3aWxsIGJlIFxuICAgICAqICogdHJ1ZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSBjaGVja2VkXG4gICAgICogKiBmYWxzZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSB1bmNoZWNrZWRcbiAgICAgKiAqIEEgYE1hcDxpbmRleCxjaGVja2VkPmAgb2YgZWFjaCBjaGlsZCdzIHN0YXR1cyB3aGVuIHJldmVydGluZyB0byBcIm1peGVkXCIuXG4gICAgICogXG4gICAgICogQmVjYXVzZSB3ZSdyZSBkZWFsaW5nIHdpdGggY29udHJvbGxlZCBjb21wb25lbnRzIGhlcmUsIGFuZCB0aGUgZGF0YSBmb3JcbiAgICAgKiB3aGF0IGNoZWNrYm94ZXMgYXJlIGNoZWNrZWQgbGl2ZSAqb3V0c2lkZSogb2YgYW55IG9mIHRoZXNlIGhvb2tzLFxuICAgICAqIGl0J3MgeW91IHdobydzIHJlc3BvbnNpYmxlIGZvciBsaXN0ZW5pbmcgZm9yIHRoaXMgZXZlbnQsIG1vZGlmeWluZyB0aGVcbiAgICAgKiBkYXRhLCBhbmQgcmUtcmVuZGVyaW5nIGFwcHJvcHJpYXRlbHkuXG4gICAgICogXG4gICAgICogSGlnaGx5IHJlY29tbWVuZGVkIHRvLCBmb3IgZXhhbXBsZSwgYWRkIGVhY2ggY2hpbGQncyBgb25JbnB1dGAgZXZlbnQgaGFuZGxlclxuICAgICAqIGF2YWlsYWJsZSBpbiB0aGUgY2hpbGQgaW5mbyB0aGUgcGFyZW50IGdldHMgc28gaXQgY2FuIGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgKiByZW1vdGVseSBmcm9tIGBtYW5hZ2VkQ2hlY2tib3hlc2AuXG4gICAgICogQHBhcmFtIGV2ZW50IFxuICAgICAqL1xuICAgIC8vY2hlY2tib3hHcm91cDoge31cbiAgICAvL29uVXBkYXRlQ2hpbGRyZW4oZXZlbnQ6IENoZWNrYm94R3JvdXBDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+Pik6IHZvaWQ7XG59XG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7XG4vKipcbiAqIFRoZSBpZCBhdHRyaWJ1dGUgdXNlZCBmb3IgdGhlIGNoaWxkLlxuICovXG4vL2lkOiBzdHJpbmc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgY2hlY2tlZCBzdGF0ZSBvZiB0aGlzIGNoaWxkLlxuICogXG4gKiBUaGlzIGlzIHVzZWQgYnkgdGhlIHBhcmVudCB3aGVuZXZlciBpdCdzIGludGVyYWN0ZWQgd2l0aCBcbiAqIGFuZCBhYm91dCB0byBmb3JjZSBldmVyeSBvbmUgdG8gYmUgc29tZXRoaW5nIGRpZmZlcmVudCAtLSBcbiAqIGl0IHdpbGwgc2F2ZSB0aGUgc3RhdGUgb2YgYWxsIGNoaWxkIGNoZWNrYm94ZXMgZm9yIGxhdGVyXG4gKiBieSBhc2tpbmcgZWFjaCBvbmUgd2hhdCBpdHMgY3VycmVudCBzdGF0ZSBpcyBpbmRpdmlkdWFsbHlcbiAqIGF0IHRoYXQgbW9tZW50LlxuICogXG4gKiBBbGwgdGhlIGNoZWNrYm94J3Mgc3RhdGVzIGFyZSBjYXB0dXJlZCB3aGVuIHRoZSBwYXJlbnRcbiAqIGlzIGluIHRoZSBcIm1peGVkXCIgc3RhdGUgYW5kIGlzIGNsaWNrZWQuIEl0IGtlZXBzIHRoZW1cbiAqIHRoYXQgd2F5IHVudGlsIHRoZSBzYW1lIGNvbmRpdGlvbnMgYXJpc2UgYWdhaW4uXG4gKi9cbi8vICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuLy8gICAgb25JbnB1dDogVXNlQ2hlY2tib3hQYXJhbWV0ZXJzPGFueSwgYW55PltcIm9uSW5wdXRcIl07XG4vL31cblxuZXhwb3J0IGludGVyZmFjZSBDQkcge1xuICAgIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCI7XG4gICAgZ2V0TGFzdFVzZXJDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XG4gICAgb25DaGVja2VkQ2hhbmdlOiBVc2VDaGVja2JveFBhcmFtZXRlcnM8YW55LCBhbnk+W1wiY2hlY2tib3hcIl1bXCJvbkNoZWNrZWRDaGFuZ2VcIl07XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBhc0NoZWNrYm94OiBVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+O1xuICAgIGFzQ2hlY2tib3hHcm91cENoaWxkOiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q0JHLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wibWFuYWdlZENoaWxkXCJdO1xuICAgICAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQkcsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJsaXN0TmF2aWdhdGlvblwiXSwgXCJzdWJJbmZvXCI+O1xuICAgICAgICByb3ZpbmdUYWJJbmRleDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q0JHLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl07XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94UmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSA9PiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiAvKntcbiAgICAvL3RhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcbiAgICBjaGVja2JveExpa2U6IFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJjaGVja2JveExpa2VcIl07XG4gICAgbGFiZWw6IFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJsYWJlbFwiXTtcbiAgICByb3ZpbmdUYWJJbmRleDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8SW5wdXRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4XCJdO1xuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHM6ICh7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHM6ICh7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xufSovXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgQ0JHLCBuZXZlcj4ge1xuICAgIGNoZWNrYm94R3JvdXA6IHtcbiAgICAgICAgcGFyZW50SXNDaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgICAgICBwYXJlbnRQZXJjZW50Q2hlY2tlZDogbnVtYmVyO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcbiAgICAvKiogKipTVEFCTEUgKiogKi9cbiAgICAvL2NoZWNrYm94ZXM6IE1hbmFnZWRDaGlsZHJlbjxJPjtcbiAgICAvKipcbiAgICAgKiBFYWNoIGNoaWxkIGNoZWNrYm94IG11c3QgY2FsbCB0aGlzIGhvb2ssICppbiBhZGRpdGlvbiB0byogYHVzZUNoZWNrYm94YFxuICAgICAqL1xuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZDogVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNoZWNrYm94IG11c3QgdXNlIHRoaXMgaG9va1xuICAgICAqIFxuICAgICAqICoqTm90YWJseSB1bnN0YWJsZSEqKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBgYXJpYUNvbnRyb2xzYCwgcG9wdWxhdGVkIGJ5IGFsbCBjaGlsZCBjaGVja2JveGVzXG4gICAgICovXG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0OiBVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgY2hlY2tib3g6IE9taXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94XCJdLCBcIm9uQ2hlY2tlZENoYW5nZVwiPjtcbiAgICBsYWJlbDogVXNlQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImxhYmVsXCJdO1xuICAgIGhhc0ZvY3VzTGFiZWw6IFVzZUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJoYXNGb2N1c0xhYmVsXCJdO1xuICAgIGhhc0ZvY3VzSW5wdXQ6IFVzZUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJoYXNGb2N1c0lucHV0XCJdO1xuICAgIGNoZWNrYm94TGlrZTogT21pdDxVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wiY2hlY2tib3hMaWtlXCJdLCBcImNoZWNrZWRcIj47XG59XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYTogVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSA9PiB7XG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xufTtcblxuXG4vKipcbiAqIFxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbiwgcm92aW5nVGFiSW5kZXgsIHR5cGVhaGVhZE5hdmlnYXRpb24gfTogVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMpOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xuICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hHcm91cFwiKTtcbiAgICAvL2NvbnN0IG9uVXBkYXRlQ2hpbGRyZW4gPSB1c2VTdGFibGVDYWxsYmFjayhvblVwZGF0ZUNoaWxkcmVuVW5zdGFibGUgPz8gKCgpID0+IHt9KSk7XG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0UmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxJbnB1dEVsZW1lbnQsIElucHV0RWxlbWVudCwgQ0JHLCBuZXZlcj4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbGlzdFJldHVyblR5cGU7XG5cbiAgICAvL2NvbnN0IFt1bmNoZWNrZWRDb3VudCwgc2V0VW5oZWNrZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgY2hpbGQgSURzLCBhbmQgYW55IHRpbWUgYW55IG9mIHRoZW0gY2hhbmdlLCBcbiAgICAvLyBnZW5lcmF0ZSBhIG5ldyBzdHJpbmcgd2l0aCBhbGwgb2YgdGhlbSBjb25jYXRlbmF0ZWQgdG9nZXRoZXJcbiAgICAvLyAoYnV0IG9ubHkgb25jZSBwZXIgcmVuZGVyKTtcbiAgICBjb25zdCBhbGxJZHMgPSB1c2VSZWYobmV3IFNldDxzdHJpbmc+KCkpO1xuICAgIGNvbnN0IFthcmlhQ29udHJvbHMsIHNldENvbnRyb2xzXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFt1cGRhdGVJbmRleCwgc2V0SWRVcGRhdGVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcblxuXG4gICAgY29uc3QgW2NoZWNrZWRDb3VudCwgc2V0Q2hlY2tlZENvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGNoZWNrZWRJbmRpY2VzID0gdXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcbiAgICAvL2NvbnN0IFtzZWxmSXNDaGVja2VkLCBzZXRTZWxmSXNDaGVja2VkLCBnZXRTZWxmSXNDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KGZhbHNlKTtcblxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGNoZWNrZWRDb3VudCAvIChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xuICAgICAgICByZXR1cm4gcGVyY2VudGFnZSA8PSAwID8gZmFsc2UgOiBwZXJjZW50YWdlID49IDEgPyB0cnVlIDogXCJtaXhlZFwiO1xuICAgIH0sIFtjaGVja2VkQ291bnRdKTtcblxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWRTdGFibGUgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUpO1xuICAgIGNvbnN0IFtzZXRQYXJlbnRDaGVja2JveENoZWNrZWQsIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZF0gPSB1c2VTdGF0ZTxTdGF0ZVVwZGF0ZXI8Q2hlY2tib3hDaGVja2VkVHlwZT4gfCBudWxsPihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRQYXJlbnRDaGVja2JveENoZWNrZWQ/LihjaGVja2VkQ291bnQgPT0gMCA/IGZhbHNlIDogY2hlY2tlZENvdW50ID09IChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpID8gdHJ1ZSA6IFwibWl4ZWRcIik7XG4gICAgfSwgW3NldFBhcmVudENoZWNrYm94Q2hlY2tlZCwgY2hlY2tlZENvdW50XSlcblxuICAgIC8vIElmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBwYXJlbnQgY2hlY2tib3gncyB2YWx1ZSwgdGhlbiB0aGlzIHJlZiBob2xkcyBhIG1lbW9yeSBvZiB3aGF0IHZhbHVlcyB3ZXJlIGhlbGQgYmVmb3JlLlxuICAgIC8vIE90aGVyd2lzZSwgaXQncyBudWxsIHdoZW4gdGhlIGxhc3QgaW5wdXQgd2FzIGZyb20gYSBjaGlsZCBjaGVja2JveC4gXG4gICAgLy9jb25zdCBzYXZlZENoZWNrZWRWYWx1ZXMgPSB1c2VSZWY8TWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQgPSB1c2VDYWxsYmFjazxVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pj4oKHsgY2hlY2tib3gsIGNoZWNrYm94TGlrZSwgbGFiZWwsIGhhc0ZvY3VzTGFiZWwsIGhhc0ZvY3VzSW5wdXQgfSkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBQYXJlbnRcIik7XG4gICAgICAgIGNvbnN0IHsgLi4uX3ZvaWQgfSA9IGNoZWNrYm94O1xuICAgICAgICBjb25zdCB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCAgLi4uX3ZvaWQyIH0gPSBjaGVja2JveExpa2U7XG4gICAgICAgIGNvbnN0IHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCAgLi4uX3ZvaWQzIH0gPSBsYWJlbDtcblxuICAgICAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZTxDaGVja2JveENoZWNrZWRUeXBlPihmYWxzZSk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQoKCkgPT4gc2V0Q2hlY2tlZCk7XG4gICAgICAgIH0sIFtdKVxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExhYmVsRWxlbWVudCB9ID0gdXNlQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlOiB7IGxhYmVsUG9zaXRpb24sIGNoZWNrZWQsIGRpc2FibGVkLCB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSwgY2hlY2tib3g6IHsgb25DaGVja2VkQ2hhbmdlOiBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgYXMgYW55LCB9LCBoYXNGb2N1c0lucHV0LCBoYXNGb2N1c0xhYmVsIH0pO1xuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scywgb25JbnB1dDogdGFnSW5wdXQgPT0gXCJpbnB1dFwiID8gKGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKSA6IHVuZGVmaW5lZCB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pLCBwcm9wcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiID8gcmV0IDogcHJvcHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxMYWJlbEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPExhYmVsRWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scyB9IGFzIGFueSkgYXMgYW55LCBwcm9wcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiID8gcmV0IDogcHJvcHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7XG5cbiAgICBjb25zdCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgPSB1c2VDYWxsYmFjaygoZTogQ2hlY2tib3hDaGFuZ2VFdmVudDxJbnB1dEVsZW1lbnQ+KSA9PiB7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IHNlbGZJc0NoZWNrZWQgPSBnZXRTZWxmSXNDaGVja2VkU3RhYmxlKCk7XG4gICAgICAgIGNvbnN0IG5leHRDaGVja2VkID0gKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlID8gXCJtaXhlZFwiIDogc2VsZklzQ2hlY2tlZCA9PT0gXCJtaXhlZFwiID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgbGV0IHdpbGxDaGFuZ2VBbnkgPSBmYWxzZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB3aWxsQ2hhbmdlQW55IHx8PSAoY2hpbGQuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uY2hlY2tlZCAhPSBjaGlsZC5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5nZXRMYXN0VXNlckNoZWNrZWQoKSkpO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGxldCBjaGVja2VkOiBib29sZWFuO1xuICAgICAgICAgICAgaWYgKG5leHRDaGVja2VkID09IFwibWl4ZWRcIikge1xuICAgICAgICAgICAgICAgIGlmICh3aWxsQ2hhbmdlQW55KVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gKGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldExhc3RVc2VyQ2hlY2tlZCgpIGFzIGJvb2xlYW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gbmV4dENoZWNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5vbkNoZWNrZWRDaGFuZ2U/LihlbmhhbmNlRXZlbnQoZSwgeyBjaGVja2VkIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qaWYgKHNlbGZJc0NoZWNrZWQgPT09IHRydWUgfHwgKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlICYmIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IGZhbHNlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxmSXNDaGVja2VkID09PSBcIm1peGVkXCIpIHtcblxuICAgICAgICAgICAgc2F2ZWRDaGVja2VkVmFsdWVzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCEuc2V0KGNoaWxkLmluZGV4LCBjaGlsZC5nZXRMYXN0VXNlckNoZWNrZWQoKSk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9uVXBkYXRlQ2hpbGRyZW4oZW5oYW5jZUV2ZW50KGUsIHsgY2hpbGRyZW5DaGVja2VkOiBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA/PyB0cnVlIH0pKTtcbiAgICAgICAgfSovXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBub3RpZnlDaGVja2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBudW1iZXIsIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCIpID0+IHtcbiAgICAgICAgaWYgKGNoZWNrZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2hlY2tlZENvdW50KGMgPT4gKGMgKyAxKSk7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGljZXMuY3VycmVudC5hZGQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHNldENoZWNrZWRDb3VudChjID0+IChjIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSBjaGVja2VkQ291bnQgLyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBzZXRTZWxmSXNDaGVja2VkKHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIilcbiAgICB9LCBbc2V0U2VsZklzQ2hlY2tlZCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgY2hlY2tlZENvdW50XSk7Ki9cblxuICAgIC8qY29uc3QgdXNlQ2hlY2tib3hHcm91cFBhcmVudFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIHJldHVybiBcbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7Ki9cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbnRyb2xzKEFycmF5LmZyb20oYWxsSWRzLmN1cnJlbnQpLmpvaW4oXCIgXCIpKTtcbiAgICB9LCBbdXBkYXRlSW5kZXhdKVxuXG4gICAgY29uc3QgdXNlQ2hlY2tib3hHcm91cENoaWxkOiBVc2VDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2s8VXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pj4oZnVuY3Rpb24gKHsgYXNDaGVja2JveCwgYXNDaGVja2JveEdyb3VwQ2hpbGQgfSkge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBDaGlsZFwiLCBhc0NoZWNrYm94R3JvdXBDaGlsZC5tYW5hZ2VkQ2hpbGQuaW5kZXgsIGFzQ2hlY2tib3guY2hlY2tib3hMaWtlLmNoZWNrZWQpO1xuICAgICAgICBjb25zdCB7IGNoZWNrYm94OiB7IG9uQ2hlY2tlZENoYW5nZSB9LCBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSwgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sIGhhc0ZvY3VzSW5wdXQsIGhhc0ZvY3VzTGFiZWwgfSA9IGFzQ2hlY2tib3g7XG4gICAgICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkOiB7IGluZGV4IH0gfSA9IGFzQ2hlY2tib3hHcm91cENoaWxkO1xuICAgICAgICAvL2xhYmVsUG9zaXRpb24gPz89IFwic2VwYXJhdGVcIjtcbiAgICAgICAgY29uc3QgW2dldExhc3RVc2VyQ2hlY2tlZCwgc2V0TGFzdFVzZXJDaGVja2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuIHwgXCJtaXhlZFwiPihudWxsLCByZXR1cm5GYWxzZSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LFxuICAgICAgICAgICAgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQsXG4gICAgICAgICAgICAuLi5jaGVja2JveFJldHVyblR5cGVcbiAgICAgICAgfSA9IHVzZUNoZWNrYm94PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XG4gICAgICAgICAgICBjaGVja2JveDoge1xuICAgICAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2hlY2tlZENoYW5nZT4+KGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRMYXN0VXNlckNoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZT8uKGUgYXMgYW55KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGVja2JveExpa2U6IHtcbiAgICAgICAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICB0YWdJbnB1dCxcbiAgICAgICAgICAgICAgICB0YWdMYWJlbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc0ZvY3VzSW5wdXQsXG4gICAgICAgICAgICBoYXNGb2N1c0xhYmVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgbGFiZWw6IHsgaW5wdXRJZCwgbGFiZWxJZCB9IH0gPSBjaGVja2JveFJldHVyblR5cGU7XG5cbiAgICAgICAgLy9jb25zdCBnZXRDaGVja2VkID0gdXNlU3RhYmxlR2V0dGVyKGNoZWNrZWQpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzSWQgPSAobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBpbnB1dElkIDogbGFiZWxJZCkhO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBhbGxJZHMuY3VycmVudC5hZGQoY29udHJvbHNJZCk7XG4gICAgICAgICAgICBzZXRJZFVwZGF0ZUluZGV4KGkgPT4gKytpKTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBhbGxJZHMuY3VycmVudC5kZWxldGUoY29udHJvbHNJZCk7XG4gICAgICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtjb250cm9sc0lkXSk7XG5cblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XG4gICAgICAgIH0sIFtpbmRleCwgY2hlY2tlZF0pO1xuXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2aWdhdGlvblJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgc3ViSW5mbzogeyBnZXRMYXN0VXNlckNoZWNrZWQsIG9uQ2hlY2tlZENoYW5nZSwgY2hlY2tlZCB9LFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4uYXNDaGVja2JveEdyb3VwQ2hpbGQubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogYXNDaGVja2JveEdyb3VwQ2hpbGQubWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IGFzQ2hlY2tib3hHcm91cENoaWxkLnJvdmluZ1RhYkluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGVja2JveExpa2U6IGNoZWNrYm94UmV0dXJuVHlwZS5jaGVja2JveExpa2UsXG4gICAgICAgICAgICBsYWJlbDogY2hlY2tib3hSZXR1cm5UeXBlLmxhYmVsLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQyID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMocmV0KSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiID8gcmV0MiA6IHJldCkgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHJldCBhcyBhbnkpIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHJldDIgOiByZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkLFxuICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgY2hlY2tib3hHcm91cDoge1xuICAgICAgICAgICAgcGFyZW50SXNDaGVja2VkOiBnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUoKSBhcyBib29sZWFuIHwgXCJtaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50UGVyY2VudENoZWNrZWQ6IChjaGVja2VkQ291bnQgLyAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKSksXG4gICAgICAgIH1cbiAgICB9O1xufVxuIiwiXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIHVzZUZvY3VzVHJhcCwgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuaW50ZXJmYWNlIFNEUCB7XG4gICAgLyoqXG4gICAgICogTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBjb3VudCBhcyBcIndpdGhpblwiIHRoaXMgY29tcG9uZW50LlxuICAgICAqIFxuICAgICAqIFVzdWFsbHkganVzdCBhIHNpbmdsZSBlbGVtZW50LCBidXQgZS5nLiBhIE1lbnUgKyBNZW51QnV0dG9uIGNvdWxkIGhhdmUgdHdvLlxuICAgICAqL1xuICAgIGdldEVsZW1lbnRzOiAoKSA9PiBFbGVtZW50IHwgKEVsZW1lbnQgfCBudWxsKVtdIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGlzbWlzc2VkXG4gICAgICovXG4gICAgb25DbG9zZShyZWFzb246IFwiYmFja2Ryb3BcIiB8IFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIik6IHZvaWQ7XG5cbiAgICBvcGVuOiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgTVAge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGJvZHkgZWxlbWVudCBwcm92aWRlZCBjb250YWlucyBwdXJlbHkgc2VtYW50aWMgY29udGVudFxuICAgICAqIHRoYXQgY2FuIGJlIHJlYWQgb3V0IGJ5IGEgc2NyZWVuIHJlYWRlciBpbiBvbmUgbG9uZywgdW5pbnRlcnJ1cHRlZCBzdHJldGNoLlxuICAgICAqIFxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGZhbHNlIGlmIHRoZSBtb2RhbCBjb250YWlucywgZm9yIGV4YW1wbGUsIGEgbGlzdCBvciBvdGhlclxuICAgICAqIGludGVyYWN0aXZlIHdpZGdldHMsIGFuZCB0cnVlIGlmIGl0J3MgbW9zdGx5IHNob3J0LWZvcm0gdGV4dCBjb250ZW50LlxuICAgICAqIFxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGZhbHNlIHRvIGJlIG9uIHRoZSBzYWZlIHNpZGUsIGJ1dCB0aGlzIHNob3VsZCBiZSB0cnVlIHdoZW5ldmVyIHJlYXNvbmFibGUuXG4gICAgICovXG4gICAgYm9keUlzT25seVNlbWFudGljPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYW55IG1vZGFsIGRpYWxvZyBvcGVucywgaXQgbXVzdCBzZW5kIGZvY3VzIHRvIHRoYXQgZGlhbG9nLCBpZGVhbGx5IHdoaWNoZXZlciBlbGVtZW50IG1ha2VzIHRoZSBtb3N0IHNlbnNlIGluIGNvbnRleHQuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGl0J3MgYSBjb25maXJtYXRpb24gZGlhbG9nIGFib3V0IGRlbGV0aW5nIHNvbWV0aGluZywgaXQncyBiZXN0IHRvIHNlbmQgZm9jdXMgdG8gdGhlIFwiY2FuY2VsXCIgYnV0dG9uLlxuICAgICAqIFxuICAgICAqIEluIG90aGVyIGNhc2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGZvY3VzIHRoZSBkaWFsb2cncyB0aXRsZSwgZmlyc3QgaW50ZXJhY3RpdmUgZWxlbWVudCwgZXRjLlxuICAgICAqIFxuICAgICAqIEJ5IGRlZmF1bHQsIHdlIHRyeSB0byBwaWNrIGEgc2Vuc2libGUgZGVmYXVsdCAtLSBpZiB0aGUgZGlhbG9nIGNvbnRhaW5zIG9ubHkgZGVzY3JpcHRpdmUgY29udGVudCwgdGhlbiB3ZSBmb2N1cyB0aGUgYm9keS4gT3RoZXJ3aXNlIHdlIGZvY3VzIHRoZSB0aXRsZS5cbiAgICAgKiBcbiAgICAgKiAqKlBMRUFTRSoqIGNvbnNpZGVyIG92ZXJyaWRpbmcgdGhpcyB0byBwcm92aWRlIHRoZSBiZXN0IGV4cGVyaWVuY2UgZm9yIHlvdXIgZGlhbG9nLiAgWW91IHNob3VsZG4ndCBoYXZlIHRoYXQgbWFueSBtb2RhbCBkaWFsb2dzIGFueXdheSAtLSB0YWtlIHRoYXQgYml0IG9mIGV4dHJhIHRpbWUgaWYgeW91IGNhbi5cbiAgICAgKi9cbiAgICBmb2N1c1NlbGY/KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFNvZnREaXNtaXNzT21pdHMgPSBrZXlvZiBTRFA7XG5leHBvcnQgdHlwZSBNb2RhbE9taXRzID0ga2V5b2YgTVA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgU29mdERpc21pc3NPbWl0cz4ge1xuICAgIHNvZnREaXNtaXNzOiBPbWl0PFNEUCwgT21pdHM+O1xuICAgIGFjdGl2ZUVsZW1lbnQ6IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUGFyYW1ldGVyczxNTyBleHRlbmRzIE1vZGFsT21pdHMsIFNETyBleHRlbmRzIFNvZnREaXNtaXNzT21pdHM+IGV4dGVuZHMgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFNETyB8IFwiZ2V0RWxlbWVudHNcIj4ge1xuICAgIG1vZGFsOiBPbWl0PE1QLCBNTz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XG4gICAgc29mdERpc21pc3M6IHtcbiAgICAgICAgb25CYWNrZHJvcENsaWNrOiAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxhbnk+KSA9PiB2b2lkO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlV2l0aEhvb2tzPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiBUaGlzIGJhc2ljYWxseSBjYW4gYmUgYW55IGVsZW1lbnQgLS0gaXQncyBvbmx5IHVzZWQgdG8gZ2V0IHRoZSBvd25pbmcgd2luZG93L2RvY3VtZW50LiAqL1xuICAgIHVzZVNvZnREaXNtaXNzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xufVxuXG4vKipcbiAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGEgbW9kYWwtbGlrZSBzb2Z0LWRpc21pc3MgaW50ZXJhY3Rpb24uXG4gKiBcbiAqIFRoYXQgaXMsIGFueSBjbGlja3Mgb3IgdGFwcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQsIFxuICogb3IgYW55IHRpbWUgdGhlIEVzY2FwZSBrZXkgaXMgcHJlc3NlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCxcbiAqICh3aXRoIHZhcmlvdXMgYnJvd3NlciBvZGRpdGllcyByZWdhcmRpbmcgY2xpY2tzIG9uIGJsYW5rIG9yIGluZXJ0IGFyZWFzIGhhbmRsZWQpXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXG4gKiBcbiAqIE9mIGNvdXJzZSwgaWYgeW91IGRvbid0IGRvIGFueXRoaW5nIGluIHRoZSBgb25DbG9zZWAgZnVuY3Rpb24sXG4gKiBpdCB3b24ndCBiZSBhIHNvZnQgZGlzbWlzcyBhbnltb3JlLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb2Z0RGlzbWlzczxUIGV4dGVuZHMgTm9kZT4oeyBzb2Z0RGlzbWlzczogeyBvbkNsb3NlLCBnZXRFbGVtZW50cywgb3BlbiB9LCBhY3RpdmVFbGVtZW50OiB7IG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIC4uLmFjdGl2ZUVsZW1lbnQgfSB9OiBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8bmV2ZXI+KTogVXNlU29mdERpc21pc3NSZXR1cm5UeXBlV2l0aEhvb2tzPFQ+IHtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcbiAgICBjb25zdCBzdGFibGVHZXRFbGVtZW50cyA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldEVsZW1lbnRzKTtcbiAgICBjb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKG9wZW4pO1xuXG4gICAgY29uc3QgeyBnZXREb2N1bWVudCB9ID0gYWN0aXZlRWxlbWVudFxuXG4gICAgY29uc3Qgb25CYWNrZHJvcENsaWNrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gb25CYWNrZHJvcENsaWNrKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8YW55Pikge1xuICAgICAgICBpZiAoIWdldE9wZW4oKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBcIndhcyB0aGlzIGV2ZW50IGZpcmVkIG9uIHRoZSByb290LW1vc3QgZWxlbWVudCwgb3IgYXQgbGVhc3QgYW4gZWxlbWVudCBub3QgY29udGFpbmVkIGJ5IHRoZSBtb2RhbD9cIlxuICAgICAgICAvLyBFaXRoZXIgY291bGQgYmUgaG93IHRoZSBicm93c2VyIGhhbmRsZXMgdGhlc2Ugc29ydHMgb2YgXCJpbnRlcmFjdGluZyB3aXRoIG5vdGhpbmdcIiBldmVudHMuXG4gICAgICAgIGlmIChlLnRhcmdldCA9PSBkb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBzdGFibGVPbkNsb3NlKFwiYmFja2Ryb3BcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBzdGFibGVHZXRFbGVtZW50cygpO1xuXG4gICAgICAgIGlmIChlbGVtZW50cyAmJiBlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50cykpXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuXG4gICAgICAgICAgICBsZXQgZm91bmRJbnNpZGVDbGljayA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEluc2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZvdW5kSW5zaWRlQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKFwiYmFja2Ryb3BcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IHsgLi4uX3VudXNlZCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7XG4gICAgICAgIC4uLmFjdGl2ZUVsZW1lbnQsXG5cbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKG5ld0VsZW1lbnQ6IEVsZW1lbnQsIHByZXY6IEVsZW1lbnQgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/LihuZXdFbGVtZW50LCBwcmV2KTtcbiAgICAgICAgICAgIGxldCB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzID0gc3RhYmxlR2V0RWxlbWVudHMoKTtcblxuICAgICAgICAgICAgaWYgKHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsaWRGb2N1c2FibGVFbGVtZW50cykpXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9jdXNhYmxlRWxlbWVudHMgPSBbdmFsaWRGb2N1c2FibGVFbGVtZW50c107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZvY3VzYWJsZSBvZiB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2FibGU/LmNvbnRhaW5zKG5ld0VsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25DbG9zZShcImxvc3QtZm9jdXNcIik7XG4gICAgICAgIH0sIFtdKVxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XG4gICAgICAgIG9uTW91bnQ6IHVzZUNhbGxiYWNrKCgpID0+IHsgZGVidWdnZXI7IH0sIFtdKSxcbiAgICAgICAgb25Vbm1vdW50OiB1c2VDYWxsYmFjaygoKSA9PiB7IGRlYnVnZ2VyOyB9LCBbXSksXG4gICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGU6IFQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3O1xuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgZXZlcnl0aGluZyBlbHNlIGlzIGluZXJ0LCB3ZSBsaXN0ZW4gZm9yIGNhcHR1cmVkIGNsaWNrcyBvbiB0aGUgd2luZG93XG4gICAgICAgICAgICAgICAgLy8gKHdlIGRvbid0IHVzZSBvbkNsaWNrIHNpbmNlIHRoYXQgZG9lc24ndCBmaXJlIHdoZW4gY2xpY2tlZCBvbiBlbXB0eS9pbmVydCBhcmVhcylcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIGEgKnNlcGFyYXRlKiB0b3VjaCBldmVudCBvbiBtb2JpbGUgU2FmYXJpLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gaXQgZG9lc24ndCBsZXQgY2xpY2sgZXZlbnRzIGJ1YmJsZSBvciBiZSBjYXB0dXJlZCBmcm9tIHRyYWRpdGlvbmFsbHkgbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0b3VjaCBldmVudHMgd29yayBhcyBleHBlY3RlZC5cbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZURvd24gPSAoZTogTW91c2VFdmVudCkgPT4geyBpZiAoZ2V0T3BlbigpKSBvbkJhY2tkcm9wQ2xpY2soZSk7IH07XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hTdGFydCA9IChlOiBUb3VjaEV2ZW50KSA9PiB7IGlmIChnZXRPcGVuKCkpIG9uQmFja2Ryb3BDbGljayhlKTsgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHsgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7IHN0YWJsZU9uQ2xvc2UoXCJlc2NhcGVcIik7IH0gfTtcblxuICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnQsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleURvd24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG1vdXNlRG93bik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5RG93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNvZnREaXNtaXNzUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPiA9PiB7IGRlYnVnZ2VyOyByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHByb3BzKSB9LCBbXSksXG4gICAgICAgIHNvZnREaXNtaXNzOiB7XG4gICAgICAgICAgICBvbkJhY2tkcm9wQ2xpY2ssXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTW9kYWxSZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTW9kYWxSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1vZGFsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNb2RhbFJldHVyblR5cGVJbmZvIHtcbiAgICB1c2VNb2RhbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD47XG4gICAgdXNlTW9kYWxUaXRsZTogVXNlTW9kYWxUaXRsZTxUaXRsZUVsZW1lbnQ+O1xuICAgIHVzZU1vZGFsQm9keTogVXNlTW9kYWxCb2R5PEJvZHlFbGVtZW50PlxuICAgIHVzZU1vZGFsQmFja2Ryb3A6IFVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50PjtcbiAgICB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+O1xuICAgIC8vc29mdERpc21pc3M6IE9taXQ8VXNlU29mdERpc21pc3NSZXR1cm5UeXBlPE1vZGFsRWxlbWVudD5bXCJzb2Z0RGlzbWlzc1wiXSwgXCJ1c2VTb2Z0RGlzbWlzc1Byb3BzXCI+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VNb2RhbFRpdGxlPFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VNb2RhbFRpdGxlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PjsgfTtcbmV4cG9ydCB0eXBlIFVzZU1vZGFsQm9keTxCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VNb2RhbEJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PjsgfTtcbmV4cG9ydCB0eXBlIFVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+OyB9O1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBtb2RhbCBob29rLCB1c2VkIGJ5IG1vZGFsIGRpYWxvZ3MsIGJ1dCBjYW4gYWxzb1xuICogYmUgdXNlZCBieSBhbnl0aGluZyB0aGF0J3MgbW9kYWwgd2l0aCBhIGJhY2tkcm9wLlxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTW9kYWw8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIE1vZGFsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgbW9kYWw6IHsgYm9keUlzT25seVNlbWFudGljOiBkZXNjcmlwdGl2ZSwgZm9jdXNTZWxmIH0sIHNvZnREaXNtaXNzOiB7IG9uQ2xvc2UsIG9wZW4gfSwgYWN0aXZlRWxlbWVudCB9OiBVc2VNb2RhbFBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyPik6IFVzZU1vZGFsUmV0dXJuVHlwZVdpdGhIb29rczxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIE1vZGFsRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wczogdXNlVGl0bGVSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQ6IGdldFRpdGxlRWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxUaXRsZUVsZW1lbnQ+KHt9KTtcbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wczogdXNlQm9keVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudDogZ2V0Qm9keUVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8Qm9keUVsZW1lbnQ+KHt9KTtcbiAgICBmb2N1c1NlbGYgPz89ICgoKSA9PiB7XG4gICAgICAgIGlmIChkZXNjcmlwdGl2ZSkge1xuICAgICAgICAgICAgZ2V0Qm9keUVsZW1lbnQoKT8uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGl0bGVFbGVtZW50ID0gZ2V0VGl0bGVFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodGl0bGVFbGVtZW50KVxuICAgICAgICAgICAgICAgIHRpdGxlRWxlbWVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG5cbiAgICAgICAgfVxuICAgICAgICAvL2NvbnN0IGVsZW1lbnRUb0ZvY3VzID0gZ2V0VGl0bGVFbGVtZW50KCkgPz8gZ2V0Qm9keUVsZW1lbnQoKVxuICAgIH0pO1xuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcbiAgICBjb25zdCBzdGFibGVGb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjayhmb2N1c1NlbGYpO1xuXG4gICAgLy9jb25zdCBbbW9kYWxEZXNjcmliZWRCeUJvZHksIHNldE1vZGFsRGVzY3JpYmVkQnlCb2R5XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB1c2VIaWRlU2Nyb2xsKG9wZW4pO1xuXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZU1vZGFsSWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPE1vZGFsRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlQm9keUlkQXNTb3VyY2UsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50IH0gPSB1c2VSYW5kb21JZDxCb2R5RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1ib2R5LVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VUaXRsZUlkQXNTb3VyY2UsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8VGl0bGVFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1vZGFsLXRpdGxlLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuXG5cbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTW9kYWxSZWZFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRNb2RhbEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8TW9kYWxFbGVtZW50Pih7fSlcbiAgICBjb25zdCB7IHNvZnREaXNtaXNzOiB7IG9uQmFja2Ryb3BDbGljayB9LCB1c2VTb2Z0RGlzbWlzc1Byb3BzIH0gPSB1c2VTb2Z0RGlzbWlzczxNb2RhbEVsZW1lbnQ+KHsgc29mdERpc21pc3M6IHsgb25DbG9zZTogc3RhYmxlT25DbG9zZSwgZ2V0RWxlbWVudHM6IGdldE1vZGFsRWxlbWVudCwgb3BlbjogISFvcGVuIH0sIGFjdGl2ZUVsZW1lbnQgfSk7XG5cbiAgICBjb25zdCB1c2VNb2RhbEJhY2tkcm9wID0gdXNlQ2FsbGJhY2s8VXNlTW9kYWxCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQ+PihmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wKCkge1xuICAgICAgICBmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxCYWNrZHJvcEVsZW1lbnQ+KHsgb25Qb2ludGVyVXA6IG9uQmFja2Ryb3BDbGljayB9LCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgdXNlTW9kYWxGb2N1c0NvbnRhaW5lclByb3BzID0gZnVuY3Rpb24gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+KHsgdHJhcEFjdGl2ZTogb3BlbiB9KTtcbiAgICAgICAgcmV0dXJuIHVzZUZvY3VzVHJhcFByb3BzKHByb3BzKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VNb2RhbFByb3BzID0gZnVuY3Rpb24gKHsgXCJhcmlhLW1vZGFsXCI6IGFyaWFNb2RhbCwgcm9sZSwgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD4ge1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VNb2RhbElkQXNTb3VyY2VQcm9wcyB9ID0gdXNlTW9kYWxJZEFzU291cmNlKCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VUaXRsZUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50PE1vZGFsRWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudDxNb2RhbEVsZW1lbnQ+KFwiYXJpYS1kZXNjcmliZWRieVwiIGFzIG5ldmVyKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoIWFyaWFNb2RhbCk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3BlbilcbiAgICAgICAgICAgICAgICBzdGFibGVGb2N1c1NlbGYoKTtcbiAgICAgICAgfSwgW29wZW5dKVxuICAgICAgICBjb25zdCBwMSA9IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMocDApO1xuICAgICAgICBjb25zdCBwMiA9IHVzZU1vZGFsSWRBc1NvdXJjZVByb3BzKHAxKTtcbiAgICAgICAgY29uc3QgcEZpbmFsID0gdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMocDIpO1xuICAgICAgICByZXR1cm4gdXNlU29mdERpc21pc3NQcm9wcyh1c2VNZXJnZWRQcm9wczxNb2RhbEVsZW1lbnQ+KHVzZU1vZGFsUmVmRWxlbWVudCh7IHJvbGU6IHJvbGUgfHwgXCJkaWFsb2dcIiB9KSwgZGVzY3JpcHRpdmUgPyBwRmluYWwgOiBwMikpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZU1vZGFsVGl0bGUgPSB1c2VDYWxsYmFjazxVc2VNb2RhbFRpdGxlPFRpdGxlRWxlbWVudD4+KGZ1bmN0aW9uIHVzZU1vZGFsVGl0bGUoKSB7XG5cbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlVGl0bGVJZEFzU291cmNlUHJvcHMgfSA9IHVzZVRpdGxlSWRBc1NvdXJjZSgpO1xuICAgICAgICBjb25zdCB1c2VNb2RhbFRpdGxlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+IHtcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTtcbiAgICAgICAgICAgIHJldHVybiB1c2VUaXRsZVJlZkVsZW1lbnRQcm9wcyh1c2VUaXRsZUlkQXNTb3VyY2VQcm9wcyhwcm9wcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxUaXRsZVByb3BzIH07XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCB1c2VNb2RhbEJvZHkgPSB1c2VDYWxsYmFjazxVc2VNb2RhbEJvZHk8Qm9keUVsZW1lbnQ+PihmdW5jdGlvbiB1c2VNb2RhbEJvZHkoKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUJvZHlJZEFzU291cmNlUHJvcHMgfSA9IHVzZUJvZHlJZEFzU291cmNlKCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudDxCb2R5RWxlbWVudD4oXCJkYXRhLW1vZGFsLWlkXCIgYXMgbmV2ZXIpO1xuXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsQm9keVByb3BzID0gZnVuY3Rpb24gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4ge1xuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xuICAgICAgICAgICAgcmV0dXJuIHVzZUJvZHlSZWZFbGVtZW50UHJvcHModXNlQm9keUlkQXNTb3VyY2VQcm9wcyh1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudFByb3BzKHByb3BzKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxCb2R5UHJvcHMgfTtcbiAgICB9LCBbXSlcblxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNb2RhbFByb3BzLFxuICAgICAgICB1c2VNb2RhbFRpdGxlLFxuICAgICAgICB1c2VNb2RhbEJvZHksXG4gICAgICAgIHVzZU1vZGFsQmFja2Ryb3AsXG4gICAgICAgIHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyxcbiAgICAgICAgc29mdERpc21pc3M6IHsgb25CYWNrZHJvcENsaWNrIH1cbiAgICB9O1xufVxuXG5cbi8qKlxuICogQWxsb3dzIGZvciBoaWRpbmcgdGhlIHNjcm9sbCBiYXIgb2YgdGhlIHJvb3QgSFRNTCBlbGVtZW50XG4gKiB3aXRob3V0IHNoaWZ0aW5nIHRoZSBsYXlvdXQgb2YgdGhlIHBhZ2UgbW9yZSB0aGFuIGFkZGluZyBhIGZvdyBwaXhlbHNcbiAqIG9mIHBhZGRpbmcgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBuZWNlc3NhcnkuXG4gKiBAcGFyYW0gaGlkZVNjcm9sbCBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUhpZGVTY3JvbGwoaGlkZVNjcm9sbDogYm9vbGVhbikge1xuICAgIGNvbnN0IFtnZXRTY3JvbGxiYXJXaWR0aCwgc2V0U2Nyb2xsYmFyV2lkdGhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtnZXRTY3JvbGxiYXJIZWlnaHQsIHNldFNjcm9sbGJhckhlaWdodF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaGlkZVNjcm9sbCkge1xuXG4gICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyBpcyByZXN1bWVkLCB3ZSdsbCBuZWVkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjcm9sbCBwb3NpdGlvbnNcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8ga2VlcCB0aGlzIGluZm9ybWF0aW9uIGFyb3VuZFxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxUb3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxMZWZ0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgIC8vIE1lYXN1cmUgdGhlIHdpZHRoIG9mIHRoZSBwYWdlIChtaW51cyB0aGUgc2Nyb2xsYmFyKVxuICAgICAgICAgICAgY29uc3Qgd2lkdGhXaXRoU2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0V2l0aFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGEgY2xhc3MgdGhhdCBoaWRlcyB0aGUgc2Nyb2xsYmFyLlxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkb2N1bWVudC1zY3JvbGwtaGlkZGVuXCIpO1xuXG4gICAgICAgICAgICAvLyBJbiBjYXNlIG11bHRpcGxlIHRoaW5ncyBhcmUgbG9ja2luZyBzY3JvbGwsIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgYXJlIGRvaW5nIHRoYXRcbiAgICAgICAgICAgIC8vIChqdXN0IGFkZCAxIG9uIGVuYWJsZSwgc3VidHJhY3QgMSBvbiBkaXNhYmxlKVxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPSAoKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSB8fCBcIjBcIikgKyAxKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBNZWFzdXJlIHRoZSBuZXcgd2lkdGggd2l0aG91dCBhIHNjcm9sbGJhciBcbiAgICAgICAgICAgIC8vIHNvIHdlIGNhbiB0YWtlIHRoZSBkaWZmZXJlbmNlIGFzIHRoZSBzY3JvbGxiYXIgd2lkdGguXG4gICAgICAgICAgICBjb25zdCB3aWR0aFdpdGhvdXRTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRXaXRob3V0U2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9ICh3aWR0aFdpdGhvdXRTY3JvbGxCYXIgLSB3aWR0aFdpdGhTY3JvbGxCYXIpO1xuICAgICAgICAgICAgbGV0IHNjcm9sbGJhckhlaWdodCA9IChoZWlnaHRXaXRob3V0U2Nyb2xsQmFyIC0gaGVpZ2h0V2l0aFNjcm9sbEJhcik7XG5cbiAgICAgICAgICAgIC8vIEZhaWxzYWZlIC0tIGlmIHRoaXMgbWVhc3VyaW5nIHRyaWNrIGRvZXMgc29tZXRoaW5nIHVuZXhwZWN0ZWQsIGp1c3QgaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGggPiA4MClcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJXaWR0aCA9IDA7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFySGVpZ2h0ID4gODApXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFySGVpZ2h0ID0gMDtcblxuICAgICAgICAgICAgLy8gTWFrZSBvdXIgbWVhc3VyZW1lbnRzIGF2YWlsYWJsZSBhcyBDU1MgcHJvcGVydGllcyBmb3IgZ2VuZXJhbCB1c2VcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxiYXItd2lkdGhcIiwgYCR7c2Nyb2xsYmFyV2lkdGh9cHhgKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxiYXItaGVpZ2h0XCIsIGAke3Njcm9sbGJhckhlaWdodH1weGApO1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbHN0b3AtdG9wXCIsIGAke29yaWdpbmFsU2Nyb2xsVG9wfXB4YCk7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsc3RvcC1sZWZ0XCIsIGAke29yaWdpbmFsU2Nyb2xsTGVmdH1weGApO1xuXG4gICAgICAgICAgICBzZXRTY3JvbGxiYXJXaWR0aChzY3JvbGxiYXJXaWR0aCk7XG4gICAgICAgICAgICBzZXRTY3JvbGxiYXJIZWlnaHQoc2Nyb2xsYmFySGVpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVbmRvIGFsbCB0aGUgdGhpbmdzIHdlIGp1c3QgZGlkXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPSAoKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSB8fCBcIjBcIikgLSAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9PSBcIjBcIikge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgdGhlIGxhc3Qgc2Nyb2xsLWxvY2tpbmcgdGhpbmcgdG8gc3RvcCwgdGhlbiByZW1vdmUgdGhlIGNsYXNzIHRoYXQgc3RvcHMgc2Nyb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zY3JvbGwtaGlkZXJzXCIpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImRvY3VtZW50LXNjcm9sbC1oaWRkZW5cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgYnkgZm9yY2luZyB0aGUgc2Nyb2xsIGJlaGF2aW9yIHRvIG5vdCBiZSBzbW9vdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gKGl0J3MgaW5zdGFudCBpZiBub3RoaW5nIGlzIHNldCB0byBzbW9vdGgsIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3NvbS12aWV3LyNzY3JvbGxpbmcpLFxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxpbmcsIHRoZW4gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBzY3JvbGwgYmVoYXZpb3IgXG4gICAgICAgICAgICAgICAgICAgIC8vICh3aGljaCB3YXMgcHJvYmFibHkgYWxyZWFkeSBhdXRvIGFueXdheSwgYnV0IGp1c3QgdG8gYmUgc2FmZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxCZWhhdmlvciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUbyh7IHRvcDogb3JpZ2luYWxTY3JvbGxUb3AsIGxlZnQ6IG9yaWdpbmFsU2Nyb2xsTGVmdCwgYmVoYXZpb3I6IFwiYXV0b1wiIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBvcmlnaW5hbFNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSwgW2hpZGVTY3JvbGxdKTtcblxuICAgIHJldHVybiB7IGdldFNjcm9sbGJhcldpZHRoLCBnZXRTY3JvbGxiYXJIZWlnaHQgfTtcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2cgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTW9kYWwsIFVzZU1vZGFsUGFyYW1ldGVycywgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYXdlclJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1vZGFsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VEcmF3ZXJSZXR1cm5UeXBlSW5mbyB7XG4gICAgdXNlRHJhd2VyUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PjtcbiAgICB1c2VEcmF3ZXJUaXRsZTogVXNlRHJhd2VyVGl0bGU8VGl0bGVFbGVtZW50PjtcbiAgICB1c2VEcmF3ZXJCb2R5OiBVc2VEcmF3ZXJCb2R5PEJvZHlFbGVtZW50PlxuICAgIHVzZURyYXdlckJhY2tkcm9wOiBVc2VEcmF3ZXJCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQ+O1xuICAgIHVzZURyYXdlckZvY3VzQ29udGFpbmVyUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VEcmF3ZXJUaXRsZTxUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlRHJhd2VyVGl0bGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+OyB9O1xuZXhwb3J0IHR5cGUgVXNlRHJhd2VyQm9keTxCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEcmF3ZXJCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47IH07XG5leHBvcnQgdHlwZSBVc2VEcmF3ZXJCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlRHJhd2VyQmFja2Ryb3BQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+OyB9O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhd2VyUGFyYW1ldGVycyBleHRlbmRzIFVzZU1vZGFsUGFyYW1ldGVyczxuZXZlciwgbmV2ZXI+IHtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyYXdlcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRHJhd2VyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgc29mdERpc21pc3M6IHsgb3Blbiwgb25DbG9zZSB9LCBhY3RpdmVFbGVtZW50LCBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWMsIGZvY3VzU2VsZiB9IH06IFVzZURyYXdlclBhcmFtZXRlcnMpOiBVc2VEcmF3ZXJSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PiB7XG5cbiAgICBkZWJ1Z0xvZyhcInVzZURyYXdlclwiKTtcblxuICAgIC8vIFRPRE86IERyYXdlcnMgYXJlIG5vdCBhbHdheXMgbW9kYWwuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZU1vZGFsQmFja2Ryb3AsXG4gICAgICAgIHVzZU1vZGFsQm9keSxcbiAgICAgICAgdXNlTW9kYWxQcm9wcyxcbiAgICAgICAgdXNlTW9kYWxUaXRsZSxcbiAgICAgICAgdXNlTW9kYWxGb2N1c0NvbnRhaW5lclByb3BzLFxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkJhY2tkcm9wQ2xpY2sgfVxuICAgIH0gPSB1c2VNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4oeyBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWM6IChib2R5SXNPbmx5U2VtYW50aWMgPz8gZmFsc2UpLCBmb2N1c1NlbGYgfSwgc29mdERpc21pc3M6IHsgb25DbG9zZSwgb3BlbiB9LCBhY3RpdmVFbGVtZW50IH0pO1xuXG4gICAgY29uc3QgdXNlRHJhd2VyQmFja2Ryb3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzIH0gPSB1c2VNb2RhbEJhY2tkcm9wKCk7XG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlckJhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XG5cbiAgICBjb25zdCB1c2VEcmF3ZXJCb2R5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQm9keVByb3BzIH0gPSB1c2VNb2RhbEJvZHkoKTtcbiAgICAgICAgcmV0dXJuIHsgdXNlRHJhd2VyQm9keVByb3BzOiB1c2VNb2RhbEJvZHlQcm9wcyB9O1xuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XG4gICAgY29uc3QgdXNlRHJhd2VyUHJvcHMgPSB1c2VNb2RhbFByb3BzO1xuXG4gICAgY29uc3QgdXNlRHJhd2VyVGl0bGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlKCk7XG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlclRpdGxlUHJvcHM6IHVzZU1vZGFsVGl0bGVQcm9wcyB9O1xuICAgIH0sIFt1c2VNb2RhbFRpdGxlXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VEcmF3ZXJQcm9wcyxcbiAgICAgICAgdXNlRHJhd2VyVGl0bGUsXG4gICAgICAgIHVzZURyYXdlckJvZHksXG4gICAgICAgIHVzZURyYXdlckJhY2tkcm9wLFxuICAgICAgICB1c2VEcmF3ZXJGb2N1c0NvbnRhaW5lclByb3BzOiB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMsXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQmFja2Ryb3BDbGljayB9XG4gICAgfVxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZVJhbmRvbUlkLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCB3YXJuT25PdmVyd3JpdGUgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTGFiZWwsIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuZXhwb3J0IHR5cGUgTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyIHwgXCJvblNlbGVjdGVkSW5kZXhDaGFuZ2VcIiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgbGlzdGJveFNpbmdsZToge1xuICAgICAgICAvL3NlbGVjdGlvbk1vZGU6IFwiZm9jdXNcIiB8IFwiYWN0aXZhdGVcIjtcbiAgICAgICAgb25TZWxlY3Q/KGV2ZW50OiBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RWxlbWVudD4pOiB2b2lkO1xuICAgICAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XG4gICAgICAgIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUsIHt9LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4ge1xuICAgIGxpc3Rib3hTaW5nbGVJdGVtOiB7IGRpc2FibGVkPzogYm9vbGVhbjsgfVxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XG59XG5cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdEl0ZW1FbGVtZW50PikgPT4gVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPExpc3RJdGVtRWxlbWVudD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+IHtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVXaXRoSG9va3M8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xuICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCwge30sIG5ldmVyPiwgVXNlTGFiZWxSZXR1cm5UeXBlSW5mbyB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xuICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtOiBVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQ+O1xuICAgIHVzZUxpc3Rib3hTaW5nbGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBsaXN0Ym94U2luZ2xlOiB7IHRhZ0xhYmVsLCB0YWdMaXN0LCBvblNlbGVjdCwgLi4uX2xicyB9LFxuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCAuLi5zcyB9LFxuICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxuICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLnJ0aSB9LFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgLi4udG4gfSxcbiAgICBjaGlsZHJlbkhhdmVGb2N1czogeyAuLi5jaGYgfVxufTogVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4pOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZUxpc3Rib3hTaW5nbGVcIiwgc2VsZWN0ZWRJbmRleCk7XG5cbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwsIC4uLmxhYmVsUmV0dXJuVHlwZSB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgcHJlZml4TGFiZWw6IFwiYXJpYS1saXN0Ym94LWxhYmVsLVwiLFxuICAgICAgICAgICAgcHJlZml4SW5wdXQ6IFwiYXJpYS1saXN0Ym94LVwiLFxuICAgICAgICAgICAgdGFnSW5wdXQ6IHRhZ0xpc3QsXG4gICAgICAgICAgICB0YWdMYWJlbDogdGFnTGFiZWxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25TZWxlY3RlZEluZGV4Q2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGV2ZW50OiBFdmVudCwgbmV3SW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBzdGFibGVPblNlbGVjdChlbmhhbmNlRXZlbnQ8TGlzdEl0ZW1FbGVtZW50LCBFdmVudCwgeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfT4oZXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogbmV3SW5kZXggfSkpXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsIC4uLmxpc3RSZXR1cm5UeXBlIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCB7fSwgbmV2ZXI+KHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgLi4uY2hmIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAuLi5ydGlcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IC4uLnNzLCBvblNlbGVjdGVkSW5kZXhDaGFuZ2UsIHNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG5cbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wcyB9ID0gdXNlTGFiZWxJbnB1dCgpO1xuICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3QgPz8gKCgpID0+IHsgfSkpO1xuXG5cbiAgICBjb25zdCB1c2VMaXN0Ym94U2luZ2xlSXRlbSA9IHVzZUNhbGxiYWNrPFVzZUxpc3Rib3hTaW5nbGVJdGVtPExpc3RJdGVtRWxlbWVudD4+KCh7IGxpc3Rib3hTaW5nbGVJdGVtOiB7IGRpc2FibGVkIH0sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBoYXNGb2N1cyB9KSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlTGlzdGJveFNpbmdsZUl0ZW1cIiwgbWFuYWdlZENoaWxkLmluZGV4KTtcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogcnRpX3JldCwgc2luZ2xlU2VsZWN0aW9uOiBzc19yZXQsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQsXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbixcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICAgICAgaGFzRm9jdXMsXG4gICAgICAgICAgICBzdWJJbmZvOiB7fVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiBzc19yZXRcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+Pihwcm9wczogUCkge1xuXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChzc19yZXQuc2VsZWN0ZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gXCJ0cnVlXCI7XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMocHJvcHMpO1xuICAgICAgICB9XG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRdKTtcblxuXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCkge1xuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pikge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfTtcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbSxcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZVByb3BzLFxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsXG4gICAgICAgIC4uLmxpc3RSZXR1cm5UeXBlLFxuICAgICAgICAuLi5sYWJlbFJldHVyblR5cGVcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pikge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyhwcm9wcykpO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0Ym94R3JvdXA8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRpbmdFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oKSB7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50LCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPEhlYWRpbmdFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJsaXN0Ym94LW11bHRpLWdyb3VwXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9KTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxDb250YWluZXJFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiKTtcbiAgICBjb25zdCB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRpbmdFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRpbmdFbGVtZW50PiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgfTtcbiAgICBjb25zdCB1c2VMaXN0Ym94R3JvdXBDb250YWluZXJQcm9wcyA9ICh7IHJvbGUsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gPT4ge1xuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHtcbiAgICAgICAgICAgIHJvbGU6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUxpc3Rib3hNdWx0aUdyb3VwUHJvcHNcIiwgXCJyb2xlXCIsIHJvbGUsIFwiZ3JvdXBcIiksXG4gICAgICAgICAgICAuLi5wcm9wc1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzLFxuICAgICAgICB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMsXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uVGFiYmFibGVJbmRleENoYW5nZSwgcmV0dXJuRmFsc2UsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycywgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUHJlc3MsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5cbmV4cG9ydCB0eXBlIExpc3Rib3hNdWx0aVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6IGJvb2xlYW4gfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcbiAgICBsaXN0Ym94TXVsdGk6IHtcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgICAgICB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8SW5mbywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcbiAgICBsaXN0Ym94TXVsdGlJdGVtOiB7XG4gICAgICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgICAgIG9uU2VsZWN0ZWRDaGFuZ2U/KGV2ZW50OiAoTGlzdGJveE11bHRpU2VsZWN0RXZlbnQ8RT4pKTogdm9pZDtcbiAgICB9O1xuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XG59XG5cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94TXVsdGlJdGVtPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVyczxFPikgPT4gVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxFPiB7XG4gICAgbGlzdGJveE11bHRpSXRlbToge1xuICAgICAgICB0YWJiYWJsZTogYm9vbGVhbjtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxFPiB7XG4gICAgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50LCBJbmZvLCBuZXZlcj4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XG4gICAgdXNlTGlzdGJveE11bHRpSXRlbTogVXNlTGlzdGJveE11bHRpSXRlbTxMaXN0SXRlbUVsZW1lbnQ+O1xuICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+O1xuICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsOiAoKSA9PiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxufVxuXG5cbmludGVyZmFjZSBJbmZvIHtcbiAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICBvblNlbGVjdD8oZXZlbnQ6IChMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFbGVtZW50PikpOiB2b2lkO1xufVxuXG5cbi8qZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCB7fSwgbmV2ZXI+LCBcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRcIiB8IFwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiPiB7XG4gICAgdXNlTGlzdGJveE11bHRpSXRlbTogVXNlTGlzdGJveE11bHRpSXRlbTxMaXN0SXRlbUVsZW1lbnQ+O1xuICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+O1xuICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsOiAoKSA9PiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxufSovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBsaXN0Ym94TXVsdGk6IHsgdGFnTGFiZWwsIHRhZ0xpc3QgfSxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXG4gICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcbiAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIC4uLnJ0aSB9LFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgLi4udG4gfVxufTogVXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50Pik6IFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50PiB7XG5cbiAgICBkZWJ1Z0xvZyhcInVzZUxpc3Rib3hNdWx0aVwiKTtcblxuICAgIC8vY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzPExpc3RFbGVtZW50Pih7fSk7XG5cbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwgfSA9IHVzZUxhYmVsPExpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHByZWZpeExhYmVsOiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIixcbiAgICAgICAgICAgIHByZWZpeElucHV0OiBcImFyaWEtbGlzdGJveC1cIixcbiAgICAgICAgICAgIHRhZ0xhYmVsOiB0YWdMYWJlbCxcbiAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdMaXN0XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGxpc3RSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+KHtcblxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgLi4ucnRpLFxuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPblRhYmJhYmxlSW5kZXhDaGFuZ2U+KChpKSA9PiB7XG4gICAgICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPy4oaSk7XG4gICAgICAgICAgICAgICAgLyppZiAoc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGNoaWxkcmVuLmdldEF0KGkhKT8uc3ViSW5mby5nZXRFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q/Lih7IHRhcmdldCwgY3VycmVudFRhcmdldDogdGFyZ2V0LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGkhIH0gfSk7XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG5cbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9XG4gICAgfSA9IGxpc3RSZXR1cm5UeXBlXG5cbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wcyB9ID0gdXNlTGFiZWxJbnB1dCgpO1xuXG4gICAgY29uc3QgW2dldFNoaWZ0SGVsZCwgc2V0U2hpZnRIZWxkXSA9IHVzZVBhc3NpdmVTdGF0ZShudWxsLCByZXR1cm5GYWxzZSk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUl0ZW0gPSB1c2VDYWxsYmFjazxVc2VMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudD4+KCh7IGxpc3Rib3hNdWx0aUl0ZW06IHsgc2VsZWN0ZWQsIGRpc2FibGVkLCBvblNlbGVjdGVkQ2hhbmdlIH0sIG1hbmFnZWRDaGlsZCwgbGlzdE5hdmlnYXRpb246IGxzLCByb3ZpbmdUYWJJbmRleDogcnRpLCBoYXNGb2N1cyB9KSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlTGlzdGJveE11bHRpSXRlbVwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgsIHNlbGVjdGVkKTtcbiAgICAgICAgdHlwZSBFID0gTGlzdEl0ZW1FbGVtZW50O1xuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZCA9IHVzZVN0YWJsZUdldHRlcihzZWxlY3RlZCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PEU+KHt9KTtcbiAgICAgICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdGVkQ2hhbmdlID8/ICgoKSA9PiB7IH0pKTtcblxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgbGlzdE5hdmlnYXRpb246IGxzLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4OiBydGksIHN1YkluZm86IHsgc2VsZWN0ZWQsIG9uU2VsZWN0OiBzdGFibGVPblNlbGVjdCB9IH0pO1xuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZ2V0U2hpZnRIZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiB0cnVlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtydGkyX3JldC50YWJiYWJsZV0pO1xuXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcywgbGlzdGJveE11bHRpSXRlbTogeyBnZXRTZWxlY3RlZCwgdGFiYmFibGU6IHJ0aTJfcmV0LnRhYmJhYmxlIH0sIHJvdmluZ1RhYkluZGV4OiBydGkyX3JldCB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG4gICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8RT4oe1xuICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jOiBkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgLi4uZSwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZDogIWdldFNlbGVjdGVkKCkgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGU6IHt9LFxuICAgICAgICAgICAgICAgIGhhc0ZvY3VzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1zZXRzaXplXCJdID0gKGNoaWxkQ291bnQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChydGkyX3JldC50YWJiYWJsZSA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBcInRydWVcIjtcblxuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlUHJlc3NQcm9wcyhwcm9wcykpKTtcbiAgICAgICAgfVxuXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRdKTtcblxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpTGFiZWwoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VMYWJlbExhYmVsKCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlTGFiZWxMYWJlbFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMgfTtcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdGJveE11bHRpSXRlbSxcbiAgICAgICAgdXNlTGlzdGJveE11bHRpUHJvcHMsXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW5cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGlQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IHtcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xuICAgICAgICBwcm9wc1tcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wczxMaXN0RWxlbWVudD4oeyBvbktleURvd24sIG9uS2V5VXAsIG9uZm9jdXNvdXQ6IG9uRm9jdXNPdXQgfSwgcHJvcHMpKSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7IGlmIChlLmtleSA9PSBcIlNoaWZ0XCIpIHNldFNoaWZ0SGVsZCh0cnVlKTsgfVxuICAgIGZ1bmN0aW9uIG9uS2V5VXAoZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQoZmFsc2UpOyB9XG4gICAgZnVuY3Rpb24gb25Gb2N1c091dChfOiBGb2N1c0V2ZW50KSB7IHNldFNoaWZ0SGVsZChmYWxzZSk7IH1cblxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIHdhcm5Pbk92ZXJ3cml0ZSB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VTb2Z0RGlzbWlzcywgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzLCBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLW1vZGFsXCI7XG5cbmludGVyZmFjZSBNU1Age1xuICAgIC8qKlxuICAgICAqIFdoYXQgcm9sZSB0aGUgc3VyZmFjZSBmdWxmaWxscy5cbiAgICAgKiBcbiAgICAgKiBHZW5lcmFsIG1lbnVzIHNob3VsZCB1c2UgXCJtZW51XCIuIFwiZGlhbG9nXCIgY2FuIGJlIHVzZWQgZm9yIGdlbmVyaWMgcG9wLXVwIHRoaW5ncy5cbiAgICAgKi9cbiAgICByb2xlOiBcImRpYWxvZ1wiIHwgXCJtZW51XCIgfCBcInRyZWVcIiB8IFwiZ3JpZFwiIHwgXCJsaXN0Ym94XCI7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoaXMgbWVudSBzdXJmYWNlIGlzIG9wZW5lZCwgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gaXQgbXVzdCBiZSBmb2N1c2VkLlxuICAgICAqIFxuICAgICAqIFRoaXMgY29udHJvbHMgd2hhdCBpcyBmb2N1c2VkIChlLmcuIHRoZSBmaXJzdCBtZW51IGl0ZW0sIHRoZSB3aG9sZSBzdXJmYWNlIGl0c2VsZiwgZXRjLilcbiAgICAgKi9cbiAgICBzZW5kRm9jdXNUb01lbnUoKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgTWVudVN1cmZhY2VPbWl0cyA9IGtleW9mIE1TUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51U3VyZmFjZVBhcmFtZXRlcnM8X1MgZXh0ZW5kcyBFbGVtZW50LCBfQiBleHRlbmRzIEVsZW1lbnQsIE1TTyBleHRlbmRzIE1lbnVTdXJmYWNlT21pdHM+IGV4dGVuZHMgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFwiZ2V0RWxlbWVudHNcIj4ge1xuICAgIG1lbnVTdXJmYWNlOiBPbWl0PE1TUCwgTVNPPjtcbiAgICAvL2hhc0ZvY3VzQnV0dG9uOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Qj47XG4gICAgLy9oYXNGb2N1c1N1cmZhY2U6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxTPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVBhcmFtZXRlcnM8UyBleHRlbmRzIEVsZW1lbnQsIEIgZXh0ZW5kcyBFbGVtZW50LCBNU08gZXh0ZW5kcyBNZW51U3VyZmFjZU9taXRzPiBleHRlbmRzIFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxTLCBCLCBNU08gfCBcInJvbGVcIiB8IFwic2VuZEZvY3VzVG9NZW51XCI+LCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgbWVudToge1xuICAgICAgICBvbk9wZW4oKTogdm9pZDtcblxuICAgICAgICAvLyBDb3JyZXNwb25kcyB0byB3aGF0IGFycm93IGtleSBjYW4gb3BlbiB0aGlzIG1lbnVcbiAgICAgICAgb3BlbkRpcmVjdGlvbjogXCJkb3duXCIgfCBcInVwXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiB8IG51bGw7XG4gICAgfVxuICAgIG1lbnVCdXR0b25IYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEI+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUGFyYW1ldGVycyBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPHt9LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4geyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxfTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xuICAgIG1lbnVTdXJmYWNlOiB7XG4gICAgICAgIC8qZ2V0QnV0dG9uRm9jdXNlZCgpOiBib29sZWFuO1xuICAgICAgICBnZXRCdXR0b25Gb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcbiAgICAgICAgZ2V0QnV0dG9uTGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcbiAgICAgICAgZ2V0QnV0dG9uTGFzdEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xuICAgICAgICBnZXRCdXR0b25FbGVtZW50OiAoKSA9PiBNZW51QnV0dG9uRWxlbWVudCB8IG51bGw7XG4gICAgICAgIGdldFN1cmZhY2VGb2N1c2VkKCk6IGJvb2xlYW47XG4gICAgICAgIGdldFN1cmZhY2VGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcbiAgICAgICAgZ2V0U3VyZmFjZUxhc3RGb2N1c2VkKCk6IGJvb2xlYW47XG4gICAgICAgIGdldFN1cmZhY2VMYXN0Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XG4gICAgICAgIGdldFN1cmZhY2VFbGVtZW50OiAoKSA9PiBNZW51UGFyZW50RWxlbWVudCB8IG51bGw7XG4gICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudDtcbiAgICAgICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjsqL1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9NZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNZW51U3VyZmFjZVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudCwge30sIG5ldmVyPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPG5ldmVyPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZVdpdGhIb29rczxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNZW51U3VyZmFjZVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+IHtcbiAgICB1c2VNZW51U3VyZmFjZVNlbnRpbmVsOiA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VNZW51U2VudGluZWxQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfTtcbiAgICB1c2VNZW51U3VyZmFjZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD47XG4gICAgdXNlTWVudVN1cmZhY2VDaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+OyAgLy8gTk9UIGEgbWVudSBpdGVtISBUaGlzIGlzIHRoZSBtZW51LCBkaWFsb2csIHBvcHVwLCB3aGF0ZXZlciBhY3R1YWxseSBnZXRzIHRoZSByb2xlLCBhcyBvcHBvc2VkIHRvIHRoZSBzdXJmYWNlIHRoYXQgbGlzdGVucyB0byBtb3VzZSBhbmQga2V5Ym9hcmQgZXZlbnRzXG4gICAgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51QnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XG5cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+IHtcbiAgICB1c2VNZW51U2VudGluZWw6IDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9O1xuICAgIHVzZU1lbnVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjtcbiAgICB1c2VNZW51U3VyZmFjZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD47XG4gICAgdXNlTWVudUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+O1xuICAgIHVzZU1lbnVJdGVtOiBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQ+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZU1lbnVCdXR0b25SZXR1cm5UeXBlSW5mbyB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHsgfVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHtcbiAgICB1c2VNZW51SXRlbVByb3BzOiBVc2VNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIFVzZU1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVJdGVtRWxlbWVudD47XG5cbmV4cG9ydCB0eXBlIFVzZU1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZU1lbnVJdGVtUGFyYW1ldGVycykgPT4gVXNlTWVudUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVJdGVtRWxlbWVudD47XG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VNZW51Q2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7fVxuXG4vL2V4cG9ydCB0eXBlIFVzZU1lbnVDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIFVzZU1lbnVDaGlsZEluZm8+ID0gSTtcblxuLyoqXG4gKiBBIG1lbnUgaXMgYSBwb3B1cCBjb250cm9sIHRoYXQgY29udGFpbnMgYSBsaXN0IG9mIG1lbnUgaXRlbXMsIGFuZCB0aGF0J3MgaXQuXG4gKiBJdCBoYXMgdmVyeSB3ZWxsLWRlZmluZWQgbG9naWMgZm9yIG1hbmFnaW5nIHRob3NlIGl0ZW1zIGFzIHRoZSBtZW51J3Mgc3RhdGUgY2hhbmdlcy5cbiAqIFxuICogQSBNZW51QmFzZSBpcyBqdXN0IHRoZSBcInBvcHVwXCIgcGFydCB3aXRob3V0IHRoZSBcImxpc3Qgb2YgbWVudSBpdGVtc1wiIHBhcnQuIEl0IGNhblxuICogKHJlYWxseSwgbXVzdCkgaGF2ZSBpbnRlcmFjdGl2ZSBjb250cm9scywgYnV0IHRoZXNlIGNvbnRyb2xzIGFyZSBhbGxvd2VkIHRvIGJlIG1vcmVcbiAqIGZyZWUtZm9ybS4gVGhpcyBtZWFucyB0aGF0LCBsaWtlIGEgZGlhbG9nLCB5b3UgbXVzdCB0ZWxsIHRoaXMgaG9va1xuICogd2hlcmUgd2l0aGluIHRoZSBwb3B1cCB0byBzZW5kIGZvY3VzIHdoZW4gb3BlbmVkIChmb3IgYSBtZW51IGl0J3MganVzdCB0aGUgZmlyc3RcbiAqIG1lbnUgaXRlbSwgYnV0IHdpdGggY3VzdG9tIGNvbnRlbnQgeW91J2xsIG5lZWQgdG8gcHJvdmlkZSB0aGlzKS5cbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVudVN1cmZhY2U8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgc29mdERpc21pc3MsIG1lbnVTdXJmYWNlOiB7IHNlbmRGb2N1c1RvTWVudSwgcm9sZSB9LCBhY3RpdmVFbGVtZW50IH06IFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBuZXZlcj4pOiBVc2VNZW51U3VyZmFjZVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZU1lbnVTdXJmYWNlXCIpO1xuICAgIC8vY29uc3Qgc2VuZEZvY3VzV2l0aGluTWVudSA9IHVzZVN0YWJsZUNhbGxiYWNrKHNlbmRGb2N1c1RvTWVudSk7XG4gICAgLy9jb25zdCBbZm9jdXNUcmFwQWN0aXZlLCBzZXRGb2N1c1RyYXBBY3RpdmVdID0gdXNlU3RhdGU8bnVsbCB8IGJvb2xlYW4+KG51bGwpO1xuICAgIGNvbnN0IHsgb3Blbiwgb25DbG9zZTogdXNlck9uQ2xvc2UgfSA9IHNvZnREaXNtaXNzO1xuICAgIGNvbnN0IG9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjazx0eXBlb2YgdXNlck9uQ2xvc2U+KChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHJlYXNvbiAhPSBcImxvc3QtZm9jdXNcIikge1xuICAgICAgICAgICAgY29uc3Qgb3BlbmVyID0gKGdldE9wZW5lckVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudCB8IG51bGwpO1xuICAgICAgICAgICAgaWYgKG9wZW5lciAmJiBcImZvY3VzXCIgaW4gb3BlbmVyKVxuICAgICAgICAgICAgICAgIG9wZW5lci5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZXJPbkNsb3NlKHJlYXNvbik7XG4gICAgfSlcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNZW51U3VyZmFjZVwiLCBvbkNsb3NlLCByb2xlLCBzZW5kRm9jdXNUb01lbnUpO1xuICAgIGNvbnN0IGdldElzT3BlbiA9IHVzZVN0YWJsZUdldHRlcihvcGVuKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IHVzZVJlZjxJbnRlcnNlY3Rpb25PYnNlcnZlcj4obnVsbCEpO1xuICAgIGNvbnN0IFtnZXRTdXJmYWNlRnVsbHlWaXNpYmxlLCBzZXRTdXJmYWNlRnVsbHlWaXNpYmxlXSA9IHVzZVBhc3NpdmVTdGF0ZShudWxsLCByZXR1cm5GYWxzZSk7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuY3VycmVudCA/Pz0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBfb2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICBzZXRTdXJmYWNlRnVsbHlWaXNpYmxlKGVudHJ5LmludGVyc2VjdGlvblJhdGlvID49IDEpO1xuICAgICAgICB9XG4gICAgfSwgeyByb290OiBudWxsLCB0aHJlc2hvbGQ6IFswLCAxXSB9KTtcblxuICAgIGNvbnN0IFssIHNldE9wZW5lckVsZW1lbnQsIGdldE9wZW5lckVsZW1lbnRdID0gdXNlU3RhdGU8TWVudUJ1dHRvbkVsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICAgIC8vY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzOiB1c2VNZW51QmFzZUhhc0ZvY3VzUHJvcHMsIC4uLnN1cmZhY2VIYXNGb2N1cyB9ID0gdXNlSGFzRm9jdXM8TWVudVN1cmZhY2VFbGVtZW50Pih7IC4uLmhhc0ZvY3VzU3VyZmFjZSB9KTtcbiAgICAvL2NvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlQnV0dG9uSGFzRm9jdXNQcm9wcywgLi4uYnV0dG9uSGFzRm9jdXMgfSA9IHVzZUhhc0ZvY3VzPE1lbnVCdXR0b25FbGVtZW50Pih7IC4uLmhhc0ZvY3VzQnV0dG9uIH0pO1xuXG4gICAgLy9jb25zdCB7IGdldExhc3RGb2N1c2VkSW5uZXI6IGdldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lciB9ID0gc3VyZmFjZUhhc0ZvY3VzO1xuXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPE1lbnVQYXJlbnRFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1lbnUtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9KTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxNZW51QnV0dG9uRWxlbWVudD4oXCJhcmlhLWNvbnRyb2xzXCIgYXMgbmV2ZXIpO1xuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRCdXR0b25FbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJ1dHRvblJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxNZW51QnV0dG9uRWxlbWVudD4oeyBvbkVsZW1lbnRDaGFuZ2U6IHNldE9wZW5lckVsZW1lbnQgfSk7XG5cbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldE1lbnVFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PE1lbnVTdXJmYWNlRWxlbWVudD4oe30pO1xuICAgIGNvbnN0IHsgdXNlU29mdERpc21pc3NQcm9wcywgLi4uc29mdERpc21pc3NSZXR1cm4gfSA9IHVzZVNvZnREaXNtaXNzPGFueT4oe1xuICAgICAgICBzb2Z0RGlzbWlzczoge1xuICAgICAgICAgICAgLi4uc29mdERpc21pc3MsXG4gICAgICAgICAgICBnZXRFbGVtZW50czogKCkgPT4gKFtnZXRCdXR0b25FbGVtZW50KCksIGdldE1lbnVFbGVtZW50KCldKSxcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB1c2VNZW51U3VyZmFjZVByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PiA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuID0gZ2V0SXNPcGVuKCk7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT0gXCJFc2NhcGVcIiAmJiBvcGVuKSB7XG4gICAgICAgICAgICAgICAgb25DbG9zZShcImVzY2FwZVwiKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVzZVNvZnREaXNtaXNzUHJvcHMoKHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzKCh1c2VNZXJnZWRQcm9wczxNZW51U3VyZmFjZUVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIChwcm9wcykpKSkpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+ID0+IHtcbiAgICAgICAgcHJvcHNbXCJhcmlhLWV4cGFuZGVkXCJdID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wc1wiLCBcImFyaWEtZXhwYW5kZWRcIiwgb3Blbiwgb3Blbi50b1N0cmluZygpKTtcbiAgICAgICAgcHJvcHNbXCJhcmlhLWhhc3BvcHVwXCJdID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wc1wiLCBcImFyaWEtaGFzcG9wdXBcIiwgcm9sZSwgcm9sZSk7XG4gICAgICAgIHJldHVybiB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMoKHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhwcm9wcykpKTtcbiAgICB9O1xuXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgIGlmIChvcGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZW5kRm9jdXNUb01lbnU/LigpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFnZXRTdXJmYWNlRnVsbHlWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TWVudUVsZW1lbnQoKT8uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSwgW29wZW5dKTtcblxuICAgIGZ1bmN0aW9uIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+IHtcbiAgICAgICAgcHJvcHMucm9sZSA9IHJvbGU7XG4gICAgICAgIHJldHVybiB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWVudVN1cmZhY2VDaGlsZFByb3BzLFxuICAgICAgICB1c2VNZW51U3VyZmFjZVNlbnRpbmVsOiB1c2VDYWxsYmFjayg8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4ge1xuICAgICAgICAgICAgZGVidWdMb2coXCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsXCIpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHVzZVNlbnRpbmVsUHJvcHM6IHVzZU1lbnVTZW50aW5lbFByb3BzLFxuICAgICAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICAgIH0gPSB1c2VGb2N1c1NlbnRpbmVsPEU+KHtcbiAgICAgICAgICAgICAgICBmb2N1c1NlbnRpbmVsOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW46IG9wZW4gPT09IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U6ICgpID0+IG9uQ2xvc2UoXCJlc2NhcGVcIiksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRGb2N1c1RvTWVudVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXNlTWVudVNlbnRpbmVsUHJvcHMsIC4uLnJlc3QgfTtcbiAgICAgICAgfSwgW29wZW4sIG9uQ2xvc2VdKSxcbiAgICAgICAgdXNlTWVudVN1cmZhY2VQcm9wcyxcbiAgICAgICAgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyxcbiAgICAgICAgbWVudVN1cmZhY2U6IHtcbiAgICAgICAgICAgIC8qZ2V0QWN0aXZlRWxlbWVudDogYnV0dG9uSGFzRm9jdXMuZ2V0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiBidXR0b25IYXNGb2N1cy5nZXRMYXN0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIGdldEJ1dHRvbkVsZW1lbnQ6IGJ1dHRvbkhhc0ZvY3VzLmdldEVsZW1lbnQsXG4gICAgICAgICAgICBnZXRCdXR0b25Gb2N1c2VkOiBidXR0b25IYXNGb2N1cy5nZXRGb2N1c2VkLFxuICAgICAgICAgICAgZ2V0QnV0dG9uRm9jdXNlZElubmVyOiBidXR0b25IYXNGb2N1cy5nZXRGb2N1c2VkSW5uZXIsXG4gICAgICAgICAgICBnZXRCdXR0b25MYXN0Rm9jdXNlZDogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEZvY3VzZWQsXG4gICAgICAgICAgICBnZXRCdXR0b25MYXN0Rm9jdXNlZElubmVyOiBidXR0b25IYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZElubmVyLFxuICAgICAgICAgICAgZ2V0U3VyZmFjZUVsZW1lbnQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRFbGVtZW50LFxuICAgICAgICAgICAgZ2V0U3VyZmFjZUZvY3VzZWQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRGb2N1c2VkLFxuICAgICAgICAgICAgZ2V0U3VyZmFjZUZvY3VzZWRJbm5lcjogc3VyZmFjZUhhc0ZvY3VzLmdldEZvY3VzZWRJbm5lcixcbiAgICAgICAgICAgIGdldFN1cmZhY2VMYXN0Rm9jdXNlZDogc3VyZmFjZUhhc0ZvY3VzLmdldExhc3RGb2N1c2VkLFxuICAgICAgICAgICAgZ2V0U3VyZmFjZUxhc3RGb2N1c2VkSW5uZXI6IHN1cmZhY2VIYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZElubmVyLFxuICAgICAgICAgICAgZ2V0V2luZG93Rm9jdXNlZDogYnV0dG9uSGFzRm9jdXMuZ2V0V2luZG93Rm9jdXNlZCwqL1xuICAgICAgICB9LFxuICAgICAgICAuLi5zb2Z0RGlzbWlzc1JldHVyblxuXG4gICAgICAgIC8vZ2V0TWVudUJhc2VMYXN0Rm9jdXNlZElubmVyLFxuICAgICAgICAvL2dldE1lbnVCYXNlQnV0dG9uTGFzdEZvY3VzZWRJbm5lcixcbiAgICAgICAgLy9vcGVuLFxuICAgICAgICAvL29uT3BlbixcbiAgICAgICAgLy9vbkNsb3NlXG4gICAgfVxufVxuXG5pbnRlcmZhY2UgRlNQIGV4dGVuZHMgTVNQIHtcbiAgICBvcGVuOiBib29sZWFuO1xuICAgIG9uQ2xvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgRm9jdXNTZW50aW5lbE9taXRzID0ga2V5b2YgRlNQO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzU2VudGluZWxQYXJhbWV0ZXJzIHtcbiAgICBmb2N1c1NlbnRpbmVsOiB7IHNlbmRGb2N1c1RvTWVudTogTVNQW1wic2VuZEZvY3VzVG9NZW51XCJdOyBvcGVuOiBib29sZWFuOyBvbkNsb3NlKCk6IHZvaWQ7IH07XG59XG5cblxuLy8gQSBmb2N1cyBzZW50aW5hbCBpcyBhIGhpZGRlbiBidXQgZm9jdXNhYmxlIGVsZW1lbnQgdGhhdCBjb21lcyBhdCB0aGUgc3RhcnQgb3IgZW5kIFxuLy8gb2YgdGhlIG91dC1vZi1wbGFjZS1mb2N1c2FibGUgY29tcG9uZW50IHRoYXQsIHdoZW4gYWN0aXZhdGVkIG9yIGZvY3VzZWQgb3ZlciwgY2xvc2VzIHRoZSBjb21wb25lbnRcbi8vIChpZiBmb2N1c2VkIHdpdGhpbiAxMDBtcyBvZiB0aGUgb3BlbiBwcm9wIGNoYW5naW5nLCBpbnN0ZWFkIG9mXG4vLyBjbG9zaW5nLCBmb2N1c2luZyB0aGUgc2VudGluZWwgaW1tZWRpYXRlbHkgYXNrcyBpdCB0byBmb2N1cyBpdHNlbGYpLlxuLy8gVGhpcyBleGlzdHMgZm9yIHRoaW5ncyBsaWtlIG1lbnVzIHdoaWNoIGNhbiBoYXZlIGZvY3VzIGJ1dCBhbHNvIG5lZWQgYSB3YXkgdG8gcmV0dXJuXG4vLyB0byB3aGF0ZXZlciBvdXQtb2YtcGxhY2UgcGFyZW50IHRoZXkgY2FtZSBmcm9tIHdoZW4gbmF0dXJhbGx5IHRhYmJlZCBvdXQgb2YgKGFzIG9wcG9zZWRcbi8vIHRvIGRpYWxvZ3Mgd2hpY2ggbG9vcCBiYWNrIGFyb3VuZCB3aGVuIHRhYmJlZCBvdXQgb2YpLiBXaGlsZSBtb3VzZSB1c2VycyBjYW4gY2xpY2sgb3V0IG9mIGEgbWVudVxuLy8gYW5kIGtleWJvYXJkIHVzZXJzIGNhbiBlc2NhcGUgdG8gY2xvc2UgYSBtZW51LCBzY3JlZW4gcmVhZGVycyBhbmQgb3RoZXIgaW5wdXQgbWV0aG9kcyBcbi8vIHRoYXQgZG9uJ3QgdXNlIHRob3NlIHR3byB3b3VsZCBiZWNvbWUgc3R1Y2suXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNTZW50aW5lbDxFIGV4dGVuZHMgRWxlbWVudD4oeyBmb2N1c1NlbnRpbmVsOiB7IG9wZW4sIG9uQ2xvc2UsIHNlbmRGb2N1c1RvTWVudSB9IH06IFVzZUZvY3VzU2VudGluZWxQYXJhbWV0ZXJzKSB7XG4gICAgZGVidWdMb2coXCJ1c2VGb2N1c1NlbnRpbmVsXCIpO1xuICAgIGNvbnN0IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVHZXR0ZXIoc2VuZEZvY3VzVG9NZW51KTtcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSk7XG5cbiAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmUob3Blbik7IH0sIHRpbWVvdXQ6IDEwMCwgdHJpZ2dlckluZGV4OiBgJHtvcGVufS0ke2ZpcnN0U2VudGluZWxJc0FjdGl2ZX1gIH0pO1xuXG5cbiAgICBjb25zdCBvbkZvY3VzID0gZmlyc3RTZW50aW5lbElzQWN0aXZlID8gKCgpID0+IHN0YWJsZU9uQ2xvc2UoKSkgOiAoKCkgPT4gZ2V0U2VuZEZvY3VzV2l0aGluTWVudSgpPy4oKSk7XG4gICAgY29uc3Qgb25DbGljayA9ICgpID0+IHN0YWJsZU9uQ2xvc2UoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNlbnRpbmVsUHJvcHM6IGZ1bmN0aW9uICh7IHRhYkluZGV4LCAuLi5wIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHsgb25Gb2N1cywgb25DbGljaywgdGFiSW5kZXg6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUZvY3VzU2VudGluZWxcIiwgXCJ0YWJJbmRleFwiLCB0YWJJbmRleCwgMCkgfSwgcCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51PE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1lbnVCdXR0b25IYXNGb2N1cywgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbiwgbWVudVN1cmZhY2UsIHJvdmluZ1RhYkluZGV4LCBzb2Z0RGlzbWlzcywgdHlwZWFoZWFkTmF2aWdhdGlvbiwgbWVudSwgYWN0aXZlRWxlbWVudCB9OiBVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBuZXZlcj4pOiBVc2VNZW51UmV0dXJuVHlwZVdpdGhIb29rczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiB7XG5cbiAgICBkZWJ1Z0xvZyhcInVzZU1lbnVcIik7XG4gICAgY29uc3QgeyBvbk9wZW4gfSA9IG1lbnU7XG4gICAgY29uc3QgeyBvcGVuLCBvbkNsb3NlIH0gPSBzb2Z0RGlzbWlzcztcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4udXNlTGlzdE5hdlJldHVyblxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCB7fSwgc3RyaW5nPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSB1c2VMaXN0TmF2UmV0dXJuO1xuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIC8qdXNlTWVudVNlbnRpbmVsLFxuICAgICAgICB1c2VNZW51QmFzZUJ1dHRvblByb3BzLFxuICAgICAgICB1c2VNZW51QmFzZVByb3BzLFxuICAgICAgICBvcGVuLFxuICAgICAgICBvbk9wZW4sXG4gICAgICAgIG9uQ2xvc2U6IF9vbkNsb3NlLCovXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMsXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlUHJvcHMsXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlU2VudGluZWwsXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyxcbiAgICAgICAgLi4ubWVudVJlc3RcbiAgICB9ID0gdXNlTWVudVN1cmZhY2U8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+KHtcbiAgICAgICAgbWVudVN1cmZhY2U6IHtcbiAgICAgICAgICAgIC4uLm1lbnVTdXJmYWNlLFxuICAgICAgICAgICAgcm9sZTogXCJtZW51XCIsXG4gICAgICAgICAgICBzZW5kRm9jdXNUb01lbnU6IHVzZUNhbGxiYWNrKCgpID0+IGNoaWxkcmVuLmdldEF0KDApPy5zdWJJbmZvLmZvY3VzU2VsZigpLCBbXSlcbiAgICAgICAgfSxcbiAgICAgICAgc29mdERpc21pc3MsXG4gICAgICAgIC8vaGFzRm9jdXNCdXR0b24sXG4gICAgICAgIC8vaGFzRm9jdXNTdXJmYWNlLFxuICAgICAgICBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vc2VuZEZvY3VzV2l0aGluTWVudTogZm9jdXNNZW51ID8/ICgoKSA9PiB7IH0pXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VNZW51QnV0dG9uUHJvcHMgPSAoKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4ge1xuICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8TWVudUJ1dHRvbkVsZW1lbnQ+KHtcbiAgICAgICAgICAgIG9uQ2xpY2tTeW5jOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW4pXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U/LihcImVzY2FwZVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uT3Blbj8uKCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIGV4Y2x1ZGU6IHt9LFxuICAgICAgICAgICAgaGFzRm9jdXM6IG1lbnVCdXR0b25IYXNGb2N1c1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzKHApO1xuICAgICAgICByZXR1cm4gdXNlUHJlc3NQcm9wcyhwcm9wcyk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VNZW51SXRlbSA9IHVzZUNhbGxiYWNrPFVzZU1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4IH0pID0+IHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VNZW51SXRlbVwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuXG4gICAgICAgIHR5cGUgRSA9IE1lbnVJdGVtRWxlbWVudDtcblxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdE5hdlJldCB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvOiB7fSB9KTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VNZW51SXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oeyAuLi5wcm9wcyB9OiBQKSB7XG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJtZW51aXRlbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHt9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLmxpc3ROYXZSZXQgfTtcbiAgICB9LCBbXSk7XG5cblxuICAgIGZ1bmN0aW9uIHVzZU1lbnVQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyhwcm9wcykpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWVudVByb3BzLFxuICAgICAgICB1c2VNZW51U3VyZmFjZVByb3BzLFxuXG4gICAgICAgIHVzZU1lbnVCdXR0b25Qcm9wcyxcblxuICAgICAgICB1c2VNZW51SXRlbSxcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsOiB1c2VNZW51U3VyZmFjZVNlbnRpbmVsLFxuICAgICAgICAvL3VzZU1lbnVTdWJtZW51SXRlbSxcbiAgICAgICAgLi4udXNlTGlzdE5hdlJldHVybixcbiAgICAgICAgLi4ubWVudVJlc3RcblxuICAgICAgICAvKmZvY3VzTWVudSxcblxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbiwqL1xuXG5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkLCByZXR1cm5UcnVlLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgdXNlTWFuYWdlZENoaWxkcmVuLCB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtaGFzLWZvY3VzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVGFic0NoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFbGVtZW50PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJzUGFyYW1ldGVycyB7XHJcbiAgICB0YWJQYW5lbHM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj47XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7XHJcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCB7fSwgXCJ2aXNpYmxlXCIsIFwic3ViSW5mb1wiPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+IHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4ge1xyXG4gICAgdXNlVGFiUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGFiZWxQYXJhbWV0ZXJzIHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIgfCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIHRhYnM6IHsgb25TZWxlY3RlZEluZGV4Q2hhbmdlKGU6IEVuaGFuY2VkRXZlbnQ8VGFiRWxlbWVudCwgRXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0+KTogdm9pZDsgfTtcclxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXTtcclxuXHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHRhYkxpc3Q6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCwgVGFiSW5mbywgbmV2ZXI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGlzdFJldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiB7XHJcbiAgICB1c2VUYWJMaXN0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiQ29udGFpbmVyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkNvbnRhaW5lckVsZW1lbnQ+O1xyXG4gICAgdXNlVGFiOiAoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCB9OiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KSA9PiBVc2VUYWJSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkVsZW1lbnQ+XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdGFiUGFuZWw6IHsgdmlzaWJsZTogYm9vbGVhbjsgZ2V0VmlzaWJsZTogKCkgPT4gYm9vbGVhbjsgfTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlVGFiUGFuZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMaXN0TGFiZWxSZXR1cm5UeXBlSW5mbyB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJMaXN0TGFiZWxSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUYWJMaXN0TGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYnNSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB0YWJQYW5lbHM6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVGFiUGFuZWxJbmZvLCBuZXZlcj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYnNSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUYWJMaXN0OiBVc2VUYWJMaXN0PFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQ+O1xyXG4gICAgdXNlVGFiUGFuZWw6IFVzZVRhYlBhbmVsPFBhbmVsRWxlbWVudD47XHJcbiAgICB1c2VUYWJMaXN0TGFiZWw6IFVzZVRhYkxpc3RMYWJlbDxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VUYWI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4pID0+IFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYkxpc3Q8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PikgPT4gVXNlVGFiTGlzdFJldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYlBhbmVsPFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRhYlBhbmVsUGFyYW1ldGVycykgPT4gVXNlVGFiUGFuZWxSZXR1cm5UeXBlV2l0aEhvb2tzPFBhbmVsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYkxpc3RMYWJlbDxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUYWJMYWJlbFBhcmFtZXRlcnMpID0+IFVzZVRhYkxhYmVsUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQ+O1xyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFiczxUYWJMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhYlBhbmVsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4gfSB9IH06IFVzZVRhYnNQYXJhbWV0ZXJzKTogVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcbiAgICBjb25zdCB7IFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsIFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMgXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm8sIG5ldmVyPih7IFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7fSwgXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sIFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSwgXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7fSwgXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHt9LCBcclxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHt9LCBcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fVxyXG4gICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYiA9IHVzZUNhbGxiYWNrKCgpID0+IHt9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VUYWJQYW5lbCA9IHVzZUNhbGxiYWNrKCgpID0+IHt9KTtcclxuICAgIGZ1bmN0aW9uIHVzZVRhYkxpc3RQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiTGlzdEVsZW1lbnQ+KSB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHByb3BzKTsgfVxyXG4gICAgZnVuY3Rpb24gdXNlVGFiTGFiZWxQcm9wcygpIHt9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICB9XHJcbiAgICBcclxufSovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFiczxUYWJMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhYlBhbmVsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4gfSB9IH06IFVzZVRhYnNQYXJhbWV0ZXJzKTogVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcblxyXG4gICAgZGVidWdMb2coXCJ1c2VUYWJzXCIpO1xyXG5cclxuXHJcbiAgICBjb25zdCBiYXNlSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwiYXJpYS10YWJzLVwiKTtcclxuICAgIC8vY29uc3QgZ2V0VGFiTGlzdElkID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLWxpc3RcIjsgfSwgW10pO1xyXG4gICAgY29uc3QgZ2V0VGFiSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLVwiICsgaW5kZXg7IH0sIFtdKTtcclxuICAgIGNvbnN0IGdldFBhbmVsSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItcGFuZWwtXCIgKyBpbmRleDsgfSwgW10pO1xyXG5cclxuICAgIC8vIFVzZWQgZm9yIHRoZSBwYW5lbHMsIG5vdCB0aGUgdGFicyBpbiB0aGUgdGFibGlzdC5cclxuICAgIC8vIFRob3NlIGFyZSBpbiB1c2VUYWJMaXN0IGl0c2VsZi5cclxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkLCAuLi5tYW5hZ2VkQ2hpbGRyZW5SZXQgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFRhYlBhbmVsSW5mbywgXCJ2aXNpYmxlXCI+KHsgbWFuYWdlZENoaWxkcmVuOiB7IC4uLnRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG0sIHUpID0+IHsgb2NtYz8uKG0sIHUpOyByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpOyB9KSB9IH0pO1xyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVmlzaWJsZVBhbmVsLCBnZXRDdXJyZW50SW5kZXg6IGdldFZpc2libGVJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZyh7IGNoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW5SZXQubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiBmYWxzZSwgaW5pdGlhbEluZGV4OiBudWxsLCBrZXk6IFwidmlzaWJsZVwiIH0pO1xyXG5cclxuICAgIC8vY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50LCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkKHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtdGFicy1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwgfSA9IHVzZUxhYmVsPFRhYkxpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgbGFiZWw6IHsgcHJlZml4SW5wdXQ6IFwiXCIsIHByZWZpeExhYmVsOiBcIlwiLCB0YWdJbnB1dDogXCJkaXZcIiBhcyBhbnksIHRhZ0xhYmVsOiBcImRpdlwiIGFzIGFueSB9IH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VUYWJMaXN0TGFiZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VUYWJMaXN0TGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgeyByZXR1cm4gdXNlTGFiZWxMYWJlbFByb3BzKHByb3BzKTsgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYkxpc3RMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYkxpc3QgPSB1c2VDYWxsYmFjazxVc2VUYWJMaXN0PFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50Pj4oKHsgY2hpbGRyZW5IYXZlRm9jdXMsIHRhYnM6IHsgb25TZWxlY3RlZEluZGV4Q2hhbmdlIH0sIGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW46IHRhYkxpc3RNYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24gfSkgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlVGFiTGlzdFwiKTtcclxuICAgICAgICBjb25zdCBzdGFibGVPblNlbGVjdGVkSW5kZXhDaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdGVkSW5kZXhDaGFuZ2UpO1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXHJcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgICAgIC4uLmxpc3ROYXZSZXQxXHJcbiAgICAgICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJJbmZvLCBuZXZlcj4oe1xyXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB0YWJMaXN0TWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5zaW5nbGVTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChldmVudDogRXZlbnQsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U/LihlbmhhbmNlRXZlbnQ8VGFiRWxlbWVudCwgRXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0+KGV2ZW50LCB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0pKVxyXG4gICAgICAgICAgICAgICAgfSwgW10pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNoYW5nZVZpc2libGVQYW5lbChzaW5nbGVTZWxlY3Rpb24uc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgfSwgW3NpbmdsZVNlbGVjdGlvbi5zZWxlY3RlZEluZGV4XSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VMYWJlbElucHV0KClcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFiID0gdXNlQ2FsbGJhY2s8VXNlVGFiPFRhYkVsZW1lbnQ+PigoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgaGFzRm9jdXMgfTogVXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50Pik6IFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYlwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdE5hdlJldDIgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbzoge30sIGhhc0ZvY3VzIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB7IHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZCB9LCByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9IH0gPSBsaXN0TmF2UmV0MjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVRhYlByb3BzID0gKHsgcm9sZSwgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scywgXCJhcmlhLXNlbGVjdGVkXCI6IGFyaWFTZWxlY3RlZCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsSWQgPSBnZXRQYW5lbElkKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJJZCA9IGdldFRhYklkKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlUHJlc3NQcm9wcyA9IHVzZVByZXNzPFRhYkVsZW1lbnQ+KHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrU3luYzogKGUpID0+IHsgc3RhYmxlT25TZWxlY3RlZEluZGV4Q2hhbmdlKGVuaGFuY2VFdmVudChlLCB7IHNlbGVjdGVkSW5kZXg6IG1hbmFnZWRDaGlsZC5pbmRleCB9KSkgfSxcclxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBoYXNGb2N1c1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyh1c2VNZXJnZWRQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiXCIsIFwicm9sZVwiLCByb2xlLCBcInRhYlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiXCIsIFwiYXJpYUNvbnRyb2xzXCIsIGFyaWFDb250cm9scywgcGFuZWxJZCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXNlbGVjdGVkXCI6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYlwiLCBcImFyaWFTZWxlY3RlZFwiLCBhcmlhU2VsZWN0ZWQsIHNlbGVjdGVkID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YS10YWJiYWJsZVwiOiB0YWJiYWJsZS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YWJJZFxyXG4gICAgICAgICAgICAgICAgfSBhcyB7fSwgdXNlUHJlc3NQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZVRhYlByb3BzLFxyXG4gICAgICAgICAgICAgICAgLi4ubGlzdE5hdlJldDJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt1c2VMYWJlbElucHV0LCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYkxpc3RQcm9wcyA9ICh7IHJvbGUsIFwiYXJpYS1vcmllbnRhdGlvblwiOiBhcmlhT3JpZW50YXRpb24sIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkxpc3RFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh1c2VMYWJlbElucHV0UHJvcHModXNlTWVyZ2VkUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgcm9sZTogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiTGlzdFwiLCBcInJvbGVcIiwgcm9sZSwgXCJ0YWJsaXN0XCIpLFxyXG4gICAgICAgICAgICAgICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IGFyaWFPcmllbnRhdGlvbiA/PyBcImhvcml6b250YWxcIixcclxuICAgICAgICAgICAgfSBhcyB7fSxcclxuICAgICAgICAgICAgICAgIHByb3BzKSkpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGFiTGlzdDogbGlzdE5hdlJldDEsXHJcbiAgICAgICAgICAgIHVzZVRhYkxpc3RQcm9wcyxcclxuICAgICAgICAgICAgdXNlVGFiXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUxhYmVsSW5wdXRdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUYWJQYW5lbCA9IHVzZUNhbGxiYWNrKCh7IG1hbmFnZWRDaGlsZDogeyBmbGFncywgLi4ubWFuYWdlZENoaWxkIH0gfTogVXNlVGFiUGFuZWxQYXJhbWV0ZXJzKSA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VUYWJQYW5lbFwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgIC8vY29uc3QgW2NvcnJlc3BvbmRpbmdUYWJJZCwgc2V0Q29ycmVzcG9uZGluZ1RhYklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgIGNvbnN0IFtpc1Zpc2libGUsIHNldElzVmlzaWJsZSwgZ2V0SXNWaXNpYmxlXSA9IHVzZVN0YXRlKGdldFZpc2libGVJbmRleCgpID09IG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZVJlZiA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0SXNWaXNpYmxlLCBzZXQ6IHNldElzVmlzaWJsZSwgaXNWYWxpZDogcmV0dXJuVHJ1ZSB9KTtcclxuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgLi4ubWFuYWdlZENoaWxkLCBmbGFnczogeyB2aXNpYmxlOiB2aXNpYmxlUmVmLmN1cnJlbnQsIC4uLmZsYWdzIH0sIHN1YkluZm86IHt9IH0gfSk7XHJcbiAgICAgICAgY29uc3QgcGFuZWxJZCA9IGdldFBhbmVsSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICBjb25zdCB0YWJJZCA9IGdldFRhYklkKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYlBhbmVsUHJvcHMgPSAoeyByb2xlLCBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSwgaWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhbmVsRWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKHtcclxuICAgICAgICAgICAgICAgIHJvbGU6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYlBhbmVsUHJvcHNcIiwgXCJyb2xlXCIsIHJvbGUsIFwidGFicGFuZWxcIiksXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJQYW5lbFByb3BzXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGFyaWFMYWJlbGxlZEJ5LCB0YWJJZCksXHJcbiAgICAgICAgICAgICAgICBpZDogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiUGFuZWxQcm9wc1wiLCBcImlkXCIsIGlkLCBwYW5lbElkKVxyXG4gICAgICAgICAgICB9IGFzIHt9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VUYWJQYW5lbFByb3BzLFxyXG4gICAgICAgICAgICB0YWJQYW5lbDoge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogaXNWaXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VmlzaWJsZTogZ2V0SXNWaXNpYmxlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VUYWJMaXN0TGFiZWwsXHJcbiAgICAgICAgdXNlVGFiTGlzdCxcclxuICAgICAgICB1c2VUYWJQYW5lbCxcclxuICAgICAgICB0YWJQYW5lbHM6IG1hbmFnZWRDaGlsZHJlblJldFxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuaW50ZXJmYWNlIFRhYlBhbmVsSW5mbyB7XHJcbiAgICAvL3NldENvcnJlc3BvbmRpbmdUYWJJZCh0YWJJZDogc3RyaW5nKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRhYkluZm8ge1xyXG4gICAgLy9zZXRDb3JyZXNwb25kaW5nUGFuZWxJZCh0YWJJZDogc3RyaW5nKTogdm9pZDtcclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciwgdXNlSGFzRm9jdXMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmFuZG9tSWQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2cgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5leHBvcnQgdHlwZSBVc2VUb29sdGlwVHJpZ2dlcjxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUcmlnZ2VyVHlwZT4gfSkgPT4geyB1c2VUb29sdGlwVHJpZ2dlclByb3BzOiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPiB9O1xuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUGFyYW1ldGVycyB7IG1vdXNlb3ZlckRlbGF5PzogbnVtYmVyLCBtb3VzZW91dFRvbGVyYW5jZURlbGF5PzogbnVtYmVyLCBmb2N1c0RlbGF5PzogbnVtYmVyIH1cbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVG9vbHRpcFBhcmFtZXRlcnMpID0+IFVzZVRvb2x0aXBSZXR1cm5UeXBlV2l0aEhvb2tzPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbyB7XG4gICAgaXNPcGVuOiBib29sZWFuO1xuICAgIGdldElzT3BlbjogKCkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUmV0dXJuVHlwZVdpdGhIb29rczxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIHtcbiAgICB1c2VUb29sdGlwUG9wdXA6IChhcmdzOiB7IGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8UG9wdXBUeXBlPiB9KSA9PiB7XG4gICAgICAgIHVzZVRvb2x0aXBQb3B1cFByb3BzOiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxQb3B1cFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQb3B1cFR5cGU+O1xuICAgIH07XG4gICAgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPjtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVG9vbHRpcDxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgbW91c2VvdmVyRGVsYXksIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXksIGZvY3VzRGVsYXkgfTogVXNlVG9vbHRpcFBhcmFtZXRlcnMpOiBVc2VUb29sdGlwUmV0dXJuVHlwZVdpdGhIb29rczxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPiB7XG4gICAgZGVidWdMb2coXCJ1c2VUb29sdGlwXCIpO1xuXG4gICAgbW91c2VvdmVyRGVsYXkgPz89IDQwMDtcbiAgICBtb3VzZW91dFRvbGVyYW5jZURlbGF5ID8/PSA1MDA7XG4gICAgZm9jdXNEZWxheSA/Pz0gMTtcblxuICAgIC8vIFRoZSBlc2NhcGUga2V5IHNob3VsZCBjbG9zZSB0b29sdGlwcywgYnV0IGRvIG5vdGhpbmcgZWxzZS5cbiAgICAvLyAoaS5lLiBjbG9zaW5nIGEgdG9vbHRpcCBpbiBhIGRpYWxvZyBNVVNUIE5PVCBjbG9zZSB0aGUgZGlhbG9nIHRvbylcbiAgICAvLyBUT0RPOiBUb29sdGlwcyBhcmUsIGVmZmVjdGl2ZWx5LCBhbHdheXMgdGhlIHRvcG1vc3QgY29tcG9uZW50LFxuICAgIC8vIHNvIHdlIGNhbiBqdXN0IGhhdmUgdGhlbSBsaXN0ZW4gdG8gYW5kIHN3YWxsb3cgYWxsIFwiRXNjYXBlXCJcbiAgICAvLyBrZXkgcHJlc3NlcyBiZWZvcmUgYW55b25lIGVsc2UuIEZvciBhIG1vcmUgZ2VuZXJhbCBwb3B1cCxcbiAgICAvLyBvciBhIHRvb2x0aXAgaW4gYSB0b29sdGlwICghISkgYSBkaWZmZXJlbnQgc29sdXRpb24gd291bGQgYmUgbmVlZGVkLlxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwia2V5ZG93blwiLCAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZ2V0T3BlbigpICYmIGUua2V5ID09PSBcIkVzY2FwZVwiICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBzZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW4sIGdldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsLy86IHVzZVRvb2x0aXBJZFByb3BzLCBcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwvLzogdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyBcbiAgICB9ID0gdXNlUmFuZG9tSWQ8UG9wdXBUeXBlPih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLXRvb2x0aXAtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG5cbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VyRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDEpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IG9uSG92ZXJDaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiBvbkhvdmVyQ2hhbmdlKGhvdmVyaW5nOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChob3ZlcmluZykge1xuICAgICAgICAgICAgc3dpdGNoIChob3ZlclN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhpZGluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGhvdmluZyBvdmVyIHRoZSB0b29sdGlwIHJpZ2h0IGFmdGVyIGhvdmVyaW5nIGF3YXkgZnJvbSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzaG93IGl0IGFnYWluIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJzaG93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdG9vbHRpcCBpc24ndCBzaG93aW5nIGFuZCBoYXNuJ3QgZm9yIGF3aGlsZSAoaWYgZXZlcilcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3Igb3VyIG1vdXNlb3ZlciBkZWxheVxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwic2hvd2luZzJcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4geyBjb25zb2xlLmxvZyhcInNldEhvdmVyU3RhdGUoc2hvd24pXCIpOyAgc2V0SG92ZXJTdGF0ZShcInNob3duXCIpIH0sIG1vdXNlb3ZlckRlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChob3ZlclN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNob3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSB0cmlnZ2VyLCBidXQgZGVsYXkgdHJ1bHkgaGlkaW5nIGl0IGZvciBhIG1vbWVudFxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwiaGlkaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHsgY29uc29sZS5sb2coXCJzZXRIb3ZlclN0YXRlKGhpZGRlbilcIik7IHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7fSwgbW91c2VvdmVyRGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInNob3dpbmcyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHVyaW5nIGEgbW91c2VvdmVyIGRlbGF5LCB3aGVuIHdlIG1vdXNlb3V0LFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJlc2V0IHRoZSB0aW1lclxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgWywgc2V0VHJpZ2dlckhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZShvbkhvdmVyQ2hhbmdlLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgWywgc2V0VG9vbHRpcEhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZShvbkhvdmVyQ2hhbmdlLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtob3ZlclN0YXRlLCBzZXRIb3ZlclN0YXRlXSA9IHVzZVN0YXRlPFwiaGlkZGVuXCIgfCBcInNob3dpbmcyXCIgfCBcInNob3duXCIgfCBcImhpZGluZ1wiPihcImhpZGRlblwiKTtcblxuXG5cbiAgICB1c2VUaW1lb3V0KHtcbiAgICAgICAgdHJpZ2dlckluZGV4OiBob3ZlclN0YXRlLFxuICAgICAgICB0aW1lb3V0OiAoaG92ZXJTdGF0ZSA9PSBcInNob3dpbmcyXCIpID8gbW91c2VvdmVyRGVsYXkgOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhvdmVyU3RhdGUgPT0gXCJzaG93aW5nMlwiKSB7XG4gICAgICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcInNob3duXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuXG5cbiAgICB1c2VUaW1lb3V0KHtcbiAgICAgICAgdHJpZ2dlckluZGV4OiBob3ZlclN0YXRlLFxuICAgICAgICB0aW1lb3V0OiAoaG92ZXJTdGF0ZSA9PSBcImhpZGluZ1wiKSA/IG1vdXNlb3V0VG9sZXJhbmNlRGVsYXkgOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhvdmVyU3RhdGUgPT0gXCJoaWRpbmdcIikge1xuICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy9jb25zdCBbdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy9jb25zdCBbdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IGhvdmVyRGVsYXlDb3JyZWN0ZWQgPSAoaG92ZXJTdGF0ZSA9PSBcInNob3duXCIpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE9wZW4odHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCBob3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQpO1xuICAgIH0sIFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IGhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZF0pXG5cbiAgICBjb25zdCB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXIoeyBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0gfTogeyBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFRyaWdnZXJUeXBlPiB9KSB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlVG9vbHRpcFRyaWdnZXJcIik7XG5cbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChlLnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICBzZXRUcmlnZ2VySG92ZXIodGFyZ2V0ID09IGdldEVsZW1lbnQoKSBhcyBOb2RlIHx8ICEhZ2V0RWxlbWVudCgpPy5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoZTogVG91Y2hFdmVudCkge1xuICAgICAgICAgICAgKGUudGFyZ2V0IGFzIGFueSkuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXM8VHJpZ2dlclR5cGU+KHtcbiAgICAgICAgICAgIC4uLmhhc0ZvY3VzLFxuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4geyBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTsgc2V0VHJpZ2dlckZvY3VzZWQoZm9jdXNlZCkgfSlcbiAgICAgICAgfSlcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ8VHJpZ2dlclR5cGU+KFwiYXJpYS1kZXNjcmliZWRieVwiIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFRob3VnaCBpdCdzIGltcG9ydGFudCB0byBtYWtlIHN1cmUgdGhhdCBmb2N1c2luZyBhY3RpdmF0ZXMgYSB0b29sdGlwLFxuICAgICAgICAgICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXG4gICAgICAgICAgICAvLyBub3QgdGhpcyBvbmUsIHNvIHdlIGRvbid0IHNldCB0YWJJbmRleD0wXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA/Pz0gLTE7XG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKFxuICAgICAgICAgICAgICAgIHVzZUhhc0ZvY3VzUHJvcHMoXG4gICAgICAgICAgICAgICAgICAgIHVzZU1lcmdlZFByb3BzPFRyaWdnZXJUeXBlPih7IG9uVG91Y2hFbmQgfSwgKHByb3BzIGFzIGFueSkgYXMgdW5rbm93biBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfTtcblxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVRvb2x0aXBQb3B1cCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXAoeyBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0gfTogeyBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFBvcHVwVHlwZT4gfSkge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRvb2x0aXBUb29sdGlwXCIpO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VIYXNGb2N1czxQb3B1cFR5cGU+KHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4geyBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTsgc2V0VG9vbHRpcEZvY3VzZWQoZm9jdXNlZCk7IH0pLCAuLi5oYXNGb2N1cyB9KVxuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XG4gICAgICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwUG9wdXBQcm9wcyh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQb3B1cFR5cGU+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHVzZU1lcmdlZFByb3BzPFBvcHVwVHlwZT4oe30sIHByb3BzKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFBvcHVwUHJvcHMgfTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUb29sdGlwUG9wdXAsXG4gICAgICAgIHVzZVRvb2x0aXBUcmlnZ2VyLFxuICAgICAgICBpc09wZW46IG9wZW4sXG4gICAgICAgIGdldElzT3BlbjogZ2V0T3BlblxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcsIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQ2hlY2tib3hMaWtlLCB1c2VMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG4vL3R5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuZXhwb3J0IHR5cGUgUmFkaW9DaGFuZ2VFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFYgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+ID0gRW5oYW5jZWRFdmVudDxFLCBFdmVudCwgeyBzZWxlY3RlZFZhbHVlOiBWIHwgdW5kZWZpbmVkIH0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8XCJzZWxlY3RlZEluZGV4XCIgfCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcbiAgICByYWRpb0dyb3VwOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZztcblxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBWIHwgbnVsbDtcbiAgICAgICAgb25TZWxlY3RlZFZhbHVlQ2hhbmdlKGV2ZW50OiBSYWRpb0NoYW5nZUV2ZW50PElucHV0RWxlbWVudCwgVj4pOiB2b2lkO1xuICAgICAgICAvL29uSW5wdXQoZXZlbnQ6IFJhZGlvQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbEVsZW1lbnQ+LCBWPik6IHZvaWQ7XG4gICAgICAgIHRhZ0dyb3VwOiBFbGVtZW50VG9UYWc8R3JvdXBFbGVtZW50PjtcbiAgICAgICAgdGFnR3JvdXBMYWJlbDogRWxlbWVudFRvVGFnPEdyb3VwTGFiZWxFbGVtZW50PjtcbiAgICB9XG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyc1tcImNoaWxkcmVuSGF2ZUZvY3VzXCJdO1xufVxuXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9JbmZvQmFzZSBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxcInRhYmJhYmxlXCIgfCBcInNlbGVjdGVkXCI+IHtcbiAgICBzZXRDaGVja2VkKGNoZWNrZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIGdldENoZWNrZWQoKTogYm9vbGVhbiB8IG51bGw7XG59Ki9cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1BhcmFtZXRlcnM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPHt9LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4ge1xuICAgIHJhZGlvOiB7XG4gICAgICAgIGxhYmVsUG9zaXRpb246IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIjtcbiAgICAgICAgdmFsdWU6IFY7XG4gICAgICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgICAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPEk+O1xuICAgICAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPElMPjtcbiAgICB9XG4gICAgaGFzRm9jdXNJbnB1dDogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEk+O1xuICAgIGhhc0ZvY3VzTGFiZWw6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJTD47XG4gICAgLypPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgSUw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCI+ICYge1xuICAgICAgICBpbmZvOiBPbWl0PEluZm8sIFwic2V0Q2hlY2tlZFwiIHwgXCJnZXRDaGVja2VkXCIgfCBcImJsdXJTZWxmXCIgfCBcImdldEVsZW1lbnRcIiB8IFwiZm9jdXNTZWxmXCI+O1xuICAgICAgICBcbiAgICB9Ki9cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxJLCB7fSwgbmV2ZXI+IHtcbiAgICByYWRpb0dyb3VwOiB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFYgfCBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgRWxlbWVudCwgSUwgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgST4ge1xuICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+O1xuICAgIHVzZVJhZGlvR3JvdXBQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz47XG4gICAgdXNlUmFkaW86IFVzZVJhZGlvPFYsIEksIElMPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhZGlvR3JvdXA8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgRyBleHRlbmRzIEVsZW1lbnQsIEdMIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICByYWRpb0dyb3VwOiB7IG5hbWUsIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSwgc2VsZWN0ZWRWYWx1ZSwgdGFnR3JvdXAsIHRhZ0dyb3VwTGFiZWwgfSxcbiAgICByb3ZpbmdUYWJJbmRleCxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzLFxuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3Rpb25Nb2RlIH1cbn06IFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEcsIEdMLCBJPik6IFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlV2l0aEhvb2tzPFYsIEcsIEdMLCBJLCBJTD4ge1xuICAgIGRlYnVnTG9nKFwidXNlUmFkaW9Hcm91cFwiLCBzZWxlY3RlZFZhbHVlKTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IF9nZXRSYWRpb0dyb3VwUGFyZW50RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEc+KHt9KTtcblxuICAgIC8vY29uc3QgZ2V0U2VsZWN0ZWRJbmRleCA9IHVzZUNhbGxiYWNrKChzZWxlY3RlZFZhbHVlOiBWKSA9PiB7IHJldHVybiBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSkgPz8gMCB9LCBbXSlcblxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KDApO1xuICAgIGNvbnN0IGJ5TmFtZSA9IHVzZVJlZihuZXcgTWFwPFYsIGFueT4oKSk7XG4gICAgLy9jb25zdCBzdGFibGVPbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3RlZFZhbHVlQ2hhbmdlKTtcblxuICAgIC8vY29uc3QgW2FueVJhZGlvc0ZvY3VzZWQsIHNldEFueVJhZGlvc0ZvY3VzZWQsIGdldEFueVJhZGlvc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VHcm91cExhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWw6IHVzZUdyb3VwTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8RywgR0w+KHsgbGFiZWw6IHsgcHJlZml4TGFiZWw6IFwiYXJpYS1yYWRpby1ncm91cC1sYWJlbC1cIiwgdGFnSW5wdXQ6IHRhZ0dyb3VwIGFzIG5ldmVyLCB0YWdMYWJlbDogdGFnR3JvdXBMYWJlbCBhcyBuZXZlciwgcHJlZml4SW5wdXQ6IFwiYXJpYS1yYWRpby1ncm91cC1cIiB9IH0pXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHM6IHVzZUdyb3VwTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHcm91cExhYmVsSW5wdXQoKTtcbiAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wczogdXNlR3JvdXBMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdyb3VwTGFiZWxMYWJlbCgpO1xuXG4gICAgY29uc3Qgb25TZWxlY3RlZEluZGV4Q2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IEV2ZW50LCBuZXdJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZShlbmhhbmNlRXZlbnQ8SSwgRXZlbnQsIHsgc2VsZWN0ZWRWYWx1ZTogViB8IHVuZGVmaW5lZCB9PihlLCB7IHNlbGVjdGVkVmFsdWU6IGxpc3ROYXZSZXQubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KG5ld0luZGV4KT8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0VmFsdWUoKSB9KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXRcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248RywgSSwgeyBnZXRWYWx1ZSgpOiBWIH0sIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgb25TZWxlY3RlZEluZGV4Q2hhbmdlLCBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzXG4gICAgfSk7XG5cbiAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIHJhZGlvIGdyb3VwIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIFdoZW4gaXQncyBub3QsIHdlIHJlc2V0IHRoZSB0YWJiYWJsZSBpbmRleCBiYWNrIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudC5cbiAgICAvL2NvbnN0IHsgdXNlQWN0aXZlRWxlbWVudFByb3BzIH0gPSB1c2VBY3RpdmVFbGVtZW50PEc+KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoYWN0aXZlRWxlbWVudDogTm9kZSB8IG51bGwpID0+IHNldEFueVJhZGlvc0ZvY3VzZWQoISEoZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQoKT8uY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSwgW10pIH0pO1xuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhbnlSYWRpb3NGb2N1c2VkKVxuICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXggPz8gMCk7XG4gICAgfSwgW2FueVJhZGlvc0ZvY3VzZWQsIHNlbGVjdGVkSW5kZXgsIG5hdmlnYXRlVG9JbmRleF0pOyovXG5cblxuICAgIGNvbnN0IHVzZVJhZGlvR3JvdXBQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz4gPT4ge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJyYWRpb2dyb3VwXCI7XG4gICAgICAgIHJldHVybiB1c2VHcm91cExhYmVsSW5wdXRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykpKTtcbiAgICB9LCBbdXNlUmVmRWxlbWVudFByb3BzXSlcblxuICAgIGNvbnN0IHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHTD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHTD4gPT4geyByZXR1cm4gdXNlR3JvdXBMYWJlbExhYmVsUHJvcHMocHJvcHMpOyB9LCBbdXNlR3JvdXBMYWJlbExhYmVsUHJvcHNdKTtcblxuICAgIC8vY29uc3QgY29ycmVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCA9PSBudWxsIHx8IHNlbGVjdGVkSW5kZXggPCAwIHx8IHNlbGVjdGVkSW5kZXggPj0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCkgPyBudWxsIDogc2VsZWN0ZWRJbmRleDtcbiAgICAvKmNvbnN0IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gPSB1c2VDaGlsZHJlbkZsYWcoe1xuICAgICAgICBpbml0aWFsSW5kZXg6IDAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBrZXk6IFwic2VsZWN0ZWRcIlxuICAgICAgICAvL3NldENoaWxkRmxhZzogKGksIGNoZWNrZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpXT8uc2V0Q2hlY2tlZChjaGVja2VkKSxcbiAgICAgICAgLy9nZXRDaGlsZEZsYWc6ICgoaSkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5nZXRDaGVja2VkKCkgPz8gZmFsc2UpXG4gICAgfSk7Ki9cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RlZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXgobnVsbClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXggPz8gbnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbYnlOYW1lLCBzZWxlY3RlZFZhbHVlXSk7XG5cblxuXG4gICAgY29uc3QgdXNlUmFkaW8gPSB1c2VDYWxsYmFjazxVc2VSYWRpbzxWLCBJLCBJTD4+KGZ1bmN0aW9uIHVzZVJhZGlvKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZCxcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIGhhc0ZvY3VzSW5wdXQsXG4gICAgICAgIGhhc0ZvY3VzTGFiZWwsXG4gICAgICAgIHJhZGlvOiB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIHZhbHVlIH1cbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWFuYWdlZENoaWxkLmluZGV4O1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZVJhZGlvXCIsIGluZGV4KTtcbiAgICAgICAgLy9jb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZCwgZ2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XG5cbiAgICAgICAgY29uc3Qgb25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEk+KSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2UoZSwgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZVN0YWJsZUdldHRlcih2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2UmV0IH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHtcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXgsXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQsXG4gICAgICAgICAgICBoYXNGb2N1czogaGFzRm9jdXNJbnB1dCxcbiAgICAgICAgICAgIHN1YkluZm86IHsgZ2V0VmFsdWUgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZDogY2hlY2tlZCB9IH0gPSBsaXN0TmF2UmV0O1xuXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgfSA9IHVzZUNoZWNrYm94TGlrZTxJLCBJTD4oe1xuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZDogKGNoZWNrZWQgPz8gZmFsc2UpLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlOiBvbklucHV0LFxuICAgICAgICAgICAgICAgIHJvbGU6IFwicmFkaW9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgdGFnSW5wdXQ6IHRhZ0lucHV0IGFzIG5ldmVyLFxuICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiB0YWdMYWJlbCBhcyBuZXZlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc0ZvY3VzSW5wdXQsXG4gICAgICAgICAgICBoYXNGb2N1c0xhYmVsXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGJ5TmFtZS5jdXJyZW50LnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgYnlOYW1lLmN1cnJlbnQuZGVsZXRlKHZhbHVlKTsgfVxuICAgICAgICB9LCBbYnlOYW1lLCB2YWx1ZSwgaW5kZXhdKTtcblxuICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0OiBVc2VSYWRpb0lucHV0PEk+ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gdGFnSW5wdXQ7XG4gICAgICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0UHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4gPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gKGNoZWNrZWQgPz8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJyYWRpb1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSAoY2hlY2tlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMocHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wczxJPigodXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoe30pKSwgbGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgOiBwcm9wcykpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VSYWRpb0lucHV0UHJvcHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB1c2VSYWRpb0xhYmVsOiBVc2VSYWRpb0xhYmVsPElMPiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vY29uc3QgdGFnID0gdGFnTGFiZWw7XG4gICAgICAgICAgICBjb25zdCB1c2VSYWRpb0xhYmVsUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElMPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElMPiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHByb3BzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPElMPih7fSBhcyBhbnksIGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiID8gcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzIGFzIGFueSA6IHByb3BzIGFzIGFueSkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZVJhZGlvTGFiZWxQcm9wc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50XSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVJhZGlvSW5wdXQsXG4gICAgICAgICAgICB1c2VSYWRpb0xhYmVsLFxuICAgICAgICAgICAgLi4ubGlzdE5hdlJldFxuICAgICAgICAgICAgLy9jaGVja2VkOiBjaGVja2VkID8/IGZhbHNlLFxuICAgICAgICAgICAgLy90YWJiYWJsZTogdGFiYmFibGUgPz8gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgfSwgW2J5TmFtZSwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlUmFkaW8sXG4gICAgICAgIHVzZVJhZGlvR3JvdXBQcm9wcyxcbiAgICAgICAgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMsXG4gICAgICAgIHJhZGlvR3JvdXA6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmxpc3ROYXZSZXRcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88ST4geyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9SZXR1cm5UeXBlV2l0aEhvb2tzPEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEk+IHtcbiAgICB1c2VSYWRpb0lucHV0OiBVc2VSYWRpb0lucHV0PEk+O1xuICAgIHVzZVJhZGlvTGFiZWw6IFVzZVJhZGlvTGFiZWw8TD47XG59XG5cbnR5cGUgVXNlUmFkaW9JbnB1dDxJIGV4dGVuZHMgRWxlbWVudD4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8ST4pID0+IHsgdXNlUmFkaW9JbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPjsgfVxudHlwZSBVc2VSYWRpb0xhYmVsPEwgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxMPikgPT4geyB1c2VSYWRpb0xhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+OyB9XG5cbmV4cG9ydCB0eXBlIFVzZVJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4gPSAoYTogVXNlUmFkaW9QYXJhbWV0ZXJzPFYsIEksIEw+KSA9PiBVc2VSYWRpb1JldHVyblR5cGVXaXRoSG9va3M8SSwgTD5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmaW5kRmlyc3RGb2N1c2FibGUsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1hbmFnZWRDaGlsZHJlbiwgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1pbnRlcmZhY2UgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xuICAgIHRvYXN0czoge1xuICAgICAgICB2aXNpYmxlQ291bnQ6IG51bWJlcjsgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgdG9hc3RzIHRoYXQgYXJlIHNob3duIGF0IG9uZSB0aW1lICh1c2VkIGZvciBhdXRvbWF0aWMgbWFuYWdlbWVudCBvZiB3aGVuIHRvIHNob3cgdG9hc3RzLCBpLmUuIGRvbid0IHNob3cgdGhpcyB0b2FzdCBpZiAyIGFyZSBhbHJlYWR5IG9uLXNjcmVlbiAtLSAxIGlzIGEgZ29vZCBkZWZhdWx0KVxuICAgIH1cbn1cblxudHlwZSBTaG93aW5nID0gbmV2ZXI7IC8vXCJzaG93aW5nXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIFRvYXN0SW5mbywgU2hvd2luZywgXCJzdWJJbmZvXCI+IHtcbiAgICAvL2luZm86IE9taXQ8VG9hc3RJbmZvQmFzZSwgXCJkaXNtaXNzZWRcIiB8IFwiZ2V0U3RhdHVzXCIgfCBcInNldFN0YXR1c1wiIHwgXCJmb2N1c1wiIHwgXCJmbGFnc1wiPjtcbiAgICB0b2FzdDoge1xuICAgICAgICBwb2xpdGVuZXNzPzogXCJwb2xpdGVcIiB8IFwiYXNzZXJ0aXZlXCI7XG4gICAgICAgIHRpbWVvdXQ6IG51bWJlciB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvYXN0SW5mbyB7XG4gICAgLy9kaXNtaXNzZWQ6IGJvb2xlYW47XG4gICAgc2V0TnVtYmVyQWhlYWRPZk1lOiBTdGF0ZVVwZGF0ZXI8bnVtYmVyPjtcbiAgICBmb2N1cygpOiB2b2lkO1xuICAgIHNob3coKTogdm9pZDtcbiAgICAvL3NldFN0YXR1czogU3RhdGVVcGRhdGVyPFwicGVuZGluZ1wiIHwgXCJhY3RpdmVcIiB8IFwiZGlzbWlzc2VkXCI+O1xuICAgIC8vZ2V0U3RhdHVzKCk6IG51bGwgfCBcInBlbmRpbmdcIiB8IFwiYWN0aXZlXCIgfCBcImRpc21pc3NlZFwiO1xufVxuXG5leHBvcnQgdHlwZSBVc2VUb2FzdCA9IChhcmdzOiBVc2VUb2FzdFBhcmFtZXRlcnMpID0+IFVzZVRvYXN0UmV0dXJuVHlwZUluZm87XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RSZXR1cm5UeXBlSW5mbyB7XG4gICAgdG9hc3Q6IHtcbiAgICAgICAgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXM6IG51bWJlcjtcbiAgICAgICAgZGlzbWlzczogKCkgPT4gdm9pZDtcbiAgICAgICAgZGlzbWlzc2VkOiBib29sZWFuO1xuICAgICAgICBzaG93aW5nOiBib29sZWFuO1xuICAgICAgICByZXNldERpc21pc3NUaW1lcjogKCkgPT4gdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RzUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFRvYXN0SW5mbywgU2hvd2luZz4ge1xuICAgIHRvYXN0czoge307XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RSZXR1cm5UeXBlV2l0aEhvb2tzIGV4dGVuZHMgVXNlVG9hc3RSZXR1cm5UeXBlSW5mbyB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb2FzdHNSZXR1cm5UeXBlV2l0aEhvb2tzPENvbnRhaW5lclR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRvYXN0c1JldHVyblR5cGVJbmZvIHtcbiAgICB1c2VUb2FzdDogVXNlVG9hc3Q7XG4gICAgdXNlVG9hc3RDb250YWluZXJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRvYXN0czxDb250YWluZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY211LCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgfSwgdG9hc3RzOiB7IHZpc2libGVDb3VudCB9IH06IFVzZVRvYXN0c1BhcmFtZXRlcnMpOiBVc2VUb2FzdHNSZXR1cm5UeXBlV2l0aEhvb2tzPENvbnRhaW5lclR5cGU+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZVRvYXN0c1wiKTtcblxuICAgIC8vIE5vcm1hbGx5LCB0aGlzIGRvZXMganVzdCBsb29rIGxpa2UgWzAsIDEsIDIsIDNdLCBldGNcbiAgICAvLyBzbyBpdCBjb3VsZCBiZSBqdXN0IGFuIGluZGV4IHRvIHRoZSBjdXJyZW50IHRvYXN0LFxuICAgIC8vIGJ1dCBpZiB3ZSBkaXNtaXNzIHRvYXN0cyBvdXQgb2Ygb3JkZXIsIGl0J3MgWzAsIDIsIDNdIG9yIHNvbWV0aGluZy5cbiAgICAvLyBTbyBqdXN0IGtlZXAgdHJhY2sgb2YgaXQgYWxsIGluIGEgYmlnIG9sJywgdGhlcmUncyBvbmx5IG9uZSBvZiB0aGVzZSBvbiBhIHBhZ2UgYW55d2F5LFxuICAgIC8vIGFuZCBpZiB5b3UncmUgcHVzaW5nIDEwMDAwIHRvYXN0cyBhdCBvbmNlIGFuIEFycmF5PG51bWJlcj4gaXNuJ3QgZ29pbmcgdG8gYmUgeW91ciBib3R0bGVuZWNrLlxuICAgIGNvbnN0IGN1cnJlbnRJbmRleFF1ZXVlID0gdXNlUmVmPG51bWJlcltdPihbXSk7XG5cbiAgICBjb25zdCBbcG9saXRlbmVzcywgc2V0UG9saXRlbmVzc10gPSB1c2VTdGF0ZTxcInBvbGl0ZVwiIHwgXCJhc3NlcnRpdmVcIj4oXCJwb2xpdGVcIik7XG5cbiAgICBjb25zdCBnZXRNYXhWaXNpYmxlQ291bnQgPSB1c2VTdGFibGVHZXR0ZXIodmlzaWJsZUNvdW50KTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PENvbnRhaW5lclR5cGU+KHt9KTtcbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgLi4uY2hpbGRJbmZvIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBUb2FzdEluZm8sIFNob3dpbmc+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY211IH0gfSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogdG9hc3RRdWV1ZSB9IH0gPSBjaGlsZEluZm87XG5cbiAgICAvLyBXaGVuIGEgdG9hc3QgaXMgc2hvd24gb3IgaGlkZGVuLCBhbHdheXMgbWFrZSBzdXJlIHRoYXQgd2UncmUgc2hvd2luZyBhbGwgdGhlIHRvYXN0cyB0aGF0IHdlIHNob3VsZCBiZS5cbiAgICBjb25zdCBzaG93SGlnaGVzdFByaW9yaXR5VG9hc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKGdldE1heFZpc2libGVDb3VudCgpLCBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50Lmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7ICsraSkge1xuXG4gICAgICAgICAgICBjb25zdCBoaWdoZXN0UHJpb3JpdHlUb2FzdCA9IHRvYXN0UXVldWUuZ2V0QXQoY3VycmVudEluZGV4UXVldWUuY3VycmVudFtpXSk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghIWhpZ2hlc3RQcmlvcml0eVRvYXN0KTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVRvYXN0Py5zdWJJbmZvLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgLy8gQW55IHRpbWUgYSBuZXcgdG9hc3QgbW91bnRzLCB1cGRhdGUgb3VyIGJvdHRvbW1vc3RUb2FzdEluZGV4IHRvIHBvaW50IHRvIGl0IGlmIG5lY2Vzc2FyeVxuICAgIC8vIChcIm5lY2Vzc2FyeVwiIGp1c3QgbWVhbmluZyBpZiBpdCdzIHRoZSBmaXJzdCB0b2FzdCBldmVyIG9yIGFsbCBwcmlvciB0b2FzdHMgaGF2ZSBiZWVuIGRpc21pc3NlZClcbiAgICBjb25zdCBvbkFueVRvYXN0TW91bnRlZCA9IHVzZUNhbGxiYWNrKCh0b2FzdEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY3VycmVudEluZGV4UXVldWUuY3VycmVudC5wdXNoKHRvYXN0SW5kZXgpO1xuICAgICAgICB0b2FzdFF1ZXVlLmdldEF0KHRvYXN0SW5kZXgpPy5zdWJJbmZvLnNldE51bWJlckFoZWFkT2ZNZShjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICBzaG93SGlnaGVzdFByaW9yaXR5VG9hc3QoKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIHRvYXN0IGlzIGRpc21pc3NlZCwgdXBkYXRlIG91ciBib3R0b21tb3N0VG9hc3RJbmRleCB0byBwb2ludCB0byB0aGUgbmV4dCB0b2FzdCBpbiB0aGUgcXVldWUsIGlmIG9uZSBleGlzdHMuXG4gICAgY29uc3Qgb25BbnlUb2FzdERpc21pc3NlZCA9IHVzZUNhbGxiYWNrKChfaW5kZXg6IG51bWJlcikgPT4ge1xuXG4gICAgICAgIC8vIFdoZW4gd2UgZGlzbWlzcyBhIHRvYXN0LCByZW1vdmUgaXQgZnJvbSB0aGUgXCJ0by1kaXNwbGF5XCIgcXVldWUgYnkgYWN0dWFsbHkgc3BsaWNpbmcgaXQgb3V0IG9mIHRoZSBhcnJheS5cbiAgICAgICAgLy8gVGhlbiBub3RpZnkgZWFjaCB0b2FzdCBvZiBpdHMgY2hhbmdlIGluIHBvc2l0aW9uIHdpdGhpbiB0aGF0IHF1ZXVlIHRvIGtlZXAgdGhlIHR3byBpbiBzeW5jLlxuICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50LmZpbmRJbmRleChpID0+IGkgPT0gX2luZGV4KTtcblxuXG4gICAgICAgIC8vIEZvciBhbGwgdG9hc3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGlzbWlzc2VkLCBzaGlmdCB0aGVtIGV2ZW4gZnVydGhlciBiYWNrIGJ5IG9uZSB0byBcIm1ha2Ugc3BhY2VcIiBcbiAgICAgICAgLy8gKHRoZXkncmUgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZSBidXQgdGhpcyBpcyB0aGUgbmVnYXRpdmUgaW5kZXggdGhleSB3b3VsZCBoYXZlIGlmIHdlIGtlcHQgbmVnYXRpdmVzIGluIHRoZSBxdWV1ZSlcbiAgICAgICAgLy8gZm9yIHRoZSBuZXdseS1kaXNtaXNzZWQgdG9hc3QuXG4gICAgICAgIHRvYXN0UXVldWUuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGMuc3ViSW5mby5zZXROdW1iZXJBaGVhZE9mTWUocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldiAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTGV0IHRoaXMgdG9hc3Qga25vdyB0aGF0IGl0J3Mgbm93IHRoZSBtb3N0IHJlY2VudGx5IGRpc21pc3NlZCB0b2FzdFxuICAgICAgICB0b2FzdFF1ZXVlLmdldEF0KF9pbmRleCk/LnN1YkluZm8uc2V0TnVtYmVyQWhlYWRPZk1lKC0xKTtcblxuICAgICAgICAvLyBOb3RpZnkgYWxsIHRvYXN0cyB3YWl0aW5nIGJlaGluZCB0aGlzIG9uZSBpbiB0aGUgcXVldWUgdGhhdCB0aGV5J3ZlIG1vdmVkIHVwIG9uZSBzbG90XG4gICAgICAgIHRvYXN0UXVldWUuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGMuc3ViSW5mby5zZXROdW1iZXJBaGVhZE9mTWUocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPiByZW1vdmFsSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2IC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFjdHVhbGx5IG1vZGlmeSB0aGUgcXVldWUgaXRzZWxmXG4gICAgICAgIGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQuc3BsaWNlKHJlbW92YWxJbmRleCwgMSk7XG5cbiAgICAgICAgLy8gQW5kIGFmdGVyIGFsbCB0aGF0LCBtYWtlIHN1cmUgdGhhdCB3ZSdyZSBzaG93aW5nIGFueSB0b2FzdHMgdGhhdCBoYXZlIGJlZW4gd2FpdGluZyBpbiB0aGUgcXVldWVcbiAgICAgICAgc2hvd0hpZ2hlc3RQcmlvcml0eVRvYXN0KCk7XG4gICAgfSwgW10pO1xuXG5cblxuICAgIGNvbnN0IFtfbW91c2VPdmVyMiwgc2V0TW91c2VPdmVyLCBfZ2V0TW91c2VPdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdXNlT3ZlciA9IChlLnRhcmdldCAhPSBudWxsICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiAoZ2V0RWxlbWVudCgpPy5jb250YWlucyhlLnRhcmdldCkgfHwgZ2V0RWxlbWVudCgpID09IGUudGFyZ2V0KSk7XG4gICAgICAgIHNldE1vdXNlT3Zlcihtb3VzZU92ZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIGluZGV4IHBvaW50aW5nIHRvIHRoZSBjdXJyZW50bHktc2hvd2luZyB0b2FzdCBjaGFuZ2VzLFxuICAgIC8vIHVwZGF0ZSB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gYW5kIGxldCB0aGVtIGtub3cgdGhhdCB0aGV5J3JlIG5vdyBlaXRoZXIgYWN0aXZlIG9yIGRpc21pc3NlZC5cbiAgICAvKmNvbnN0IHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VG9hc3RJbmZvLCBcInNob3dpbmdcIj4oe1xuICAgICAgICBpbml0aWFsSW5kZXg6IGFjdGl2ZVRvYXN0SW5kZXgsXG4gICAgICAgIGNoaWxkcmVuOiB0b2FzdFF1ZXVlLFxuICAgICAgICBrZXk6IFwic2hvd2luZ1wiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZSxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VJbmRleChhY3RpdmVUb2FzdEluZGV4KTtcbiAgICB9LCBbYWN0aXZlVG9hc3RJbmRleF0pOyovXG5cbiAgICBjb25zdCB1c2VUb2FzdDogVXNlVG9hc3QgPSB1c2VDYWxsYmFjaygoeyB0b2FzdDogeyBwb2xpdGVuZXNzLCB0aW1lb3V0IH0sIG1hbmFnZWRDaGlsZDogeyBpbmRleCB9IH06IFVzZVRvYXN0UGFyYW1ldGVycyk6IFVzZVRvYXN0UmV0dXJuVHlwZVdpdGhIb29rcyA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlVG9hc3RcIiwgaW5kZXgpO1xuICAgICAgICBjb25zdCBbbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMsIHNldE51bWJlck9mVG9hc3RzQWhlYWRPZlVzXSA9IHVzZVN0YXRlKEluZmluaXR5KTtcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xuICAgICAgICBjb25zdCBbZGlzbWlzc2VkMiwgc2V0RGlzbWlzc2VkMiwgZ2V0RGlzbWlzc2VkMl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IFtzaG93aW5nMiwgc2V0U2hvd2luZzIsIGdldFNob3dpbmcyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgLy9jb25zdCBbZGlzbWlzc2VkLCBzZXREaXNtaXNzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICAvL2NvbnN0IFtzdGF0dXMsIHNldFN0YXR1cywgZ2V0U3RhdHVzXSA9IHVzZVN0YXRlPFwicGVuZGluZ1wiIHwgXCJhY3RpdmVcIiB8IFwiZGlzbWlzc2VkXCI+KFwicGVuZGluZ1wiKTtcbiAgICAgICAgLy9jb25zdCBkaXNtaXNzZWQgPSAoc3RhdHVzID09PSBcImRpc21pc3NlZFwiKTtcbiAgICAgICAgY29uc3QgZGlzbWlzcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZ2V0RGlzbWlzc2VkMigpKVxuICAgICAgICAgICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQoZ2V0SW5kZXgoKSk7XG5cbiAgICAgICAgICAgIHNldERpc21pc3NlZDIodHJ1ZSk7XG4gICAgICAgICAgICBzZXRTaG93aW5nMihmYWxzZSk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCBzaG93ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgc2V0U2hvd2luZzIodHJ1ZSk7XG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWdldERpc21pc3NlZDIoKSAmJiAhZ2V0U2hvd2luZzIoKSkge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyA+PSAwICYmIG51bWJlck9mVG9hc3RzQWhlYWRPZlVzIDwgZ2V0TWF4VmlzaWJsZUNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW251bWJlck9mVG9hc3RzQWhlYWRPZlVzXSlcblxuICAgICAgICAvL2NvbnN0IHRvYXN0SWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwidG9hc3QtXCIpO1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRQb2xpdGVuZXNzKHBvbGl0ZW5lc3MgPz8gXCJwb2xpdGVcIik7IH0sIFtwb2xpdGVuZXNzXSk7XG5cblxuICAgICAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlPy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgLypjb25zdCBbc2hvd2luZywgc2V0U2hvd2luZzIsIGdldFNob3dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICBjb25zdCBzZXRTaG93aW5nOiBTdGF0ZVVwZGF0ZXI8Ym9vbGVhbj4gPSAoKHUpID0+IHtcbiAgICAgICAgICAgIHNldFNob3dpbmcyKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldDogYm9vbGVhbiA9ICh0eXBlb2YgdSA9PSAnZnVuY3Rpb24nKSA/IHUocHJldikgOiB1O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGlzbWlzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBvbkFueVRvYXN0RGlzbWlzc2VkKGdldEluZGV4KCkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSovXG4gICAgICAgIC8vY29uc3Qgc2hvd2luZ1JlZiA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0U2hvd2luZywgc2V0OiBzZXRTaG93aW5nLCBpc1ZhbGlkOiByZXR1cm5UcnVlIH0pO1xuXG4gICAgICAgIGNvbnN0IF9fOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFnczogeyAvKnNob3dpbmc6IHNob3dpbmdSZWYuY3VycmVudCovIH0sIHN1YkluZm86IHsgZm9jdXMsIHNldE51bWJlckFoZWFkT2ZNZTogc2V0TnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMsIHNob3cgfSB9IH0pO1xuXG4gICAgICAgIC8vY29uc3QgaXNBY3RpdmUgPSAoc3RhdHVzID09PSBcImFjdGl2ZVwiKTtcbiAgICAgICAgY29uc3QgW3RyaWdnZXJJbmRleCwgc2V0VHJpZ2dlckluZGV4XSA9IHVzZVN0YXRlKDEpO1xuXG4gICAgICAgIGNvbnN0IHJlc2V0RGlzbWlzc1RpbWVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgc2V0VHJpZ2dlckluZGV4KGkgPT4gKytpKTtcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIG9uQW55VG9hc3RNb3VudGVkKGluZGV4KTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghc2hvd2luZylcbiAgICAgICAgICAgICAgICBvbkFueVRvYXN0RGlzbWlzc2VkKGluZGV4KVxuICAgICAgICB9LCBbc2hvd2luZ10pOyovXG5cbiAgICAgICAgY29uc3QgZGlzbWlzc1RpbWVvdXRLZXkgPSAodGltZW91dCA9PSBudWxsIHx8IG51bWJlck9mVG9hc3RzQWhlYWRPZlVzICE9IDApID8gbnVsbCA6IGlzRmluaXRlKHRpbWVvdXQpID8gdGltZW91dCA6IHRpbWVvdXQgPiAwID8gbnVsbCA6IDA7XG5cbiAgICAgICAgdXNlVGltZW91dCh7XG4gICAgICAgICAgICB0aW1lb3V0OiBkaXNtaXNzVGltZW91dEtleSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3dpbmcyKVxuICAgICAgICAgICAgICAgICAgICBkaXNtaXNzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJpZ2dlckluZGV4OiBzaG93aW5nMiA/IHRyaWdnZXJJbmRleCA6IGZhbHNlXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvYXN0OiB7XG4gICAgICAgICAgICAgICAgZGlzbWlzc2VkOiBkaXNtaXNzZWQyLFxuICAgICAgICAgICAgICAgIHNob3dpbmc6IHNob3dpbmcyLFxuICAgICAgICAgICAgICAgIG51bWJlck9mVG9hc3RzQWhlYWRPZlVzLFxuICAgICAgICAgICAgICAgIGRpc21pc3MsXG4gICAgICAgICAgICAgICAgcmVzZXREaXNtaXNzVGltZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGZ1bmN0aW9uIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMoeyByb2xlLCBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZSwgXCJhcmlhLXJlbGV2YW50XCI6IGFyaWFSZWxldmFudCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPiB7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDb250YWluZXJUeXBlPih1c2VSZWZFbGVtZW50UHJvcHMoeyBjbGFzczogXCJ0b2FzdHMtY29udGFpbmVyXCIsIHJvbGU6IHJvbGUgfHwgXCJzdGF0dXNcIiwgXCJhcmlhLWxpdmVcIjogcG9saXRlbmVzcyA/PyBhcmlhTGl2ZSA/PyBcInBvbGl0ZVwiLCBcImFyaWEtcmVsZXZhbnRcIjogYXJpYVJlbGV2YW50ID8/IFwiYWRkaXRpb25zXCIgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPiksIHByb3BzKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVRvYXN0LFxuICAgICAgICB1c2VUb2FzdENvbnRhaW5lclByb3BzLFxuICAgICAgICAuLi5jaGlsZEluZm8sXG4gICAgICAgIHRvYXN0czoge31cbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZHJlbiwgcmV0dXJuTnVsbCwgdXNlR3JpZE5hdmlnYXRpb24sIFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm8sIHVzZVBhc3NpdmVTdGF0ZSwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvLCB1c2VTb3J0YWJsZUNoaWxkcmVuLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm8sIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ncmlkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IENvbXBhcmUsIEdldEluZGV4LCBHZXRWYWx1ZSwgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcsIHdhcm5Pbk92ZXJ3cml0ZSB9IGZyb20gXCIuL3Byb3BzXCI7XG5cbmV4cG9ydCB0eXBlIFRhYmxlVmFsdWVUeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IGJvb2xlYW4gfCBEYXRlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJncmlkTmF2aWdhdGlvblwiPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVCb2R5UGFyYW1ldGVycyB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8VXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwge30+LCBcInN1YkluZm9cIj4ge1xuICAgIHRhYmxlUm93OiBQaWNrPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIFwibG9jYXRpb25cIj4gJiB7IHRhZ1RhYmxlUm93OiBFbGVtZW50VG9UYWc8Um93RWxlbWVudD4gfTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgVXNlVGFibGVDZWxsU3ViSW5mbywgbmV2ZXIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIE9taXQ8VXNlVGFibGVDZWxsU3ViSW5mbywgXCJzZXRNeVNvcnREaXJlY3Rpb25cIj4+IHtcbiAgICB0YWJsZUNlbGw6IHsgdGFnVGFibGVDZWxsOiBFbGVtZW50VG9UYWc8Q2VsbEVsZW1lbnQ+OyBoZWFkZXJUeXBlOiBcInJvd1wiIHwgXCJjb2x1bW5cIiB8IG51bGwgfTtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIjtcbiAgICBnZXRDZWxscygpOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2VsbEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VUYWJsZUNlbGxTdWJJbmZvPj4sIFwidGFiYmFibGVcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsU3ViSW5mbyB7XG4gICAgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIjtcbiAgICB2YWx1ZTogVGFibGVWYWx1ZVR5cGU7XG4gICAgc2V0TXlTb3J0RGlyZWN0aW9uKGRpcmVjdGlvbjogVGFibGVTb3J0RGlyZWN0aW9uIHwgbnVsbCk6IHZvaWQ7XG59XG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IHRhYmxlSGVhZGVyQ2VsbDogeyBzb3J0KCk6IHZvaWQsIHNvcnREaXJlY3Rpb246IFRhYmxlU29ydERpcmVjdGlvbiB8IG51bGw7IH0gfVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgVXNlVGFibGVDZWxsU3ViSW5mbywgbmV2ZXI+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgVXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgbmV2ZXI+IHsgfVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVDZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD47IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4geyB1c2VUYWJsZUNlbGw6IFVzZVRhYmxlQ2VsbDxDZWxsRWxlbWVudD47IHVzZVRhYmxlUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+OyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlQm9keVJldHVyblR5cGVXaXRoSG9va3M8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4geyB1c2VUYWJsZUJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4ge1xuICAgIHVzZVRhYmxlUm93OiBVc2VUYWJsZVJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XG4gICAgdXNlVGFibGVCb2R5OiBVc2VUYWJsZUJvZHk8Qm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XG4gICAgdXNlVGFibGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+O1xuICAgIHVzZVRhYmxlU2VjdGlvblByb3BzOiAodGFnOiBzdHJpbmcsIGxvY2F0aW9uOiBVc2VUYWJsZVJvd1N1YkluZm88YW55PltcImxvY2F0aW9uXCJdLCBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4pID0+IFVzZVRhYmxlQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+O1xuZXhwb3J0IHR5cGUgVXNlVGFibGVSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gVXNlVGFibGVSb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcbmV4cG9ydCB0eXBlIFVzZVRhYmxlQm9keTxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzKSA9PiBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xuXG5leHBvcnQgdHlwZSBUYWJsZVNvcnREaXJlY3Rpb24gPSBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCI7XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHQ6IG51bWJlcikgeyByZXR1cm4gdDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFibGU8XG4gICAgVGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudFxuPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZVRhYmxlUGFyYW1ldGVycyk6IFVzZVRhYmxlUmV0dXJuVHlwZVdpdGhIb29rczxUYWJsZUVsZW1lbnQsIEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlXCIpO1xuXG4gICAgY29uc3QgW2dldEN1cnJlbnRTb3J0Q29sdW1uLCBzZXRDdXJyZW50U29ydENvbHVtbl0gPSB1c2VQYXNzaXZlU3RhdGU8eyBpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IFRhYmxlU29ydERpcmVjdGlvbiB9IHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgYm9keVNvcnQgPSB1c2VSZWY8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCk7XG4gICAgY29uc3QgbWFuZ2xlcnMgPSB1c2VSZWYoeyByb3dJbmRleE1hbmdsZXI6IGlkZW50aXR5LCByb3dJbmRleERlbWFuZ2xlcjogaWRlbnRpdHkgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxuICAgICAgICAuLi5ncmlkTmF2UmV0MVxuICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbjxUYWJsZUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBVc2VUYWJsZUNlbGxTdWJJbmZvLCBuZXZlciwgbmV2ZXI+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHsgcm93SW5kZXhEZW1hbmdsZXI6IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IG1hbmdsZXJzLmN1cnJlbnQucm93SW5kZXhEZW1hbmdsZXIobiksIFtdKSwgcm93SW5kZXhNYW5nbGVyOiB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiBtYW5nbGVycy5jdXJyZW50LnJvd0luZGV4TWFuZ2xlcihuKSwgW10pIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiByb3dzIH0gfSA9IGdyaWROYXZSZXQxO1xuXG4gICAgY29uc3QgdXNlVGFibGVSb3cgPSB1c2VDYWxsYmFjazxVc2VUYWJsZVJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb24sIGFzUGFyZW50Um93T2ZDZWxscywgdGFibGVSb3c6IHsgbG9jYXRpb24sIHRhZ1RhYmxlUm93IH0gfTogVXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pik6IFVzZVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlUm93XCIsIGFzQ2hpbGRSb3dPZlNlY3Rpb24ubWFuYWdlZENoaWxkLmluZGV4KTtcblxuICAgICAgICBjb25zdCBnZXRDZWxscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjZWxscztcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsLFxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcbiAgICAgICAgICAgIC4uLmdyaWROYXZSZXQyXG4gICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvblJvdyh7IGFzQ2hpbGRSb3dPZlNlY3Rpb246IHsgLi4uYXNDaGlsZFJvd09mU2VjdGlvbiwgc3ViSW5mbzogeyBnZXRDZWxscywgbG9jYXRpb24gfSB9LCBhc1BhcmVudFJvd09mQ2VsbHMgfSk7XG5cbiAgICAgICAgY29uc3QgeyBhc1BhcmVudE9mQ2VsbHM6IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBjZWxscyB9IH0gfSA9IGdyaWROYXZSZXQyO1xuXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZVRhYmxlQ2VsbDxDZWxsRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvLCBoYXNGb2N1cywgdGFibGVDZWxsOiB7IHRhZ1RhYmxlQ2VsbCwgaGVhZGVyVHlwZSB9IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtteVNvcnREaXJlY3Rpb24sIHNldE15U29ydERpcmVjdGlvbl0gPSB1c2VTdGF0ZTxUYWJsZVNvcnREaXJlY3Rpb24gfCBudWxsPihudWxsKTtcbiAgICAgICAgICAgIGRlYnVnTG9nKFwidXNlVGFibGVDZWxsXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMsXG4gICAgICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDNcbiAgICAgICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNlbGwoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbzogeyAuLi5zdWJJbmZvLCBzZXRNeVNvcnREaXJlY3Rpb24gfSwgaGFzRm9jdXMgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydEluZm8gPSBnZXRDdXJyZW50U29ydENvbHVtbigpID8/IHsgaW5kZXg6IC0xLCBkaXJlY3Rpb246ICdhc2NlbmRpbmcnIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEluZGV4ID0gbWFuYWdlZENoaWxkLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChzb3J0SW5mby5pbmRleCA9PSBjZWxsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRJbmZvLmRpcmVjdGlvblswXSA9PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbmZvLmRpcmVjdGlvbiA9ICdkZXNjZW5kaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbmZvLmRpcmVjdGlvbiA9ICdhc2NlbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3J0SW5mby5kaXJlY3Rpb24gPSBcImFzY2VuZGluZ1wiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvcnRJbmZvLmluZGV4ID0gbWFuYWdlZENoaWxkLmluZGV4O1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRTb3J0Q29sdW1uKHNvcnRJbmZvKTtcblxuICAgICAgICAgICAgICAgIGdldENlbGxzKCkuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaW5kZXggPT0gbWFuYWdlZENoaWxkLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLnNldE15U29ydERpcmVjdGlvbihzb3J0SW5mby5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5zZXRNeVNvcnREaXJlY3Rpb24obnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCEoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB1c2VUYWJsZUNlbGxQcm9wczogdHlwZW9mIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzID0gKHByb3BzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFnVGFibGVDZWxsICE9IFwidGRcIiAmJiB0YWdUYWJsZUNlbGwgIT0gXCJ0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJUeXBlID09IFwicm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFibGVDZWxsXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd2hlYWRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyVHlwZSA9PSBcImNvbHVtblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlQ2VsbFwiLCBcInJvbGVcIiwgcHJvcHMucm9sZSwgXCJjb2x1bW5oZWFkZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJsZUNlbGxcIiwgXCJyb2xlXCIsIHByb3BzLnJvbGUsIFwiY2VsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkZXJUeXBlID09IFwicm93XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5zY29wZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlQ2VsbFwiLCBcInNjb3BlXCIsIHByb3BzLnNjb3BlLCBcInJvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyVHlwZSA9PSBcImNvbHVtblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2NvcGUgPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJsZUNlbGxcIiwgXCJzY29wZVwiLCBwcm9wcy5zY29wZSwgXCJjb2xcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG15U29ydERpcmVjdGlvbiA9PSBcImRlc2NlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNvcnRcIl0gPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJsZUNlbGxcIiwgXCJhcmlhLXNvcnRcIiwgcHJvcHNbXCJhcmlhLXNvcnRcIl0sIFwiZGVzY2VuZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChteVNvcnREaXJlY3Rpb24gPT0gXCJhc2NlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNvcnRcIl0gPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJsZUNlbGxcIiwgXCJhcmlhLXNvcnRcIiwgcHJvcHNbXCJhcmlhLXNvcnRcIl0sIFwiYXNjZW5kaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhYmxlSGVhZGVyQ2VsbDogeyBzb3J0LCBzb3J0RGlyZWN0aW9uOiBteVNvcnREaXJlY3Rpb24gfSxcbiAgICAgICAgICAgICAgICB1c2VUYWJsZUNlbGxQcm9wcyxcbiAgICAgICAgICAgICAgICAuLi5ncmlkTmF2UmV0M1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCB1c2VUYWJsZVJvd1Byb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyA9IChwcm9wcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZ1RhYmxlUm93ICE9IFwidHJcIilcbiAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFibGVSb3dcIiwgXCJyb2xlXCIsIHByb3BzLnJvbGUsIFwicm93XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMocHJvcHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VUYWJsZUNlbGwsXG4gICAgICAgICAgICB1c2VUYWJsZVJvd1Byb3BzLFxuICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDJcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVRhYmxlQm9keSA9IHVzZUNhbGxiYWNrPFVzZVRhYmxlQm9keTxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4oKCkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlQm9keVwiKTtcbiAgICAgICAgdHlwZSBDID0gVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+Pj47XG4gICAgICAgIHR5cGUgViA9IHsgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIiwgdmFsdWU6IFRhYmxlVmFsdWVUeXBlIH07XG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlQ2FsbGJhY2s8R2V0SW5kZXg8QywgbmV2ZXI+PigoaSkgPT4gaS5pbmRleCwgW10pO1xuICAgICAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPEdldFZhbHVlPEMsIG5ldmVyLCBbXSwgVj4+KChpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IGkuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0Q2VsbHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxscy5nZXRBdChnZXRDdXJyZW50U29ydENvbHVtbigpPy5pbmRleCA/PyAwKTtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBjZWxsPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5sb2NhdGlvbiA/PyBcImhlYWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8udmFsdWUgPz8gLTFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9yZXR1cm4gY2VsbHMuZ2V0QXQoZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uaW5kZXggPz8gMCk/LnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLnZhbHVlID8/IG51bGw7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCBjb21wYXJlOiBDb21wYXJlPFY+ID0gKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09PSByaHMubG9jYXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuICsobGhzLnZhbHVlID8/IC1JbmZpbml0eSkgLSArKHJocy52YWx1ZSA/PyAtSW5maW5pdHkpO1xuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PSAnaGVhZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PSAnYm9keScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocy5sb2NhdGlvbiA9PSAnaGVhZCcgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgICAgICAuLi5zb3J0YWJsZVJldFxuICAgICAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxCb2R5U2VjdGlvbkVsZW1lbnQsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+LCBuZXZlciwgW10sIFY+KHtcbiAgICAgICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgICAgIGdldEluZGV4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgICAgIGNvbXBhcmUsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyBzb3J0YWJsZUNoaWxkcmVuOiB7IHNvcnQgfSwgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSB9ID0gc29ydGFibGVSZXQ7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBtYW5nbGVycy5jdXJyZW50LnJvd0luZGV4RGVtYW5nbGVyID0gaW5kZXhEZW1hbmdsZXI7XG4gICAgICAgICAgICBtYW5nbGVycy5jdXJyZW50LnJvd0luZGV4TWFuZ2xlciA9IGluZGV4TWFuZ2xlcjtcbiAgICAgICAgfSwgW2luZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXJdKTtcblxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzb3J0KHJvd3MsIGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmRpcmVjdGlvbiA/PyAnYXNjZW5kaW5nJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc29ydF0pXG5cbiAgICAgICAgY29uc3QgdXNlVGFibGVCb2R5UHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVNvcnRhYmxlUHJvcHMocHJvcHMgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PiAmIHsgY2hpbGRyZW46IGFueSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VUYWJsZUJvZHlQcm9wcyxcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VUYWJsZVByb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25Qcm9wcyA9IHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM7XG5cbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25Qcm9wcyA9IHVzZUNhbGxiYWNrKCh0YWc6IHN0cmluZywgbG9jYXRpb246IFVzZVRhYmxlUm93U3ViSW5mbzxhbnk+W1wibG9jYXRpb25cIl0sIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSA9PiB7XG4gICAgICAgIGlmICghKHRhZyA9PSBcInRoZWFkXCIgfHwgdGFnID09IFwidGJvZHlcIiB8fCB0YWcgPT0gXCJ0Zm9vdFwiKSkge1xuICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlU2VjdGlvblByb3BzXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd2dyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVRhYmxlUHJvcHMsXG4gICAgICAgIHVzZVRhYmxlQm9keSxcbiAgICAgICAgdXNlVGFibGVSb3csXG4gICAgICAgIHVzZVRhYmxlU2VjdGlvblByb3BzLFxuICAgICAgICAuLi5ncmlkTmF2UmV0MVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRyZW4sIHJldHVybk51bGwsIHVzZUdyaWROYXZpZ2F0aW9uLCBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvLCB1c2VQYXNzaXZlU3RhdGUsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbywgdXNlU29ydGFibGVDaGlsZHJlbiwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm8sIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ncmlkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IENvbXBhcmUsIEdldEluZGV4LCBHZXRWYWx1ZSwgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwiZ3JpZE5hdmlnYXRpb25cIj4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0U2VjdGlvblBhcmFtZXRlcnMgeyBjb21wYXJlUm93czogKGxoc0luZGV4OiBudW1iZXIsIHJoc0luZGV4OiBudW1iZXIpID0+IG51bWJlciB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8VXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwge30+LCBcInN1YkluZm9cIj4ge1xuICAgIGdyaWRsaXN0Um93OiBQaWNrPFVzZUdyaWRsaXN0Um93U3ViSW5mbzxDZWxsRWxlbWVudD4sIFwibG9jYXRpb25JbmRleFwiPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RDaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIFVzZUdyaWRsaXN0Q2hpbGRTdWJJbmZvLCBuZXZlciwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgVXNlR3JpZGxpc3RDaGlsZFN1YkluZm8+IHtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJvd1N1YkluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbG9jYXRpb25JbmRleDogbnVtYmVyO1xuICAgIGdldENlbGxzKCk6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDZWxsRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZUdyaWRsaXN0Q2hpbGRTdWJJbmZvPj4sIFwidGFiYmFibGVcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RDaGlsZFN1YkluZm8ge1xuICAgIGxvY2F0aW9uSW5kZXg6IG51bWJlcjtcbn1cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdENoaWxkUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFVzZUdyaWRsaXN0Q2hpbGRTdWJJbmZvLCBuZXZlcj4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+LCBuZXZlciwgW10+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBVc2VHcmlkbGlzdFJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBuZXZlcj4geyB9XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IHVzZUdyaWRsaXN0Q2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PjsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZUdyaWRsaXN0Q2hpbGQ6IFVzZUdyaWRsaXN0Q2hpbGQ8Q2VsbEVsZW1lbnQ+OyB1c2VHcmlkbGlzdFJvd1Byb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PjsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZGxpc3RTZWN0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHsgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PiB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0UmV0dXJuVHlwZVdpdGhIb29rczxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWRsaXN0UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcbiAgICB1c2VHcmlkbGlzdFJvdzogVXNlR3JpZGxpc3RSb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xuICAgIHVzZUdyaWRsaXN0U2VjdGlvbjogVXNlR3JpZGxpc3RTZWN0aW9uPEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xuICAgIHVzZUdyaWRsaXN0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RFbGVtZW50Pjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlR3JpZGxpc3RDaGlsZDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZUdyaWRsaXN0Q2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50PikgPT4gVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+O1xuZXhwb3J0IHR5cGUgVXNlR3JpZGxpc3RSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PikgPT4gVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcbmV4cG9ydCB0eXBlIFVzZUdyaWRsaXN0U2VjdGlvbjxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VHcmlkbGlzdFNlY3Rpb25QYXJhbWV0ZXJzKSA9PiBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xuXG5mdW5jdGlvbiBpZGVudGl0eSh0OiBudW1iZXIpIHsgcmV0dXJuIHQ7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWRsaXN0PFxuICAgIEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnRcbj4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9OiBVc2VHcmlkbGlzdFBhcmFtZXRlcnMpOiBVc2VHcmlkbGlzdFJldHVyblR5cGVXaXRoSG9va3M8R3JpZGxpc3RFbGVtZW50LCBCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgZGVidWdMb2coXCJ1c2VHcmlkbGlzdFwiKTtcblxuICAgIGNvbnN0IFtnZXRDdXJyZW50U29ydENvbHVtbiwgc2V0Q3VycmVudFNvcnRDb2x1bW5dID0gdXNlUGFzc2l2ZVN0YXRlPHsgaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIgfSB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IGJvZHlTb3J0ID0gdXNlUmVmPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwpO1xuXG4gICAgLy8gVE9ETzogQ29tcGFyaW5nIHRoZSBsb2NhdGlvbiBzaG91bGQgaGFwcGVuIG91dCBoZXJlLCBub3QgaW4gZWFjaCBzZWN0aW9uIHNvIHRoYXQgZ3JpZCBuYXZpZ2F0aW9uIHdvcmtzIHJpZ2h0Li4uXG4gICAgY29uc3QgbWFuZ2xlcnMgPSB1c2VSZWYoeyByb3dJbmRleE1hbmdsZXI6IGlkZW50aXR5LCByb3dJbmRleERlbWFuZ2xlcjogaWRlbnRpdHkgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxuICAgICAgICAuLi5ncmlkTmF2UmV0MVxuICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbjxHcmlkbGlzdEVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VHcmlkbGlzdFJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBVc2VHcmlkbGlzdENoaWxkU3ViSW5mbywgbmV2ZXIsIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBncmlkTmF2aWdhdGlvbjogeyByb3dJbmRleERlbWFuZ2xlcjogdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gbWFuZ2xlcnMuY3VycmVudC5yb3dJbmRleERlbWFuZ2xlcihuKSwgW10pLCByb3dJbmRleE1hbmdsZXI6IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IG1hbmdsZXJzLmN1cnJlbnQucm93SW5kZXhNYW5nbGVyKG4pLCBbXSkgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiByb3dzIH0gfSA9IGdyaWROYXZSZXQxO1xuXG4gICAgY29uc3QgdXNlR3JpZGxpc3RSb3cgPSB1c2VDYWxsYmFjazxVc2VHcmlkbGlzdFJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb24sIGFzUGFyZW50Um93T2ZDZWxscywgZ3JpZGxpc3RSb3c6IHsgbG9jYXRpb25JbmRleCB9IH06IFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4pOiBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VHcmlkbGlzdFJvd1wiLCBhc0NoaWxkUm93T2ZTZWN0aW9uLm1hbmFnZWRDaGlsZC5pbmRleCk7XG5cbiAgICAgICAgY29uc3QgZ2V0Q2VsbHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMsXG4gICAgICAgICAgICAuLi5ncmlkTmF2UmV0MlxuICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7IC4uLmFzQ2hpbGRSb3dPZlNlY3Rpb24sIHN1YkluZm86IHsgZ2V0Q2VsbHMsIGxvY2F0aW9uSW5kZXggfSB9LCBhc1BhcmVudFJvd09mQ2VsbHMgfSk7XG5cbiAgICAgICAgY29uc3QgeyBhc1BhcmVudE9mQ2VsbHM6IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBjZWxscyB9IH0gfSA9IGdyaWROYXZSZXQyO1xuXG4gICAgICAgIGNvbnN0IHVzZUdyaWRsaXN0Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VHcmlkbGlzdENoaWxkPENlbGxFbGVtZW50Pj4oKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm8sIGhhc0ZvY3VzIH0pID0+IHtcbiAgICAgICAgICAgIGRlYnVnTG9nKFwidXNlR3JpZGxpc3RDaGlsZFwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzLFxuICAgICAgICAgICAgICAgIC4uLmdyaWROYXZSZXQzXG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25DZWxsKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm8sIGhhc0ZvY3VzIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB1c2VHcmlkbGlzdENoaWxkUHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyA9IChwcm9wcykgPT4ge1xuICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VHcmlkbGlzdENoaWxkXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcImNlbGxcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXNlR3JpZGxpc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgICAgIC4uLmdyaWROYXZSZXQzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHVzZUdyaWRsaXN0Um93UHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzID0gKHByb3BzKSA9PiB7XG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlR3JpZGxpc3RSb3dcIiwgXCJyb2xlXCIsIHByb3BzLnJvbGUsIFwicm93XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMocHJvcHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VHcmlkbGlzdENoaWxkLFxuICAgICAgICAgICAgdXNlR3JpZGxpc3RSb3dQcm9wcyxcbiAgICAgICAgICAgIC4uLmdyaWROYXZSZXQyXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VHcmlkbGlzdFNlY3Rpb24gPSB1c2VDYWxsYmFjazxVc2VHcmlkbGlzdFNlY3Rpb248Qm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+KCh7IGNvbXBhcmVSb3dzIH0pID0+IHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VHcmlkbGlzdFNlY3Rpb25cIik7XG4gICAgICAgIHR5cGUgQyA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+O1xuICAgICAgICB0eXBlIFYgPSB7IGxvY2F0aW9uSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciB9O1xuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZUNhbGxiYWNrPEdldEluZGV4PEMsIG5ldmVyPj4oKGkpID0+IGkuaW5kZXgsIFtdKTtcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjazxHZXRWYWx1ZTxDLCBuZXZlciwgW10sIFY+PigoaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBpLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldENlbGxzKCk7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0QXQoZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uaW5kZXggPz8gMCk7XG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbkluZGV4OiBjZWxsPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5sb2NhdGlvbkluZGV4ID8/IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNlbGw/LmluZGV4ID8/IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgY29tcGFyZTogQ29tcGFyZTxWPiA9IChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbkluZGV4ID09PSByaHMubG9jYXRpb25JbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVJvd3MobGhzLmluZGV4LCByaHMuaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhdGlvbkluZGV4IC0gcmhzLmxvY2F0aW9uSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAgICAgLi4uc29ydGFibGVSZXRcbiAgICAgICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48Qm9keVNlY3Rpb25FbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZUdyaWRsaXN0Um93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdLCBWPih7XG4gICAgICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgICAgICAgICBnZXRJbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgICAgICAgICBjb21wYXJlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0IH0gfSA9IHNvcnRhYmxlUmV0O1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzb3J0KHJvd3MsIGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmRpcmVjdGlvbiA/PyAnYXNjZW5kaW5nJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc29ydF0pXG5cbiAgICAgICAgY29uc3QgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xuICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUdyaWRsaXN0U2VjdGlvblwiLCBcInJvbGVcIiwgcHJvcHMucm9sZSwgXCJyb3dncm91cFwiKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMsXG4gICAgICAgICAgICAuLi5zb3J0YWJsZVJldFxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlR3JpZGxpc3RQcm9wczogdHlwZW9mIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMgPSAocHJvcHMpID0+IHtcbiAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUdyaWRsaXN0XCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcImdyaWRcIik7XG4gICAgICAgIHJldHVybiB1c2VHcmlkTmF2aWdhdGlvblByb3BzKHByb3BzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlR3JpZGxpc3RQcm9wcyxcbiAgICAgICAgdXNlR3JpZGxpc3RTZWN0aW9uLFxuICAgICAgICB1c2VHcmlkbGlzdFJvdyxcbiAgICAgICAgLi4uZ3JpZE5hdlJldDFcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlQWNjb3JkaW9uLCBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbywgVXNlQWNjb3JkaW9uU2VjdGlvbiwgVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMsIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtYWNjb3JkaW9uXCI7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSBcIi4vaGVhZGluZ1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3JkaW9uUHJvcHMgZXh0ZW5kc1xuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBcImFjY29yZGlvblwiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uUGFyYW1ldGVycywgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XG4gICAgZXhwYW5kZWRJbmRleD86IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XG4gICAgcmVuZGVyKGluZm86IFVzZUFjY29yZGlvblJldHVyblR5cGVJbmZvKTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBY2NvcmRpb25TZWN0aW9uUHJvcHM8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PiwgXCJhY2NvcmRpb25TZWN0aW9uXCI+LFxuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXG4gICAgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LFxuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PiwgXCJidXR0b25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8sIG1ha2VIZWFkZXJQcm9wczogUHJvcE1vZGlmaWVyPEhlYWRlckVsZW1lbnQ+LCBtYWtlQm9keVByb3BzOiBQcm9wTW9kaWZpZXI8Qm9keUVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuXG5jb25zdCBBY2NvcmRpb25TZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQWNjb3JkaW9uU2VjdGlvbjxhbnksIGFueT4+KG51bGwhKTtcbmV4cG9ydCBjb25zdCBBY2NvcmRpb24gPSBtZW1vKGZ1bmN0aW9uIEFjY29yZGlvbih7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgZXhwYW5kZWRJbmRleCwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmVuZGVyIH06IEFjY29yZGlvblByb3BzKSB7XG4gICAgY29uc3QgeyB1c2VBY2NvcmRpb25TZWN0aW9uLCAuLi5wcm92aWRlciB9ID0gdXNlQWNjb3JkaW9uKHtcbiAgICAgICAgYWNjb3JkaW9uOiB7IGluaXRpYWxJbmRleCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfVxuICAgIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgcHJvdmlkZXIuYWNjb3JkaW9uLmNoYW5nZUV4cGFuZGVkSW5kZXgoZXhwYW5kZWRJbmRleCEgPz8gbnVsbCk7IH0sIFtleHBhbmRlZEluZGV4XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUFjY29yZGlvblNlY3Rpb259PntyZW5kZXIocHJvdmlkZXIpfTwvQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJBY2NvcmRpb25TZWN0aW9uPEhlYWRlckNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IG1ha2VQcm9wc0hlYWRpbmdDb250YWluZXIsIG1ha2VQcm9wc0hlYWRpbmdCdXR0b24sIG1ha2VQcm9wc0JvZHksIHRhZ0JvZHksIHRhZ0hlYWRpbmdCdXR0b24gfTogeyB0YWdIZWFkaW5nQnV0dG9uOiBFbGVtZW50VG9UYWc8SGVhZGVyQnV0dG9uRWxlbWVudD47IHRhZ0JvZHk6IEVsZW1lbnRUb1RhZzxCb2R5RWxlbWVudD47IG1ha2VQcm9wc0hlYWRpbmdDb250YWluZXIoaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyQ29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0hlYWRpbmdCdXR0b24oaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyQnV0dG9uRWxlbWVudD4sIG1ha2VQcm9wc0JvZHkoaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbywgbW9kaWZ5SGVhZGluZ0J1dHRvblByb3BzOiBQcm9wTW9kaWZpZXI8SGVhZGVyQnV0dG9uRWxlbWVudD4sIG1vZGlmeUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8SGVhZGluZzxIZWFkZXJDb250YWluZXJFbGVtZW50PiB7Li4ubWFrZVByb3BzSGVhZGluZ0NvbnRhaW5lcihpbmZvKX0gaGVhZGluZz17Y3JlYXRlRWxlbWVudCh0YWdIZWFkaW5nQnV0dG9uIGFzIG5ldmVyLCBtb2RpZnlIZWFkaW5nQnV0dG9uUHJvcHMobWFrZVByb3BzSGVhZGluZ0J1dHRvbihpbmZvKSkpfT5cbiAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnQm9keSBhcyBuZXZlciwgbW9kaWZ5Qm9keVByb3BzKG1ha2VQcm9wc0JvZHkoaW5mbykpKX1cbiAgICAgICAgICAgICAgICA8L0hlYWRpbmc+XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFjY29yZGlvblNlY3Rpb24gPSBtZW1vKGZ1bmN0aW9uIEFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG9wZW4sXG4gICAgaW5kZXgsXG4gICAgdGFnQnV0dG9uLFxuICAgIGRpc2FibGVkLFxuICAgIHJlbmRlcixcbiAgICBnZXREb2N1bWVudCxcbiAgICBnZXRXaW5kb3csXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlLFxuICAgIG9uRWxlbWVudENoYW5nZSxcbiAgICBvbkZvY3VzZWRDaGFuZ2VkLFxuICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZCxcbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLFxuICAgIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLFxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsXG4gICAgb25Nb3VudCxcbiAgICBvblVubW91bnQsXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXG59OiBBY2NvcmRpb25TZWN0aW9uUHJvcHM8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+KSB7XG4gICAgY29uc3QgdXNlQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNvbnRleHQoQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHsgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcywgdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzLCAuLi5zZWN0aW9uSW5mbyB9ID0gdXNlQWNjb3JkaW9uU2VjdGlvbih7XG4gICAgICAgIGJ1dHRvbjogeyBkaXNhYmxlZCwgdGFnQnV0dG9uIH0sXG4gICAgICAgIGFjY29yZGlvblNlY3Rpb246IHsgb3BlbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXggfSxcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIoc2VjdGlvbkluZm8sIHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcywgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyk7XG59KVxuXG5cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlQ2hlY2tib3gsIFVzZUNoZWNrYm94UGFyYW1ldGVycywgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveFByb3BzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveExpa2VcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveFwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+LCBcImxhYmVsXCI+LFxuICAgIEdldDxVc2VDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4sIFwiaGFzRm9jdXNJbnB1dFwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUNoZWNrYm94UmV0dXJuVHlwZUluZm88SSwgTD4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPEw+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2U8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH06IERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIEluZm9UeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogSW5mb1R5cGUsIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPEw+KTogVk5vZGU8YW55PiB7XG5cbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFByb3BzQmFzZSA9IG1ha2VJbnB1dFByb3BzKGluZm8pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxQcm9wc0Jhc2UgPSBtYWtlTGFiZWxQcm9wcyhpbmZvKTtcblxuICAgICAgICAgICAgY29uc3QgaW5wdXRQcm9wcyA9IG1vZGlmeUlucHV0UHJvcHMoaW5wdXRQcm9wc0Jhc2UpO1xuICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ubGFiZWxQcm9wcyB9ID0gbW9kaWZ5TGFiZWxQcm9wcyhsYWJlbFByb3BzQmFzZSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQodGFnSW5wdXQgYXMgbmV2ZXIsIGlucHV0UHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCB7IC4uLmxhYmVsUHJvcHMsIGNoaWxkcmVuOiA8PntpbnB1dH17Y2hpbGRyZW59PC8+IH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRQcm9wcyA9IG1vZGlmeUlucHV0UHJvcHMobWFrZUlucHV0UHJvcHMoaW5mbykpXG4gICAgICAgICAgICBjb25zdCBsYWJlbFByb3BzID0gbW9kaWZ5TGFiZWxQcm9wcyhtYWtlTGFiZWxQcm9wcyhpbmZvKSlcblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjcmVhdGVFbGVtZW50KHRhZ0lucHV0IGFzIG5ldmVyLCBpbnB1dFByb3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbGFiZWxQcm9wcyk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAge2lucHV0fVxuICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvcHMgPSBtYWtlSW5wdXRQcm9wcyhpbmZvKTtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCEhdXNlclByb3BzW1wiYXJpYS1sYWJlbFwiXSk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgbW9kaWZ5SW5wdXRQcm9wcyh1c2VyUHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+IHtcbiAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCIgfCBcImhpZGRlblwiLFxuICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8ST4sXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMPixcbiAgICBtYWtlSW5wdXRQcm9wczogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPixcbiAgICBtYWtlTGFiZWxQcm9wczogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTCwgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJLCBMPj4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3g8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMgfTogRGVmYXVsdFJlbmRlckNoZWNrYm94UGFyYW1ldGVyczxJLCBMPikge1xuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlPEksIEwsIFVzZUNoZWNrYm94UmV0dXJuVHlwZUluZm88SSwgTD4+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMgfSk7XG59XG5cblxuXG5leHBvcnQgY29uc3QgQ2hlY2tib3ggPSBtZW1vKGZ1bmN0aW9uIENoZWNrYm94PEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGNoZWNrZWQsIGRpc2FibGVkLCB0YWdMYWJlbCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIG9uQ2hlY2tlZENoYW5nZSwgcmVuZGVyLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfTogQ2hlY2tib3hQcm9wczxJLCBMPikge1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50LCAuLi5jaGVja2JveEluZm8gfSA9IHVzZUNoZWNrYm94PEksIEw+KHtcbiAgICAgICAgY2hlY2tib3g6IHsgb25DaGVja2VkQ2hhbmdlIH0sXG4gICAgICAgIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LFxuICAgICAgICBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSxcbiAgICAgICAgaGFzRm9jdXNJbnB1dDogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSxcbiAgICAgICAgaGFzRm9jdXNMYWJlbDogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZTogb25FbGVtZW50Q2hhbmdlIGFzIGFueSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudDogb25Nb3VudCBhcyBhbnksIG9uVW5tb3VudDogb25Vbm1vdW50IGFzIGFueSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cbiAgICB9KTtcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpO1xuXG5cbiAgICByZXR1cm4gcmVuZGVyKGNoZWNrYm94SW5mbywgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcywgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyk7XG59KVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGgsIFJlbmRlcmFibGVQcm9wcywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2UsIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vY2hlY2tib3hcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgUmVuZGVyYWJsZVByb3BzPHt9PixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGVja2JveFwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImNoZWNrYm94TGlrZVwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxhYmVsXCI+IHtcbiAgICBnZXREb2N1bWVudDogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPElucHV0RWxlbWVudD5bXCJnZXREb2N1bWVudFwiXTtcbiAgICBnZXRXaW5kb3c/OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRFbGVtZW50PltcImdldFdpbmRvd1wiXTtcbiAgICByZW5kZXIoaW5mbzogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPElucHV0RWxlbWVudD4sIGxhYmVsOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImNoZWNrYm94XCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImxhYmVsXCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImNoZWNrYm94TGlrZVwiPixcbiAgICBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImFzQ2hlY2tib3hHcm91cENoaWxkXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94R3JvdXBDaGlsZFwiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJtYW5hZ2VkQ2hpbGRcIj4ge1xuICAgIGdldERvY3VtZW50OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRUeXBlPltcImdldERvY3VtZW50XCJdO1xuICAgIGdldFdpbmRvdz86IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJbnB1dFR5cGU+W1wiZ2V0V2luZG93XCJdO1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBsYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPj4ge1xuICAgIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbGFiZWxQb3NpdGlvbiwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRUeXBlPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2UoeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KShpbmZvLCBtb2RpZnlJbnB1dFByb3BzLCBtb2RpZnlMYWJlbFByb3BzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgY2hpbGRyZW4sIGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxUeXBlPik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH0pKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIG1vZGlmeUxhYmVsUHJvcHMpfVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5jb25zdCBVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VDaGVja2JveEdyb3VwQ2hpbGQ8YW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgY29uc3QgQ2hlY2tib3hHcm91cCA9IG1lbW8oZnVuY3Rpb24gQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICBkaXNhYmxlZDogcGFyZW50RGlzYWJsZWQsXG4gICAgdGFnSW5wdXQsXG4gICAgdGFnTGFiZWwsXG4gICAgcmVuZGVyLFxuICAgIGdldERvY3VtZW50LFxuICAgIGdldFdpbmRvdyxcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXJcbn06IENoZWNrYm94R3JvdXBQcm9wczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZCxcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0LFxuICAgICAgICAuLi5jaGVja2JveEdyb3VwUGFyZW50SW5mb1xuICAgIH0gPSB1c2VDaGVja2JveEdyb3VwPElucHV0VHlwZSwgTGFiZWxUeXBlPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cbiAgICB9KTtcblxuXG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMgfSA9IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCh7IGNoZWNrYm94OiB7fSwgY2hlY2tib3hMaWtlOiB7IGRpc2FibGVkOiBwYXJlbnREaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSwgaGFzRm9jdXNJbnB1dDogeyBnZXRXaW5kb3csIGdldERvY3VtZW50IH0sIGhhc0ZvY3VzTGFiZWw6IHsgZ2V0V2luZG93LCBnZXREb2N1bWVudCB9IH0pO1xuXG5cbiAgICBsZXQgd3JhcHBpbmc6IFZOb2RlPGFueT47XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIHdyYXBwaW5nID0gcmVuZGVyKGNoZWNrYm94R3JvdXBQYXJlbnRJbmZvLCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3JhcHBpbmcgPSByZW5kZXIoY2hlY2tib3hHcm91cFBhcmVudEluZm8sIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUNoZWNrYm94R3JvdXBDaGlsZH0+e3dyYXBwaW5nfTwvVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuXG5leHBvcnQgY29uc3QgQ2hlY2tib3hHcm91cENoZWNrYm94ID0gbWVtbyhmdW5jdGlvbiBDaGVja2JveEdyb3VwQ2hlY2tib3g8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgY2hlY2tlZCxcbiAgICBkaXNhYmxlZCxcbiAgICBpbmRleCxcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIHRhZ0lucHV0LFxuICAgIHRhZ0xhYmVsLFxuICAgIHRleHQsXG4gICAgZ2V0V2luZG93LFxuICAgIGdldERvY3VtZW50LFxuICAgIGZsYWdzLFxuICAgIGZvY3VzU2VsZixcbiAgICBoaWRkZW4sXG4gICAgb25DaGVja2VkQ2hhbmdlLFxuICAgIHJlbmRlclxufTogQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzLCAuLi5jaGVja2JveEdyb3VwQ2hpbGRJbmZvIH0gPSB1c2VDb250ZXh0KFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQpKHtcbiAgICAgICAgYXNDaGVja2JveDoge1xuICAgICAgICAgICAgY2hlY2tib3g6IHsgb25DaGVja2VkQ2hhbmdlIH0sXG4gICAgICAgICAgICBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSxcbiAgICAgICAgICAgIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9LFxuICAgICAgICAgICAgaGFzRm9jdXNJbnB1dDogeyBnZXRXaW5kb3csIGdldERvY3VtZW50IH0sXG4gICAgICAgICAgICBoYXNGb2N1c0xhYmVsOiB7IGdldFdpbmRvdywgZ2V0RG9jdW1lbnQgfVxuICAgICAgICB9LFxuICAgICAgICBhc0NoZWNrYm94R3JvdXBDaGlsZDoge1xuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3NcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgICAgICBoaWRkZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIHJldHVybiByZW5kZXIoY2hlY2tib3hHcm91cENoaWxkSW5mbywgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVuZGVyKGNoZWNrYm94R3JvdXBDaGlsZEluZm8sIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMpO1xuICAgIH1cbn0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwsIG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcbmltcG9ydCB7IHVzZURpYWxvZywgVXNlRGlhbG9nUGFyYW1ldGVycywgVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWRpYWxvZ1wiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIERpYWxvZ1Byb3BzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VEaWFsb2dQYXJhbWV0ZXJzLCBcInNvZnREaXNtaXNzXCI+LFxuICAgIEdldDxVc2VEaWFsb2dQYXJhbWV0ZXJzLCBcIm1vZGFsXCI+LFxuICAgIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLFxuICAgIEdldDxVc2VEaWFsb2dQYXJhbWV0ZXJzLCBcImRpYWxvZ1wiPiB7XG5cbiAgICByZW5kZXIoZGlhbG9nSW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8sIG1vZGlmeUZvY3VzQ29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtb2RpZnlEaWFsb2dQcm9wczogUHJvcE1vZGlmaWVyPERpYWxvZ0VsZW1lbnQ+LCBtb2RpZnlUaXRsZVByb3BzOiBQcm9wTW9kaWZpZXI8VGl0bGVFbGVtZW50PiwgbW9kaWZ5Qm9keVByb3BzOiBQcm9wTW9kaWZpZXI8Qm9keUVsZW1lbnQ+LCBtb2RpZnlCYWNrZHJvcFByb3BzOiBQcm9wTW9kaWZpZXI8QmFja2Ryb3BFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUG9ydGFsKHsgcG9ydGFsSWQsIGNoaWxkcmVuIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgY2hpbGRyZW46IFZOb2RlIH0pIHtcbiAgICBjb25zdCBwb3J0YWxSZWYgPSB1c2VSZWY8SFRNTEVsZW1lbnQ+KG51bGwhKTtcbiAgICBwb3J0YWxSZWYuY3VycmVudCA/Pz0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocG9ydGFsSWQpITtcbiAgICBpZiAocG9ydGFsUmVmLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbFJlZi5jdXJyZW50KTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNEaWFsb2c6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RGlhbG9nRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+LCBtYWtlUHJvcHNCYWNrZHJvcDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpYWxvZ0luZm86IEluZm9UeXBlLCBtb2RpZnlGb2N1c0NvbnRhaW5lclByb3BzOiBQcm9wTW9kaWZpZXI8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgbW9kaWZ5RGlhbG9nUHJvcHM6IFByb3BNb2RpZmllcjxEaWFsb2dFbGVtZW50PiwgbW9kaWZ5VGl0bGVQcm9wczogUHJvcE1vZGlmaWVyPFRpdGxlRWxlbWVudD4sIG1vZGlmeUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPEJvZHlFbGVtZW50PiwgbW9kaWZ5QmFja2Ryb3BQcm9wczogUHJvcE1vZGlmaWVyPEJhY2tkcm9wRWxlbWVudD4pOiBWTm9kZTxhbnk+IHtcblxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiB0aXRsZUNoaWxkcmVuLCAuLi50aXRsZVByb3BzIH0gPSBtb2RpZnlUaXRsZVByb3BzKG1ha2VQcm9wc1RpdGxlKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogYm9keUNoaWxkcmVuLCAuLi5ib2R5UHJvcHMgfSA9IG1vZGlmeUJvZHlQcm9wcyhtYWtlUHJvcHNCb2R5KGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZGlhbG9nQ2hpbGRyZW4sIC4uLmRpYWxvZ1Byb3BzIH0gPSBtb2RpZnlEaWFsb2dQcm9wcyhtYWtlUHJvcHNEaWFsb2coZGlhbG9nSW5mbykpO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBiYWNrZHJvcENoaWxkcmVuLCAuLi5iYWNrZHJvcFByb3BzIH0gPSBtb2RpZnlCYWNrZHJvcFByb3BzKG1ha2VQcm9wc0JhY2tkcm9wKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZm9jdXNDb250YWluZXJDaGlsZHJlbiwgLi4uZm9jdXNDb250YWluZXJQcm9wcyB9ID0gbW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wcyhtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcihkaWFsb2dJbmZvKSk7XG5cbiAgICAgICAgY29uc3QgdGl0bGUgPSBjcmVhdGVFbGVtZW50KHRhZ1RpdGxlIGFzIG5ldmVyLCB0aXRsZVByb3BzLCB0aXRsZUNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUVsZW1lbnQodGFnQm9keSBhcyBuZXZlciwgYm9keVByb3BzLCBib2R5Q2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBjcmVhdGVFbGVtZW50KHRhZ0RpYWxvZyBhcyBuZXZlciwgZGlhbG9nUHJvcHMsIGRpYWxvZ0NoaWxkcmVuLCB0aXRsZSwgYm9keSk7XG5cbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSBjcmVhdGVFbGVtZW50KHRhZ0JhY2tkcm9wIGFzIG5ldmVyLCBiYWNrZHJvcFByb3BzLCBiYWNrZHJvcENoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgZm9jdXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KHRhZ0ZvY3VzQ29udGFpbmVyIGFzIG5ldmVyLCBmb2N1c0NvbnRhaW5lclByb3BzLCA8ZGl2Pntmb2N1c0NvbnRhaW5lckNoaWxkcmVufXtkaWFsb2d9e2JhY2tkcm9wfTwvZGl2Pik7XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJQb3J0YWwoe1xuICAgICAgICAgICAgcG9ydGFsSWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogZm9jdXNDb250YWluZXJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNEaWFsb2c6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RGlhbG9nRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+LCBtYWtlUHJvcHNCYWNrZHJvcDogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50LCBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbz4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBEaWFsb2cgPSBtZW1vKGZ1bmN0aW9uIERpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICBvbkNsb3NlLFxuICAgIG9wZW4sXG4gICAgYm9keUlzT25seVNlbWFudGljLFxuICAgIGdldERvY3VtZW50LFxuICAgIGdldFdpbmRvdyxcbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSxcbiAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsXG4gICAgZm9jdXNTZWxmLFxuICAgIHJlbmRlclxufTogRGlhbG9nUHJvcHM8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+KSB7XG4gICAgY29uc3Qge1xuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcCxcbiAgICAgICAgdXNlRGlhbG9nQm9keSxcbiAgICAgICAgdXNlRGlhbG9nUHJvcHMsXG4gICAgICAgIHVzZURpYWxvZ1RpdGxlLFxuICAgICAgICB1c2VEaWFsb2dGb2N1c0NvbnRhaW5lclByb3BzLFxuICAgICAgICAuLi5yXG4gICAgfSA9IHVzZURpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4oeyBkaWFsb2c6IHsgb25DbG9zZSB9LCBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWMsIGZvY3VzU2VsZiB9LCBzb2Z0RGlzbWlzczogeyBvcGVuIH0sIGFjdGl2ZUVsZW1lbnQ6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSB9KTtcblxuICAgIGNvbnN0IHsgdXNlRGlhbG9nVGl0bGVQcm9wcyB9ID0gdXNlRGlhbG9nVGl0bGUoKTtcbiAgICBjb25zdCB7IHVzZURpYWxvZ0JvZHlQcm9wcyB9ID0gdXNlRGlhbG9nQm9keSgpO1xuICAgIGNvbnN0IHsgdXNlRGlhbG9nQmFja2Ryb3BQcm9wcyB9ID0gdXNlRGlhbG9nQmFja2Ryb3AoKTtcblxuICAgIHJldHVybiByZW5kZXIociwgdXNlRGlhbG9nRm9jdXNDb250YWluZXJQcm9wcywgdXNlRGlhbG9nUHJvcHMsIHVzZURpYWxvZ1RpdGxlUHJvcHMsIHVzZURpYWxvZ0JvZHlQcm9wcywgdXNlRGlhbG9nQmFja2Ryb3BQcm9wcyk7XG5cbn0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuLy9pbXBvcnQgeyBFbGVtZW50VG9UYWcgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxpc3Rib3hTaW5nbGUsIHVzZUxpc3Rib3hHcm91cCwgVXNlTGlzdGJveFNpbmdsZUl0ZW0sIFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVycywgVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbywgVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnMsIFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1zaW5nbGVcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcInNpbmdsZVNlbGVjdGlvblwiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImNoaWxkcmVuSGF2ZUZvY3VzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJsaXN0Ym94U2luZ2xlXCI+IHtcbiAgICAvL3RhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcbiAgICByZW5kZXIoaW5mbzogVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4sIG1vZGlmeVByb3BzTGFiZWw6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc0xpc3Q6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3Rib3hJdGVtRWxlbWVudD4sIFwibWFuYWdlZENoaWxkXCI+LFxuICAgIE9taXQ8R2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LCBcInN1YkluZm9cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJoYXNGb2N1c1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3Rib3hJdGVtRWxlbWVudD4sIFwibGlzdGJveFNpbmdsZUl0ZW1cIj4ge1xuICAgIC8vdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3Rib3hJdGVtRWxlbWVudD4sIG1vZGlmeUxpc3RJdGVtUHJvcHM6IFByb3BNb2RpZmllcjxMaXN0Ym94SXRlbUVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuY29uc3QgTGlzdGJveFNpbmdsZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUxpc3Rib3hTaW5nbGVJdGVtPGFueT4+KG51bGwhKTtcblxuZnVuY3Rpb24gTGlzdGJveFNpbmdsZVU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICByZW5kZXIsXG5cbiAgICBzZWxlY3RlZEluZGV4LFxuICAgIHRhZ0xhYmVsLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXIsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBvbkFsbExvc3RGb2N1cyxcbiAgICBvbkFueUdhaW5lZEZvY3VzLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgdGFnTGlzdCxcbiAgICBvblNlbGVjdFxufTogTGlzdGJveFNpbmdsZVByb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtLFxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyxcbiAgICAgICAgLi4ubGlzdGJveFJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbGlzdGJveFNpbmdsZTogeyB0YWdMYWJlbCwgdGFnTGlzdCwgb25TZWxlY3QgfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH0sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfSA9IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpO1xuICAgIC8vY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsLCB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyh7fSkgYXMgYW55KTtcbiAgICAvL2NvbnN0IGxpc3QgPSBjcmVhdGVFbGVtZW50KHRhZ0xpc3QsIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyh7IGNoaWxkcmVuOiB2bm9kZUNoaWxkcmVuLCByZWYgfSkgYXMgYW55KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPExpc3Rib3hTaW5nbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VMaXN0Ym94U2luZ2xlSXRlbX0+XG4gICAgICAgICAgICB7cmVuZGVyKHsgLi4ubGlzdGJveFJldHVyblR5cGUgfSwgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMsIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyl9XG4gICAgICAgIDwvTGlzdGJveFNpbmdsZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0LCBtYWtlUHJvcHNMYWJlbCwgdGFnTGFiZWwsIHRhZ0xpc3QgfTogeyB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0xpc3Q6IChpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckxpc3Q8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4+KHsgbWFrZVByb3BzTGFiZWwsIG1ha2VQcm9wc0xpc3QsIHRhZ0xhYmVsLCB0YWdMaXN0IH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgbWFrZVByb3BzTGlzdEl0ZW0sIHRhZ0xpc3RJdGVtIH06IHsgdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0SXRlbUVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0SXRlbTogKGluZm86IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJMaXN0SXRlbTxMaXN0SXRlbUVsZW1lbnQsIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50Pj4oeyBtYWtlUHJvcHNMaXN0SXRlbSwgdGFnTGlzdEl0ZW0gfSk7XG59XG5cblxuXG5mdW5jdGlvbiBMaXN0Ym94U2luZ2xlSXRlbVU8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgZGlzYWJsZWQsIGZsYWdzLCBmb2N1c1NlbGYsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyLCB0ZXh0LCBoaWRkZW4gfTogTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxMaXN0SXRlbUVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzLCByb3ZpbmdUYWJJbmRleCwgc2luZ2xlU2VsZWN0aW9uIH0gPSB1c2VDb250ZXh0KExpc3Rib3hTaW5nbGVDb250ZXh0KSh7XG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9LFxuICAgICAgICBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD57cmVuZGVyKHsgcm92aW5nVGFiSW5kZXgsIHNpbmdsZVNlbGVjdGlvbiB9LCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzKX08Lz5cbiAgICApXG59XG5cbmV4cG9ydCBjb25zdCBMaXN0Ym94U2luZ2xlID0gbWVtbyhMaXN0Ym94U2luZ2xlVSkgYXMgdHlwZW9mIExpc3Rib3hTaW5nbGVVO1xuZXhwb3J0IGNvbnN0IExpc3Rib3hTaW5nbGVJdGVtID0gbWVtbyhMaXN0Ym94U2luZ2xlSXRlbVUpIGFzIHR5cGVvZiBMaXN0Ym94U2luZ2xlSXRlbVU7XG5leHBvcnQgY29uc3QgTGlzdGJveEdyb3VwID0gbWVtbyhMaXN0Ym94R3JvdXBVKSBhcyB0eXBlb2YgTGlzdGJveEdyb3VwVTtcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94R3JvdXBQcm9wczxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJlbmRlcihtb2RpZnlDb250YWluZXJQcm9wczogUHJvcE1vZGlmaWVyPENvbnRhaW5lckVsZW1lbnQ+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5mdW5jdGlvbiBMaXN0Ym94R3JvdXBVPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciB9OiBMaXN0Ym94R3JvdXBQcm9wczxDb250YWluZXJFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMsIHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzIH0gPSB1c2VMaXN0Ym94R3JvdXA8Q29udGFpbmVyRWxlbWVudCwgTGFiZWxFbGVtZW50PigpO1xuICAgIHJldHVybiAocmVuZGVyKHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzLCB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdExpc3Rib3hHcm91cFJlbmRlcjxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdDb250YWluZXIsIHRhZ0xhYmVsLCBtYWtlUHJvcHNDb250YWluZXIsIG1ha2VQcm9wc0xhYmVsIH06IHsgdGFnQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Q29udGFpbmVyRWxlbWVudD4sIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzQ29udGFpbmVyOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZ5Q29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxDb250YWluZXJFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4pIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucHJvcHNDb250YWluZXIgfSA9IG1vZGlmeUNvbnRhaW5lclByb3BzKG1ha2VQcm9wc0NvbnRhaW5lcigpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnQ29udGFpbmVyIGFzIG5ldmVyLCBwcm9wc0NvbnRhaW5lciwgPD5cbiAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKCkpKX1cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC8+KVxuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTGlzdDxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbmZvVHlwZT4oeyBtYWtlUHJvcHNMaXN0LCBtYWtlUHJvcHNMYWJlbCwgdGFnTGFiZWwsIHRhZ0xpc3QgfTogeyB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0xpc3Q6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IEluZm9UeXBlLCBtb2RpZnlQcm9wc0xhYmVsOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5UHJvcHNMaXN0OiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNMYWJlbChtYWtlUHJvcHNMYWJlbChpbmZvKSkpO1xuICAgICAgICBjb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdMaXN0IGFzIG5ldmVyLCBtb2RpZnlQcm9wc0xpc3QobWFrZVByb3BzTGlzdChpbmZvKSkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAge2xpc3R9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0SXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgbWFrZVByb3BzTGlzdEl0ZW0sIHRhZ0xpc3RJdGVtIH06IHsgdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0SXRlbUVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0SXRlbTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IEluZm9UeXBlLCBtb2RpZnlQcm9wc0xpc3RJdGVtOiBQcm9wTW9kaWZpZXI8TGlzdEl0ZW1FbGVtZW50Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdMaXN0SXRlbSBhcyBuZXZlciwgbW9kaWZ5UHJvcHNMaXN0SXRlbShtYWtlUHJvcHNMaXN0SXRlbShpbmZvKSkpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlTWVudSwgVXNlTWVudUl0ZW1QYXJhbWV0ZXJzLCBVc2VNZW51SXRlbVJldHVyblR5cGVJbmZvLCBVc2VNZW51UGFyYW1ldGVycywgVXNlTWVudVJldHVyblR5cGVJbmZvLCBVc2VNZW51SXRlbSB9IGZyb20gXCIuLi91c2UtbWVudVwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVQcm9wczxTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU2VudGluZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgLy9PbWl0PFVzZU1lbnVQYXJhbWV0ZXJzPEUsIEssIEk+LCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiIHwgXCJvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcIiB8IFwib25DaGlsZHJlbk1vdW50Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVJbmRleENoYW5nZVwiIHwgXCJvblRhYmJhYmxlUmVuZGVyXCIgfCBcIm9uVGFiYmVkSW5Ub1wiIHwgXCJvblRhYmJlZE91dE9mXCI+ICYge1xuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcIm1lbnVcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwibWVudVN1cmZhY2VcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwic29mdERpc21pc3NcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxuXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwibWFuYWdlZENoaWxkcmVuXCI+IHtcbiAgICAvL3Byb3BzTWVudUJ1dHRvbjogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcbiAgICAvL3Byb3BzTWVudVNlbnRpbmVsOiAod2hpY2g6IFwidG9wXCIgfCBcImJvdHRvbVwiKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuICAgIC8vcHJvcHNNZW51OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuXG4gICAgLy90YWdNZW51QnV0dG9uOiBhbnk7XG4gICAgLy90YWdNZW51OiBhbnk7XG4gICAgLy90YWdTZW50aW5lbDogYW55O1xuXG4gICAgZ2V0RG9jdW1lbnQ6IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wiZ2V0RG9jdW1lbnRcIl07XG4gICAgZ2V0V2luZG93PzogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJnZXRXaW5kb3dcIl07XG5cbiAgICByZW5kZXIobWVudUluZm86IFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4sIG1vZGlmeU1lbnVCdXR0b25Qcm9wczogUHJvcE1vZGlmaWVyPEJ1dHRvbkVsZW1lbnQ+LCBtb2RpZnlNZW51U3VyZmFjZVByb3BzOiBQcm9wTW9kaWZpZXI8U3VyZmFjZUVsZW1lbnQ+LCBtb2RpZnlNZW51UHJvcHM6IFByb3BNb2RpZmllcjxNZW51RWxlbWVudD4sIG1vZGlmeUZpcnN0U2VudGluZWxQcm9wczogUHJvcE1vZGlmaWVyPFNlbnRpbmVsRWxlbWVudD4sIG1vZGlmeUxhc3RTZW50aW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8U2VudGluZWxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VNZW51SXRlbVBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkXCI+LFxuICAgIEdldDxVc2VNZW51SXRlbVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZU1lbnVJdGVtUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiwgbW9kaWZ5TGlzdEl0ZW1Qcm9wczogUHJvcE1vZGlmaWVyPE1lbnVJdGVtRWxlbWVudD4pOiBWTm9kZTtcbiAgICAvL3RhZ01lbnVJdGVtOiBhbnk7XG4gICAgLy9wcm9wc01lbnVJdGVtOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+XG59XG5cbmNvbnN0IE1lbnVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTWVudUl0ZW08YW55Pj4obnVsbCEpO1xuXG5leHBvcnQgY29uc3QgTWVudSA9IG1lbW8oZnVuY3Rpb24gTWVudTxTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluaXRpYWxJbmRleCxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgb25PcGVuLFxuICAgIG9uQ2xvc2UsXG4gICAgb3BlbixcblxuICAgIG9wZW5EaXJlY3Rpb24sXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXIsXG5cbiAgICBnZXREb2N1bWVudCxcbiAgICBnZXRXaW5kb3csXG5cbiAgICByZW5kZXJcblxufTogTWVudVByb3BzPFN1cmZhY2VFbGVtZW50LCBQYXJlbnRFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZU1lbnVCdXR0b25Qcm9wcyxcbiAgICAgICAgdXNlTWVudUl0ZW0sXG4gICAgICAgIHVzZU1lbnVQcm9wcyxcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsLFxuICAgICAgICB1c2VNZW51U3VyZmFjZVByb3BzLFxuICAgICAgICAuLi5tZW51UmV0dXJuXG4gICAgfSA9IHVzZU1lbnU8U3VyZmFjZUVsZW1lbnQsIFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQnV0dG9uRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICBtZW51OiB7IG9uT3BlbjogdXNlU3RhYmxlQ2FsbGJhY2sob25PcGVuKSwgb3BlbkRpcmVjdGlvbiB9LFxuICAgICAgICBtZW51U3VyZmFjZToge30sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQ2xvc2U6IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpLCBvcGVuIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH0sXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9LFxuICAgICAgICBtZW51QnV0dG9uSGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiB1c2VGaXJzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbDxTZW50aW5lbEVsZW1lbnQ+KCk7XG4gICAgY29uc3QgeyB1c2VNZW51U2VudGluZWxQcm9wczogdXNlTGFzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbDxTZW50aW5lbEVsZW1lbnQ+KCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPE1lbnVJdGVtQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlTWVudUl0ZW19PlxuICAgICAgICAgICAge3JlbmRlcihtZW51UmV0dXJuLCB1c2VNZW51QnV0dG9uUHJvcHMsIHVzZU1lbnVTdXJmYWNlUHJvcHMsIHVzZU1lbnVQcm9wcywgdXNlRmlyc3RTZW50aW5lbFByb3BzLCB1c2VMYXN0U2VudGluZWxQcm9wcyl9XG4gICAgICAgIDwvTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcblxufSlcblxuZXhwb3J0IGNvbnN0IE1lbnVJdGVtID0gbWVtbyhmdW5jdGlvbiBNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciwgaW5kZXgsIHRleHQsIGhpZGRlbiwgZmxhZ3MsIGZvY3VzU2VsZiB9OiBNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLnJlc3QgfSA9IHVzZUNvbnRleHQoTWVudUl0ZW1Db250ZXh0KSh7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlbmRlcihyZXN0LCB1c2VNZW51SXRlbVByb3BzKTtcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWVudTxTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU2VudGluZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcG9ydGFsSWQsIHRhZ0J1dHRvbiwgdGFnTWVudSwgdGFnU3VyZmFjZSwgdGFnU2VudGluZWwsIG1ha2VQcm9wc0J1dHRvbiwgbWFrZVByb3BzTWVudSwgbWFrZVByb3BzU3VyZmFjZSwgbWFrZVByb3BzU2VudGluZWwgfTogeyBwb3J0YWxJZDogc3RyaW5nLCB0YWdTdXJmYWNlOiBFbGVtZW50VG9UYWc8U3VyZmFjZUVsZW1lbnQ+LCB0YWdNZW51OiBFbGVtZW50VG9UYWc8TWVudUVsZW1lbnQ+LCB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxCdXR0b25FbGVtZW50PiwgdGFnU2VudGluZWw6IEVsZW1lbnRUb1RhZzxTZW50aW5lbEVsZW1lbnQ+LCBtYWtlUHJvcHNTdXJmYWNlOiAoaW5mbzogVXNlTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8U3VyZmFjZUVsZW1lbnQ+LCBtYWtlUHJvcHNNZW51OiAoaW5mbzogVXNlTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUVsZW1lbnQ+LCBtYWtlUHJvcHNCdXR0b246IChpbmZvOiBVc2VNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCdXR0b25FbGVtZW50PiwgbWFrZVByb3BzU2VudGluZWw6IChpbmZvOiBVc2VNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTZW50aW5lbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lbnVJbmZvOiBVc2VNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+LCBtb2RpZnlNZW51QnV0dG9uUHJvcHM6IFByb3BNb2RpZmllcjxCdXR0b25FbGVtZW50PiwgbW9kaWZ5TWVudVN1cmZhY2VQcm9wczogUHJvcE1vZGlmaWVyPFN1cmZhY2VFbGVtZW50PiwgbW9kaWZ5TWVudVByb3BzOiBQcm9wTW9kaWZpZXI8TWVudUVsZW1lbnQ+LCBtb2RpZnlGaXJzdFNlbnRpbmVsUHJvcHM6IFByb3BNb2RpZmllcjxTZW50aW5lbEVsZW1lbnQ+LCBtb2RpZnlMYXN0U2VudGluZWxQcm9wczogUHJvcE1vZGlmaWVyPFNlbnRpbmVsRWxlbWVudD4pIHtcblxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzdXJmYWNlQ2hpbGRyZW4sIC4uLnN1cmZhY2VQcm9wcyB9ID0gbW9kaWZ5TWVudVN1cmZhY2VQcm9wcyhtYWtlUHJvcHNTdXJmYWNlKG1lbnVJbmZvKSk7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IG1lbnVDaGlsZHJlbiwgLi4ubWVudVByb3BzIH0gPSBtb2RpZnlNZW51UHJvcHMobWFrZVByb3BzTWVudShtZW51SW5mbykpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdCdXR0b24gYXMgbmV2ZXIsIG1vZGlmeU1lbnVCdXR0b25Qcm9wcyhtYWtlUHJvcHNCdXR0b24obWVudUluZm8pKSl9XG4gICAgICAgICAgICAgICAge2RlZmF1bHRSZW5kZXJQb3J0YWwoe1xuICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGNyZWF0ZUVsZW1lbnQodGFnU3VyZmFjZSBhcyBuZXZlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3VyZmFjZVByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46ICg8PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ1NlbnRpbmVsIGFzIG5ldmVyLCBtb2RpZnlGaXJzdFNlbnRpbmVsUHJvcHMobWFrZVByb3BzU2VudGluZWwobWVudUluZm8pKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3N1cmZhY2VDaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdNZW51IGFzIG5ldmVyLCB7IC4uLm1lbnVQcm9wcywgY2hpbGRyZW46IDw+e21lbnVDaGlsZHJlbn08Lz4gfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnU2VudGluZWwgYXMgbmV2ZXIsIG1vZGlmeUxhc3RTZW50aW5lbFByb3BzKG1ha2VQcm9wc1NlbnRpbmVsKG1lbnVJbmZvKSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC8+KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcblxuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzTWVudUl0ZW06IG1ha2VQcm9wc01lbnVJdGVtLCB0YWdNZW51SXRlbSB9OiB7IHRhZ01lbnVJdGVtOiBFbGVtZW50VG9UYWc8TWVudUl0ZW1FbGVtZW50PiwgbWFrZVByb3BzTWVudUl0ZW06IChpbmZvOiBVc2VNZW51SXRlbVJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVJdGVtRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+LCBtb2RpZnlNZW51SXRlbVByb3BzOiBQcm9wTW9kaWZpZXI8TWVudUl0ZW1FbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdNZW51SXRlbSBhcyBuZXZlciwgbW9kaWZ5TWVudUl0ZW1Qcm9wcyhtYWtlUHJvcHNNZW51SXRlbShpbmZvKSkpXG4gICAgfVxufSIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VSYWRpb0dyb3VwLCBVc2VSYWRpb0dyb3VwUGFyYW1ldGVycywgVXNlUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvLCBVc2VSYWRpb1BhcmFtZXRlcnMsIFVzZVJhZGlvLCBVc2VSYWRpb1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1yYWRpby1ncm91cFwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSwgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jaGVja2JveFwiXG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmFkaW9Hcm91cFByb3BzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50PiwgXCJyYWRpb0dyb3VwXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcImNoaWxkcmVuSGF2ZUZvY3VzXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIC8vcHJvcHNHcm91cExhYmVsOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cExhYmVsRWxlbWVudD47XG4gICAgLy9wcm9wc0dyb3VwOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cEVsZW1lbnQ+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSW5wdXRFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPEdyb3VwTGFiZWxFbGVtZW50PiwgbW9kaWZ5R3JvdXBQcm9wczogUHJvcE1vZGlmaWVyPEdyb3VwRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvUHJvcHM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJoYXNGb2N1c0lucHV0XCI+LFxuICAgIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQ+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQ+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJhZGlvR3JvdXA8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcm91cCwgdGFnTGFiZWwsIG1ha2VQcm9wc0dyb3VwLCBtYWtlUHJvcHNMYWJlbCB9OiB7IHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnR3JvdXA6IEVsZW1lbnRUb1RhZzxJbnB1dEVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKGluZm86IFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbzxWLCBJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNHcm91cDogKGluZm86IFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbzxWLCBJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbzxWLCBJbnB1dEVsZW1lbnQ+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5R3JvdXBQcm9wczogUHJvcE1vZGlmaWVyPElucHV0RWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIG1vZGlmeUxhYmVsUHJvcHMobWFrZVByb3BzTGFiZWwoaW5mbykpKX1cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdHcm91cCBhcyBuZXZlciwgbW9kaWZ5R3JvdXBQcm9wcyhtYWtlUHJvcHNHcm91cChpbmZvKSkpfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmNvbnN0IFJhZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlUmFkaW88YW55LCBhbnksIGFueT4+KG51bGwhKTtcbmV4cG9ydCBjb25zdCBSYWRpb0dyb3VwID0gbWVtbyhmdW5jdGlvbiBSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICByZW5kZXIsXG4gICAgdGFnR3JvdXAsXG4gICAgdGFnR3JvdXBMYWJlbCxcbiAgICBuYW1lLFxuICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSxcbiAgICBzZWxlY3RlZFZhbHVlLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBpbmRleERlbWFuZ2xlcixcbiAgICBpbmRleE1hbmdsZXIsXG4gICAgb25BbGxMb3N0Rm9jdXMsXG4gICAgb25BbnlHYWluZWRGb2N1cyxcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxufTogUmFkaW9Hcm91cFByb3BzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVJhZGlvLFxuICAgICAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyxcbiAgICAgICAgdXNlUmFkaW9Hcm91cFByb3BzLFxuICAgICAgICAuLi5yYWRpb0dyb3VwUmV0dXJuXG4gICAgfSA9IHVzZVJhZGlvR3JvdXA8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgcmFkaW9Hcm91cDogeyBuYW1lLCBvblNlbGVjdGVkVmFsdWVDaGFuZ2UsIHNlbGVjdGVkVmFsdWUsIHRhZ0dyb3VwLCB0YWdHcm91cExhYmVsIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9LFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVJhZGlvfT5cbiAgICAgICAgICAgIHtyZW5kZXIocmFkaW9Hcm91cFJldHVybiwgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMsIHVzZVJhZGlvR3JvdXBQcm9wcyl9XG4gICAgICAgIDwvUmFkaW9Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlclJhZGlvUGFyYW1ldGVyczxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJLCBMLCBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEk+PiB7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJSYWRpbzxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgbGFiZWxQb3NpdGlvbiB9OiBEZWZhdWx0UmVuZGVyUmFkaW9QYXJhbWV0ZXJzPEksIEw+KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2U8SSwgTCwgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJPj4oeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IFJhZGlvID0gbWVtbyhmdW5jdGlvbiBSYWRpbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGRpc2FibGVkLCBpbmRleCwgdGV4dCwgaGlkZGVuLCB0YWdJbnB1dCwgbGFiZWxQb3NpdGlvbiwgdGFnTGFiZWwsIHZhbHVlLCByZW5kZXIsIGZsYWdzLCBmb2N1c1NlbGYsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9OiBSYWRpb1Byb3BzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dCwgdXNlUmFkaW9MYWJlbCwgLi4ucmFkaW9SZXR1cm4gfSA9IHVzZUNvbnRleHQoUmFkaW9Db250ZXh0KSh7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByYWRpbzogeyBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCB2YWx1ZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW4sIGZvY3VzU2VsZiB9LFxuICAgICAgICBoYXNGb2N1c0lucHV0OiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxuICAgICAgICBoYXNGb2N1c0xhYmVsOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXRQcm9wcyB9ID0gdXNlUmFkaW9JbnB1dCh7IHRhZzogdGFnSW5wdXQgfSk7XG4gICAgY29uc3QgeyB1c2VSYWRpb0xhYmVsUHJvcHMgfSA9IHVzZVJhZGlvTGFiZWwoeyB0YWc6IHRhZ0xhYmVsIH0pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihyYWRpb1JldHVybiwgdXNlUmFkaW9JbnB1dFByb3BzLCB1c2VSYWRpb0xhYmVsUHJvcHMpO1xufSlcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VTbGlkZXIsIFVzZVNsaWRlclBhcmFtZXRlcnMsIFVzZVNsaWRlclRodW1iLCBVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnMsIFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXNsaWRlclwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclByb3BzIGV4dGVuZHMgR2V0PFVzZVNsaWRlclBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+LCBHZXQ8VXNlU2xpZGVyUGFyYW1ldGVycywgXCJzbGlkZXJcIj4ge1xuICAgIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPiwgR2V0PFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQ+LCBcInNsaWRlclRodW1iXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGh1bWJQcm9wczogUHJvcE1vZGlmaWVyPFRodW1iRWxlbWVudD4pOiBWTm9kZTtcbn1cblxuY29uc3QgU2xpZGVyVGh1bWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VTbGlkZXJUaHVtYjxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBTbGlkZXIgPSBtZW1vKCBmdW5jdGlvbiBTbGlkZXIoeyBtYXgsIG1pbiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIGNoaWxkcmVuIH06IFNsaWRlclByb3BzKSB7XG4gICAgY29uc3QgeyB1c2VTbGlkZXJUaHVtYiwgLi4uX3NsaWRlckluZm8gfSA9IHVzZVNsaWRlcih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICBzbGlkZXI6IHsgbWF4LCBtaW4gfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNsaWRlclRodW1iQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlU2xpZGVyVGh1bWJ9PntjaGlsZHJlbn08L1NsaWRlclRodW1iQ29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xufSlcblxuZXhwb3J0IGNvbnN0IFNsaWRlclRodW1iID0gbWVtbyhmdW5jdGlvbiBTbGlkZXJUaHVtYlU8VGh1bWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsYWJlbCwgdGFnLCB2YWx1ZSwgbWF4LCBtaW4sIG9uVmFsdWVDaGFuZ2UsIGluZGV4LCBmbGFncywgcmVuZGVyLCB2YWx1ZVRleHQgfTogU2xpZGVyVGh1bWJQcm9wczxUaHVtYkVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VTbGlkZXJUaHVtYlByb3BzLCAuLi5zbGlkZXJJbmZvIH0gPSB1c2VDb250ZXh0KFNsaWRlclRodW1iQ29udGV4dCkoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHNsaWRlclRodW1iOiB7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgdmFsdWVUZXh0IH0gfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKHNsaWRlckluZm8sIHVzZVNsaWRlclRodW1iUHJvcHMpXG59KVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclNsaWRlclRodW1iPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RodW1iLCBtYWtlUHJvcHNUaHVtYiB9OiB7IHRhZ1RodW1iOiBFbGVtZW50VG9UYWc8RT4sIG1ha2VQcm9wc1RodW1iOiAoaW5mbzogVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGh1bWJQcm9wczogUHJvcE1vZGlmaWVyPEU+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RodW1iIGFzIG5ldmVyLCBtb2RpZnlUaHVtYlByb3BzKG1ha2VQcm9wc1RodW1iKGluZm8pKSlcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VUYWJsZSwgVXNlVGFibGVCb2R5LCBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzLCBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbywgVXNlVGFibGVDZWxsLCBVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzLCBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbywgVXNlVGFibGVQYXJhbWV0ZXJzLCBVc2VUYWJsZVJldHVyblR5cGVJbmZvLCBVc2VUYWJsZVJldHVyblR5cGVXaXRoSG9va3MsIFVzZVRhYmxlUm93LCBVc2VUYWJsZVJvd1BhcmFtZXRlcnMsIFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYmxlXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVByb3BzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYmxlUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VUYWJsZVBhcmFtZXRlcnMsIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPiB7XG4gICAgLy90YWdUYWJsZTogRWxlbWVudFRvVGFnPFRhYmxlRWxlbWVudD47XG4gICAgLy9wcm9wc1RhYmxlKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRWxlbWVudD47XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlUYWJsZVByb3BzOiBQcm9wTW9kaWZpZXI8VGFibGVFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzIHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlUYWJsZUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPFNlY3Rpb25FbGVtZW50Pik6IFZOb2RlO1xufVxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUhlYWRQcm9wczxUIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJlbmRlcihtb2RpZnlUYWJsZUhlYWRQcm9wczogUHJvcE1vZGlmaWVyPFQ+KTogVk5vZGU7XG4gICAgdGFnVGFibGVIZWFkOiBFbGVtZW50VG9UYWc8VD47XG59XG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlRm9vdFByb3BzPFQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcmVuZGVyKG1vZGlmeVRhYmxlRm9vdFByb3BzOiBQcm9wTW9kaWZpZXI8VD4pOiBWTm9kZTtcbiAgICB0YWdUYWJsZUZvb3Q6IEVsZW1lbnRUb1RhZzxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVJvd1Byb3BzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBPbWl0PEdldDxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcInRhYmxlUm93XCI+LCBcImxvY2F0aW9uXCI+LFxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJhc0NoaWxkUm93T2ZTZWN0aW9uXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5VGFibGVSb3dQcm9wczogUHJvcE1vZGlmaWVyPFJvd0VsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDZWxsUHJvcHM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcInRhYmxlQ2VsbFwiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LFxuICAgIE9taXQ8R2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcInN1YkluZm9cIj4sIFwibG9jYXRpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4sIG1vZGlmeVRhYmxlUm93UHJvcHM6IFByb3BNb2RpZmllcjxDZWxsRWxlbWVudD4pOiBWTm9kZTtcbn1cblxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI+KG51bGwhKTtcblxuY29uc3QgVGFibGVTZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPGFueSwgYW55LCBhbnksIGFueT5bXCJ1c2VUYWJsZVNlY3Rpb25Qcm9wc1wiXT4obnVsbCEpO1xuY29uc3QgVGFibGVCb2R5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFibGVCb2R5PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5jb25zdCBUYWJsZVJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlUm93PGFueSwgYW55Pj4obnVsbCEpO1xuY29uc3QgVGFibGVDZWxsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFibGVDZWxsPGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlLCBtYWtlUHJvcHNUYWJsZSB9OiB7IHRhZ1RhYmxlOiBFbGVtZW50VG9UYWc8VGFibGVFbGVtZW50PiwgbWFrZVByb3BzVGFibGU6IChpbmZvOiBVc2VUYWJsZVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNUYWJsZTogUHJvcE1vZGlmaWVyPFRhYmxlRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGUgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGUobWFrZVByb3BzVGFibGUoaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVCb2R5PFRhYmxlQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlQm9keSwgbWFrZVByb3BzVGFibGVCb2R5IH06IHsgdGFnVGFibGVCb2R5OiBFbGVtZW50VG9UYWc8VGFibGVCb2R5RWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlQm9keTogKGluZm86IFVzZVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVCb2R5RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlQm9keTogUHJvcE1vZGlmaWVyPFRhYmxlQm9keUVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlQm9keSBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUJvZHkobWFrZVByb3BzVGFibGVCb2R5KGluZm8pKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlSGVhZDxUYWJsZUhlYWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUhlYWQsIG1ha2VQcm9wc1RhYmxlSGVhZCB9OiB7IHRhZ1RhYmxlSGVhZDogRWxlbWVudFRvVGFnPFRhYmxlSGVhZEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUhlYWQ6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlSGVhZEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmeVByb3BzVGFibGVIZWFkOiBQcm9wTW9kaWZpZXI8VGFibGVIZWFkRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVIZWFkIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlSGVhZChtYWtlUHJvcHNUYWJsZUhlYWQoKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUZvb3Q8VGFibGVGb290RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGVGb290LCBtYWtlUHJvcHNUYWJsZUZvb3QgfTogeyB0YWdUYWJsZUZvb3Q6IEVsZW1lbnRUb1RhZzxUYWJsZUZvb3RFbGVtZW50PiwgbWFrZVByb3BzVGFibGVGb290OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUZvb3RFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZnlQcm9wc1RhYmxlRm9vdDogUHJvcE1vZGlmaWVyPFRhYmxlRm9vdEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlRm9vdCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUZvb3QobWFrZVByb3BzVGFibGVGb290KCkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZVJvdywgbWFrZVByb3BzVGFibGVSb3cgfTogeyB0YWdUYWJsZVJvdzogRWxlbWVudFRvVGFnPFJvd0VsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZVJvdzogKGluZm86IFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNUYWJsZVJvdzogUHJvcE1vZGlmaWVyPFJvd0VsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlUm93IGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlUm93KG1ha2VQcm9wc1RhYmxlUm93KGluZm8pKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlQ2VsbDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGVDZWxsLCBtYWtlUHJvcHNUYWJsZUNlbGwgfTogeyB0YWdUYWJsZUNlbGw6IEVsZW1lbnRUb1RhZzxDZWxsRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlQ2VsbDogKGluZm86IFVzZVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNUYWJsZUNlbGw6IFByb3BNb2RpZmllcjxDZWxsRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVDZWxsIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlQ2VsbChtYWtlUHJvcHNUYWJsZUNlbGwoaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUYWJsZSA9IG1lbW8oZnVuY3Rpb24gVGFibGVVPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJlbmRlclxufTogVGFibGVQcm9wczxUYWJsZUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keSwgdXNlVGFibGVQcm9wcywgdXNlVGFibGVSb3csIHVzZVRhYmxlU2VjdGlvblByb3BzLCAuLi50YWJsZUluZm8gfSA9IHVzZVRhYmxlPFRhYmxlRWxlbWVudCwgU2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjoge30sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VGFibGVTZWN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVTZWN0aW9uUHJvcHN9PlxuICAgICAgICAgICAgPFRhYmxlQm9keUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVRhYmxlQm9keX0+XG4gICAgICAgICAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyKHRhYmxlSW5mbywgdXNlVGFibGVQcm9wcyl9XG4gICAgICAgICAgICAgICAgPC9UYWJsZVJvd0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L1RhYmxlQm9keUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvVGFibGVTZWN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVCb2R5ID0gbWVtbyhmdW5jdGlvbiBUYWJsZUJvZHlVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyIH06IFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VUYWJsZUJvZHlQcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUNvbnRleHQoVGFibGVCb2R5Q29udGV4dCkoe30pO1xuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiYm9keVwiPntyZW5kZXIoc2VjdGlvbkluZm8sIHVzZVRhYmxlQm9keVByb3BzKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbn0pXG5cbmV4cG9ydCBjb25zdCBUYWJsZUhlYWQgPSBtZW1vKGZ1bmN0aW9uIFRhYmxlSGVhZFU8VCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCB0YWdUYWJsZUhlYWQgfTogVGFibGVIZWFkUHJvcHM8VD4pIHtcbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25Qcm9wc0Jhc2UgPSB1c2VDb250ZXh0KFRhYmxlU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8VD4gPSAocHJvcHMpID0+IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSh0YWdUYWJsZUhlYWQsIFwiaGVhZFwiLCBwcm9wcyk7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJoZWFkXCI+eyhyZW5kZXIodXNlVGFibGVTZWN0aW9uUHJvcHMpKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbn0pXG5cbmV4cG9ydCBjb25zdCBUYWJsZUZvb3QgPSBtZW1vKGZ1bmN0aW9uIFRhYmxlRm9vdFU8VCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCB0YWdUYWJsZUZvb3QgfTogVGFibGVGb290UHJvcHM8VD4pIHtcbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25Qcm9wc0Jhc2UgPSB1c2VDb250ZXh0KFRhYmxlU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8VD4gPSAocHJvcHMpID0+IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSh0YWdUYWJsZUZvb3QsIFwiZm9vdFwiLCBwcm9wcyk7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJmb290XCI+eyhyZW5kZXIodXNlVGFibGVTZWN0aW9uUHJvcHMpKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbn0pXG5cbmV4cG9ydCBjb25zdCBUYWJsZVJvdyA9IG1lbW8oZnVuY3Rpb24gVGFibGVSb3dVPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgdGV4dCxcbiAgICB0YWdUYWJsZVJvdyxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBmbGFncyxcbiAgICBmb2N1c1NlbGYsXG4gICAgaGlkZGVuLFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJlbmRlclxufTogVGFibGVSb3dQcm9wczxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGwsIHVzZVRhYmxlUm93UHJvcHMsIC4uLnJvd0luZm8gfSA9IHVzZUNvbnRleHQoVGFibGVSb3dDb250ZXh0KSh7XG4gICAgICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IHtcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7fVxuICAgICAgICB9LFxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlUm93OiB7IGxvY2F0aW9uOiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCksIHRhZ1RhYmxlUm93IH1cbiAgICB9KTtcbiAgICByZXR1cm4gPFRhYmxlQ2VsbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVRhYmxlQ2VsbH0+e3JlbmRlcihyb3dJbmZvLCB1c2VUYWJsZVJvd1Byb3BzKX08L1RhYmxlQ2VsbENvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVDZWxsID0gbWVtbyhmdW5jdGlvbiBUYWJsZUNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCB0ZXh0LCBmbGFncywgZm9jdXNTZWxmLCBoaWRkZW4sIHZhbHVlLCBoZWFkZXJUeXBlLCB0YWdUYWJsZUNlbGwsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyIH06IFRhYmxlQ2VsbFByb3BzPENlbGxFbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlVGFibGVDZWxsUHJvcHMsIC4uLmNlbGxJbmZvIH0gPSB1c2VDb250ZXh0KFRhYmxlQ2VsbENvbnRleHQpKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxuICAgICAgICBzdWJJbmZvOiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgdGFibGVDZWxsOiB7IGhlYWRlclR5cGUsIHRhZ1RhYmxlQ2VsbCB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKGNlbGxJbmZvLCB1c2VUYWJsZUNlbGxQcm9wcyk7XG59KVxuXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgVXNlVGFiLCBVc2VUYWJMaXN0UGFyYW1ldGVycywgVXNlVGFiTGlzdFJldHVyblR5cGVJbmZvLCBVc2VUYWJQYW5lbCwgVXNlVGFiUGFuZWxQYXJhbWV0ZXJzLCBVc2VUYWJQYW5lbFJldHVyblR5cGVJbmZvLCBVc2VUYWJQYXJhbWV0ZXJzLCBVc2VUYWJSZXR1cm5UeXBlSW5mbywgdXNlVGFicywgVXNlVGFic1BhcmFtZXRlcnMsIFVzZVRhYnNSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtdGFic1wiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFic1Byb3BzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInNpbmdsZVNlbGVjdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwiY2hpbGRyZW5IYXZlRm9jdXNcIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInRhYnNcIj4sXG4gICAgR2V0MjxVc2VUYWJzUGFyYW1ldGVycywgXCJ0YWJQYW5lbHNcIiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4ge1xuICAgIHJlbmRlcih0YWJzSW5mbzogVXNlVGFic1JldHVyblR5cGVJbmZvICYgVXNlVGFiTGlzdFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5VGFiTGlzdFByb3BzOiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJQcm9wczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+IHtcbiAgICAvLyB0YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3Rib3hJdGVtRWxlbWVudD47XG4gICAgLy8gcHJvcHNMaXN0SXRlbTogKGFyZ3M6IExpc3Rib3hTaW5nbGVQcm9wc0Rlcml2ZWRGcm9tKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiwgbW9kaWZ5TGlzdEl0ZW06IFByb3BNb2RpZmllcjxUYWJFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFiUGFuZWxQcm9wczxUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdldDxVc2VUYWJQYW5lbFBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pOiBWTm9kZTtcbn1cblxuY29uc3QgVGFiQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFiPGFueT4+KG51bGwhKTtcbmNvbnN0IFRhYlBhbmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFiUGFuZWw8YW55Pj4obnVsbCEpO1xuXG5leHBvcnQgY29uc3QgVGFicyA9IG1lbW8oZnVuY3Rpb24gVGFiczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgc2VsZWN0ZWRJbmRleCxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGluZGV4RGVtYW5nbGVyLFxuICAgIGluZGV4TWFuZ2xlcixcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXIsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBvbkFsbExvc3RGb2N1cyxcbiAgICBvbkFueUdhaW5lZEZvY3VzLFxuICAgIG9uU2VsZWN0ZWRJbmRleENoYW5nZSxcbiAgICByZW5kZXJcbn06IFRhYnNQcm9wczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBUYWJFbGVtZW50Pikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlVGFiTGlzdCxcbiAgICAgICAgdXNlVGFiTGlzdExhYmVsLFxuICAgICAgICB1c2VUYWJQYW5lbCxcbiAgICAgICAgLi4udGFic0luZm9cbiAgICB9ID0gdXNlVGFiczxMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgVGFiUGFuZWxFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgdGFiUGFuZWxzOiB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVRhYiwgdXNlVGFiTGlzdFByb3BzLCAuLi50YWJsaXN0SW5mbyB9ID0gdXNlVGFiTGlzdCh7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sXG4gICAgICAgIHRhYnM6IHsgb25TZWxlY3RlZEluZGV4Q2hhbmdlIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgfSk7XG4gICAgY29uc3QgeyB1c2VUYWJMaXN0TGFiZWxQcm9wcyB9ID0gdXNlVGFiTGlzdExhYmVsKHt9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJ9PlxuICAgICAgICAgICAgPFRhYlBhbmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFiUGFuZWx9PlxuICAgICAgICAgICAgICAgIHtyZW5kZXIoeyAuLi50YWJzSW5mbywgLi4udGFibGlzdEluZm8gfSwgdXNlVGFiTGlzdExhYmVsUHJvcHMsIHVzZVRhYkxpc3RQcm9wcyl9XG4gICAgICAgICAgICA8L1RhYlBhbmVsQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9UYWJDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pXG5cbmV4cG9ydCBjb25zdCBUYWIgPSBtZW1vKGZ1bmN0aW9uIFRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgZmxhZ3MsIGZvY3VzU2VsZiwgaGlkZGVuLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJlbmRlciB9OiBUYWJQcm9wczxUYWJFbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlVGFiUHJvcHMsIC4uLnRhYkluZm8gfSA9IHVzZUNvbnRleHQoVGFiQ29udGV4dCkoe1xuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4gfSxcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIodGFiSW5mbywgdXNlVGFiUHJvcHMpXG59KVxuXG5leHBvcnQgY29uc3QgVGFiUGFuZWwgPSBtZW1vKGZ1bmN0aW9uIFRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgaW5kZXgsIGZsYWdzLCByZW5kZXIgfTogVGFiUGFuZWxQcm9wczxUYWJQYW5lbEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VUYWJQYW5lbFByb3BzLCAuLi50YWJQYW5lbEluZm8gfSA9IHVzZUNvbnRleHQoVGFiUGFuZWxDb250ZXh0KSh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSB9KTtcblxuICAgIHJldHVybiByZW5kZXIodGFiUGFuZWxJbmZvLCB1c2VUYWJQYW5lbFByb3BzKVxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdMYWJlbCwgdGFnTGlzdCwgbWFrZVByb3BzTGFiZWwsIG1ha2VQcm9wc0xpc3QsIHBhbmVscyB9OiB7IHBhbmVsczogVk5vZGVbXSwgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+LCB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKGluZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzTGlzdDogKGluZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhYnNJbmZvOiBVc2VUYWJzUmV0dXJuVHlwZUluZm8gJiBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm88YW55PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeUxpc3RQcm9wczogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pikge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIG1vZGlmeUxhYmVsUHJvcHMobWFrZVByb3BzTGFiZWwodGFic0luZm8pKSlcbiAgICAgICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCBhcyBuZXZlciwgbW9kaWZ5TGlzdFByb3BzKG1ha2VQcm9wc0xpc3QodGFic0luZm8pKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgICAgICB7bGlzdH1cbiAgICAgICAgICAgICAgICB7cGFuZWxzfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc1RhYiwgdGFnVGFiIH06IHsgdGFnVGFiOiBFbGVtZW50VG9UYWc8VGFiRWxlbWVudD4sIG1ha2VQcm9wc1RhYjogKGluZm86IFVzZVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJJbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiwgbW9kaWZ5VGFiUHJvcHM6IFByb3BNb2RpZmllcjxUYWJFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWIgYXMgbmV2ZXIsIG1vZGlmeVRhYlByb3BzKG1ha2VQcm9wc1RhYih0YWJJbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJQYW5lbDxUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc1RhYlBhbmVsLCB0YWdUYWJQYW5lbCB9OiB7IHRhZ1RhYlBhbmVsOiBFbGVtZW50VG9UYWc8VGFiUGFuZWxFbGVtZW50PiwgbWFrZVByb3BzVGFiUGFuZWw6IChpbmZvOiBVc2VUYWJQYW5lbFJldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhYlBhbmVsSW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFiUGFuZWwgYXMgbmV2ZXIsIG1vZGlmeVRhYlBhbmVsUHJvcHMobWFrZVByb3BzVGFiUGFuZWwodGFiUGFuZWxJbmZvKSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlVG9vbHRpcCwgVXNlVG9vbHRpcFBhcmFtZXRlcnMsIFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtdG9vbHRpcFwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBQcm9wczxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFBhcmFtZXRlcnMge1xuICAgIGdldERvY3VtZW50OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcImdldERvY3VtZW50XCJdO1xuICAgIGdldFdpbmRvdz86IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wiZ2V0V2luZG93XCJdO1xuICAgIHJlbmRlcihpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8sIG1vZGlmeVRyaWdnZXJQcm9wczogUHJvcE1vZGlmaWVyPFRyaWdnZXJUeXBlPiwgbW9kaWZ5VG9vbHRpcFByb3BzOiBQcm9wTW9kaWZpZXI8UG9wdXBUeXBlPik6IFZOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1Rvb2x0aXAsIHRhZ1RyaWdnZXIsIG1ha2VUb29sdGlwUHJvcHMsIG1ha2VUcmlnZ2VyUHJvcHMsIHBvcnRhbElkIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnVHJpZ2dlcjogRWxlbWVudFRvVGFnPFRyaWdnZXJUeXBlPiwgdGFnVG9vbHRpcDogRWxlbWVudFRvVGFnPFBvcHVwVHlwZT4sIG1ha2VUcmlnZ2VyUHJvcHM6IChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPiwgbWFrZVRvb2x0aXBQcm9wczogKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBUeXBlPiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8sIG1vZGlmeVByb3BzVHJpZ2dlcjogUHJvcE1vZGlmaWVyPFRyaWdnZXJUeXBlPiwgbW9kaWZ5UHJvcHNUb29sdGlwOiBQcm9wTW9kaWZpZXI8UG9wdXBUeXBlPikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdUcmlnZ2VyIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RyaWdnZXIobWFrZVRyaWdnZXJQcm9wcyhpbmZvKSkpfVxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjcmVhdGVFbGVtZW50KHRhZ1Rvb2x0aXAgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVG9vbHRpcChtYWtlVG9vbHRpcFByb3BzKGluZm8pKSlcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgVG9vbHRpcCA9IG1lbW8oZnVuY3Rpb24gVG9vbHRpcFU8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IGZvY3VzRGVsYXksIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXksIG1vdXNlb3ZlckRlbGF5LCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCByZW5kZXIgfTogVG9vbHRpcFByb3BzPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KSB7XG4gICAgY29uc3QgeyB1c2VUb29sdGlwUG9wdXAsIHVzZVRvb2x0aXBUcmlnZ2VyLCAuLi5pbmZvIH0gPSB1c2VUb29sdGlwPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KHsgZm9jdXNEZWxheSwgbW91c2VvdXRUb2xlcmFuY2VEZWxheSwgbW91c2VvdmVyRGVsYXkgfSk7XG4gICAgY29uc3QgeyB1c2VUb29sdGlwVHJpZ2dlclByb3BzIH0gPSB1c2VUb29sdGlwVHJpZ2dlcih7IGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3cgfSB9KTtcbiAgICBjb25zdCB7IHVzZVRvb2x0aXBQb3B1cFByb3BzIH0gPSB1c2VUb29sdGlwUG9wdXAoeyBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0gfSk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvLCB1c2VUb29sdGlwVHJpZ2dlclByb3BzLCB1c2VUb29sdGlwUG9wdXBQcm9wcyk7XG59KVxuXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VHcmlkbGlzdCwgVXNlR3JpZGxpc3RTZWN0aW9uLCBVc2VHcmlkbGlzdFNlY3Rpb25QYXJhbWV0ZXJzLCBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlSW5mbywgVXNlR3JpZGxpc3RDaGlsZCwgVXNlR3JpZGxpc3RDaGlsZFBhcmFtZXRlcnMsIFVzZUdyaWRsaXN0Q2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBVc2VHcmlkbGlzdFJldHVyblR5cGVJbmZvLCBVc2VHcmlkbGlzdFJvdywgVXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzLCBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1ncmlkbGlzdFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RQcm9wczxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVycywgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIC8vdGFnR3JpZGxpc3Q6IEVsZW1lbnRUb1RhZzxHcmlkbGlzdEVsZW1lbnQ+O1xuICAgIC8vcHJvcHNHcmlkbGlzdCgpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcmlkbGlzdEVsZW1lbnQ+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VHcmlkbGlzdFJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5R3JpZGxpc3RQcm9wczogUHJvcE1vZGlmaWVyPEdyaWRsaXN0RWxlbWVudD4pOiBWTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdFNlY3Rpb25Qcm9wczxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVycywgVXNlR3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVycyB7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICByZW5kZXIoaW5mbzogVXNlR3JpZGxpc3RTZWN0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlHcmlkbGlzdFNlY3Rpb25Qcm9wczogUHJvcE1vZGlmaWVyPFNlY3Rpb25FbGVtZW50Pik6IFZOb2RlO1xufVxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdEhlYWRQcm9wcyB7XG4gICAgcmVuZGVyKCk6IFZOb2RlO1xufVxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdEZvb3RQcm9wcyB7XG4gICAgcmVuZGVyKCk6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRsaXN0Um93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJhc0NoaWxkUm93T2ZTZWN0aW9uXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5R3JpZGxpc3RSb3dQcm9wczogUHJvcE1vZGlmaWVyPFJvd0VsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RDaGlsZFByb3BzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlR3JpZGxpc3RDaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPENlbGxFbGVtZW50PixcbiAgICBPbWl0PEdldDxVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwic3ViSW5mb1wiPiwgXCJsb2NhdGlvblwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUdyaWRsaXN0Q2hpbGRSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4sIG1vZGlmeUdyaWRsaXN0Q2hpbGRQcm9wczogUHJvcE1vZGlmaWVyPENlbGxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5jb25zdCBMb2NhdGlvbkluZGV4Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbmNvbnN0IFNldE1hbmdsZXJzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8KG06IChuOiBudW1iZXIpID0+IG51bWJlciwgZDogKG46IG51bWJlcikgPT4gbnVtYmVyKSA9PiB2b2lkPihudWxsISk7XG5jb25zdCBHcmlkbGlzdFNlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkbGlzdFNlY3Rpb248YW55LCBhbnksIGFueT4+KG51bGwhKTtcbmNvbnN0IEdyaWRsaXN0Um93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlR3JpZGxpc3RSb3c8YW55LCBhbnk+PihudWxsISk7XG5jb25zdCBHcmlkbGlzdENoaWxkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlR3JpZGxpc3RDaGlsZDxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3Q8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcmlkbGlzdCwgbWFrZVByb3BzR3JpZGxpc3QgfTogeyB0YWdHcmlkbGlzdDogRWxlbWVudFRvVGFnPEdyaWRsaXN0RWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0OiAoaW5mbzogVXNlR3JpZGxpc3RSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlR3JpZGxpc3RSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVByb3BzR3JpZGxpc3Q6IFByb3BNb2RpZmllcjxHcmlkbGlzdEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0IGFzIG5ldmVyLCBtb2RpZnlQcm9wc0dyaWRsaXN0KG1ha2VQcm9wc0dyaWRsaXN0KGluZm8pKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0U2VjdGlvbjxHcmlkbGlzdFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcmlkbGlzdFNlY3Rpb24sIG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbiB9OiB7IHRhZ0dyaWRsaXN0U2VjdGlvbjogRWxlbWVudFRvVGFnPEdyaWRsaXN0U2VjdGlvbkVsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdFNlY3Rpb246IChpbmZvOiBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0U2VjdGlvbkVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNHcmlkbGlzdFNlY3Rpb246IFByb3BNb2RpZmllcjxHcmlkbGlzdFNlY3Rpb25FbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdFNlY3Rpb24gYXMgbmV2ZXIsIG1vZGlmeVByb3BzR3JpZGxpc3RTZWN0aW9uKG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbihpbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdEhlYWQ8R3JpZGxpc3RIZWFkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnR3JpZGxpc3RIZWFkLCBtYWtlUHJvcHNHcmlkbGlzdEhlYWQgfTogeyB0YWdHcmlkbGlzdEhlYWQ6IEVsZW1lbnRUb1RhZzxHcmlkbGlzdEhlYWRFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3RIZWFkOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcmlkbGlzdEhlYWRFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RIZWFkIGFzIG5ldmVyLCAobWFrZVByb3BzR3JpZGxpc3RIZWFkKCkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RGb290PEdyaWRsaXN0Rm9vdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyaWRsaXN0Rm9vdCwgbWFrZVByb3BzR3JpZGxpc3RGb290IH06IHsgdGFnR3JpZGxpc3RGb290OiBFbGVtZW50VG9UYWc8R3JpZGxpc3RGb290RWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0Rm9vdDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RGb290RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0Rm9vdCBhcyBuZXZlciwgKG1ha2VQcm9wc0dyaWRsaXN0Rm9vdCgpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0Um93PFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnR3JpZGxpc3RSb3csIG1ha2VQcm9wc0dyaWRsaXN0Um93IH06IHsgdGFnR3JpZGxpc3RSb3c6IEVsZW1lbnRUb1RhZzxSb3dFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3RSb3c6IChpbmZvOiBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVByb3BzR3JpZGxpc3RSb3c6IFByb3BNb2RpZmllcjxSb3dFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdFJvdyBhcyBuZXZlciwgbW9kaWZ5UHJvcHNHcmlkbGlzdFJvdyhtYWtlUHJvcHNHcmlkbGlzdFJvdyhpbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdENoaWxkPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcmlkbGlzdENoaWxkLCBtYWtlUHJvcHNHcmlkbGlzdENoaWxkIH06IHsgdGFnR3JpZGxpc3RDaGlsZDogRWxlbWVudFRvVGFnPENlbGxFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3RDaGlsZDogKGluZm86IFVzZUdyaWRsaXN0Q2hpbGRSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VHcmlkbGlzdENoaWxkUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc0dyaWRsaXN0Q2hpbGQ6IFByb3BNb2RpZmllcjxDZWxsRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RDaGlsZCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNHcmlkbGlzdENoaWxkKG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQoaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBHcmlkbGlzdCA9IG1lbW8oZnVuY3Rpb24gR3JpZGxpc3RVPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJlbmRlclxufTogR3JpZGxpc3RQcm9wczxHcmlkbGlzdEVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZUdyaWRsaXN0U2VjdGlvbiwgdXNlR3JpZGxpc3RQcm9wcywgdXNlR3JpZGxpc3RSb3csIC4uLmdyaWRsaXN0SW5mbyB9ID0gdXNlR3JpZGxpc3Q8R3JpZGxpc3RFbGVtZW50LCBTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEdyaWRsaXN0U2VjdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUdyaWRsaXN0U2VjdGlvbn0+XG4gICAgICAgICAgICAgICAgPEdyaWRsaXN0Um93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlR3JpZGxpc3RSb3d9PlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyKGdyaWRsaXN0SW5mbywgdXNlR3JpZGxpc3RQcm9wcyl9XG4gICAgICAgICAgICAgICAgPC9HcmlkbGlzdFJvd0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L0dyaWRsaXN0U2VjdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuZXhwb3J0IGNvbnN0IEdyaWRsaXN0U2VjdGlvbiA9IG1lbW8oZnVuY3Rpb24gR3JpZGxpc3RTZWN0aW9uVTxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciwgY29tcGFyZVJvd3MsIGluZGV4IH06IEdyaWRsaXN0U2VjdGlvblByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VHcmlkbGlzdFNlY3Rpb25Qcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUNvbnRleHQoR3JpZGxpc3RTZWN0aW9uQ29udGV4dCkoeyBjb21wYXJlUm93cyB9KTtcbiAgICByZXR1cm4gPExvY2F0aW9uSW5kZXhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmRleH0+e3JlbmRlcihzZWN0aW9uSW5mbywgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMpfTwvTG9jYXRpb25JbmRleENvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgR3JpZGxpc3RSb3cgPSBtZW1vKGZ1bmN0aW9uIEdyaWRsaXN0Um93VTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIHRleHQsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgZmxhZ3MsXG4gICAgZm9jdXNTZWxmLFxuICAgIGhpZGRlbixcbiAgICBpbmRleERlbWFuZ2xlcixcbiAgICBpbmRleE1hbmdsZXIsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVSZW5kZXIsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICByZW5kZXJcbn06IEdyaWRsaXN0Um93UHJvcHM8Um93RWxlbWVudCwgQ2VsbGVtZW50PiwgcmVmOiBSZWY8Um93RWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZUdyaWRsaXN0Q2hpbGQsIHVzZUdyaWRsaXN0Um93UHJvcHMsIC4uLnJvd0luZm8gfSA9IHVzZUNvbnRleHQoR3JpZGxpc3RSb3dDb250ZXh0KSh7XG4gICAgICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IHtcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7fVxuICAgICAgICB9LFxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgICAgIH0sXG4gICAgICAgIGdyaWRsaXN0Um93OiB7IGxvY2F0aW9uSW5kZXg6IHVzZUNvbnRleHQoTG9jYXRpb25JbmRleENvbnRleHQpIH1cbiAgICB9KTtcbiAgICByZXR1cm4gPEdyaWRsaXN0Q2hpbGRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkbGlzdENoaWxkfT57cmVuZGVyKHJvd0luZm8sIHVzZUdyaWRsaXN0Um93UHJvcHMpfTwvR3JpZGxpc3RDaGlsZENvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgR3JpZGxpc3RDaGlsZCA9IG1lbW8oZnVuY3Rpb24gR3JpZGxpc3RDaGlsZDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgaW5kZXgsIHRleHQsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZW5kZXIgfTogR3JpZGxpc3RDaGlsZFByb3BzPENlbGxFbGVtZW50PiwgcmVmOiBSZWY8Q2VsbEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VHcmlkbGlzdENoaWxkUHJvcHMsIC4uLmNlbGxJbmZvIH0gPSB1c2VDb250ZXh0KEdyaWRsaXN0Q2hpbGRDb250ZXh0KSh7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9LFxuICAgICAgICBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSxcbiAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgbG9jYXRpb25JbmRleDogdXNlQ29udGV4dChMb2NhdGlvbkluZGV4Q29udGV4dClcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihjZWxsSW5mbywgdXNlR3JpZGxpc3RDaGlsZFByb3BzKTtcbn0pXG5cbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBBY2NvcmRpb24sIEFjY29yZGlvblNlY3Rpb24sIGRlZmF1bHRSZW5kZXJBY2NvcmRpb25TZWN0aW9uIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIERlbW9BY2NvcmRpb24oeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogUmVuZGVyYWJsZVByb3BzPHt9Pikge1xuICAgIHJldHVybiA8QWNjb3JkaW9uIHsuLi5wcm9wc30gcmVuZGVyPXsoX2luZm8pID0+IHsgcmV0dXJuIDxkaXYgaWQ9XCJhY2NvcmRpb24tZGVtb1wiPntjaGlsZHJlbn08L2Rpdj4gfX0gLz5cbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn1cblxuY29uc3QgRGVtb0FjY29yZGlvblNlY3Rpb24gPSBtZW1vKGZ1bmN0aW9uIERlbW9BY2NvcmRpb25TZWN0aW9uKHsgaW5kZXgsIGJvZHksIGhlYWRpbmcsIGRpc2FibGVkLCBvcGVuIH06IHsgb3Blbj86IGJvb2xlYW4sIGRpc2FibGVkOiBib29sZWFuLCBpbmRleDogbnVtYmVyLCBoZWFkaW5nOiBDb21wb25lbnRDaGlsZHJlbiwgYm9keTogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuICAgIHJldHVybiA8QWNjb3JkaW9uU2VjdGlvbjxIVE1MQnV0dG9uRWxlbWVudCwgSFRNTERpdkVsZW1lbnQ+IGluZGV4PXtpbmRleH0gdGFnQnV0dG9uPVwiYnV0dG9uXCIgb3Blbj17b3Blbn0gZGlzYWJsZWQ9e2Rpc2FibGVkfSBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckFjY29yZGlvblNlY3Rpb24oe1xuICAgICAgICBtYWtlUHJvcHNCb2R5OiAoaW5mbykgPT4geyByZXR1cm4geyBoaWRkZW46ICFpbmZvLmFjY29yZGlvblNlY3Rpb24uZXhwYW5kZWQsIGNoaWxkcmVuOiBib2R5IH0gfSxcbiAgICAgICAgbWFrZVByb3BzSGVhZGluZzogKCkgPT4geyByZXR1cm4geyBjaGlsZHJlbjogaGVhZGluZyB9IH0sXG4gICAgICAgIHRhZ0JvZHk6IFwiZGl2XCIsXG4gICAgICAgIHRhZ0hlYWRpbmc6IFwiYnV0dG9uXCJcbiAgICB9KX0gLz5cbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvYWNjb3JkaW9uL1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBBY2NvcmRpb24gcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+RWFjaCBzZWN0aW9uJ3MgaGVhZGVyIGFuZCBib2R5IGFyZSBsaW5rZWQgdmlhIElEOyB0aGUgYm9keSBpcyA8Y29kZT5sYWJlbGxlZC1ieTwvY29kZT4gdGhlIGhlYWRlciBhbmQgdGhlIGhlYWRlciA8Y29kZT5jb250cm9sPC9jb2RlPnMgdGhlIGJvZHkuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGhlYWRlciBpcyBhIGJ1dHRvbiBhbmQgcmVzcG9uZHMgdG8ga2V5Ym9hcmQsIG1vdXNlLCB0b3VjaCwgZXRjLiBldmVudHMsIHJlZ2FyZGxlc3Mgb2YgdGhlIGVsZW1lbnQgdXNlZC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5JZiB0aGUgaGVhZGVyIGVsZW1lbnQgaXMgbm90IGEgPGNvZGU+Jmx0O2J1dHRvbiZndDs8L2NvZGU+IGVsZW1lbnQsIGl0IGlzIGdpdmVuIHRoYXQgPGNvZGU+cm9sZTwvY29kZT4uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VXAvZG93biAmYW1wOyBIb21lL0VuZCBrZXlzIG5hdmlnYXRlIHRocm91Z2ggdGhlIGxpc3QsIGFzIGRvZXMgVGFiIGFuZCBTaGlmdCtUYWI8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBlYWNoIDxjb2RlPkFjY29yZGlvblNlY3Rpb248L2NvZGU+IHRha2VzIG11c3Qgd3JhcCB0aGUgaGVhZGVyIGJ1dHRvbiB3aXRoIGEgPGEgaHJlZj1cImh0dHBzOi8vdzNjLmdpdGh1Yi5pby9hcmlhLyNoZWFkaW5nXCI+aGVhZGluZzwvYT4gKGUuZy4gPGNvZGU+aDM8L2NvZGU+LCBvciA8Y29kZT4mbHQ7SGVhZGluZyZndDs8L2NvZGU+KS4gU2VlIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBhbiBleGFtcGxlLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2A8QWNjb3JkaW9uIHJlbmRlcj17Li4ufT5cbiAgICA8QWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MH0gcmVuZGVyPXsuLi59IC8+XG4gICAgPEFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IHJlbmRlcj17Li4ufSAvPlxuICAgIDxBY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSByZW5kZXI9ey4uLn0gLz5cbjwvQWNjb3JkaW9uPmB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8Qmx1cmIgLz5cbiAgICAgICAgICAgIDxDb2RlIC8+XG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgYWNjb3JkaW9uIHNlY3Rpb25zPC9sYWJlbD5cbiAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uPlxuICAgICAgICAgICAgICAgIDw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MH0gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICMwXCIgYm9keT1cIkJvZHkgY29udGVudCAjMFwiIGRpc2FibGVkPXtmYWxzZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXsxfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzFcIiBib2R5PVwiQm9keSBjb250ZW50ICMxXCIgZGlzYWJsZWQ9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezJ9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMiAoZGlzYWJsZWQpXCIgYm9keT1cIkJvZHkgY29udGVudCAjMlwiIGRpc2FibGVkPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezN9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMyAoZm9yY2VkIG9wZW4pXCIgYm9keT1cIkJvZHkgY29udGVudCAjM1wiIGRpc2FibGVkPXtmYWxzZX0gb3Blbj17dHJ1ZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXs0fSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzQgKGZvcmNlZCBjbG9zZWQpXCIgYm9keT1cIkJvZHkgY29udGVudCAjNFwiIGRpc2FibGVkPXtmYWxzZX0gb3Blbj17ZmFsc2V9IC8+XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSA1OyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXtpfSBoZWFkaW5nPXtgQWNjb3JkaW9uIHNlY3Rpb24gIyR7aX1gfSBib2R5PXtgQm9keUNvbnRlbnQgIyR7aX1gfSBkaXNhYmxlZD17ZmFsc2V9IC8+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKS5zbGljZSgwLCBjb3VudCl9PC8+XG4gICAgICAgICAgICA8L0RlbW9BY2NvcmRpb24+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IEJ1dHRvbiwgZGVmYXVsdFJlbmRlckJ1dHRvbiwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9idXR0b24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIEJ1dHRvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5XaGV0aGVyIHVzaW5nIGFuIGFjdHVhbCA8Y29kZT4mbHQ7YnV0dG9uJmd0OzwvY29kZT4sIG9yIHNvbWV0aGluZyBlbHNlIGxpa2UgYSA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT4sIHRoZSBwcm9wZXIgcm9sZXMgYW5kIGV2ZW50IGhhbmRsZXJzIHdpbGwgYmUgYXBwbGllZC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5CdXR0b25zIGNhbiBiZSB0b2dnbGVkIChwcmVzc2VkIG9yIHVucHJlc3NlZCkuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGJ1dHRvbiByZXNwb25kcyB0byBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBldGMuIGV2ZW50cywgcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCB1c2VkLlxuICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+RG91YmxlLWNsaWNrcyBkbyBub3Qgc2VsZWN0IHRleHQsIGJ1dCB0ZXh0IGlzIHN0aWxsIHNlbGVjdGFibGUgd2l0aG91dCBpdCBjb3VudGluZyBhcyBhIHByZXNzL2NsaWNrPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5XaGVuIEVudGVyIGlzIHByZXNzZWQsIHRoZSBidXR0b24gaXMgaW1tZWRpYXRlbHkgYWN0aXZhdGVkPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5XaGVuIFNwYWNlIGlzIHByZXNzZWQsIHRoZSBidXR0b24gaXMgYWN0aXZhdGVkIG9uY2UgcmVsZWFzZWQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmlPUyBTYWZhcmkgcHJvcGVybHkgZm9jdXNlcyB0aGUgYnV0dG9uPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBidXR0b24gY29udGFpbnMgb25seSBhbiBpY29uIChvciBvdGhlciBub24tZGVzY3JpcHRpdmUgY29udGVudCwgZXRjLiksIHlvdSBtdXN0IHByb3ZpZGUgYW4gPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gbWFudWFsbHkgc3RhdGluZyB3aGF0IGhhcHBlbnMgd2hlbiB0aGUgYnV0dG9uIGlzIHByZXNzZWQuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YDxCdXR0b24gdGFnPVwiYnV0dG9uXCI+QnV0dG9uPC9CdXR0b24+XG4gICAgPEJ1dHRvbiB0YWc9XCJkaXZcIj5EaXY8L0J1dHRvbj5gfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtwcmVzc2VkLCBzZXRQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8Qmx1cmIgLz5cbiAgICAgICAgICAgIDxDb2RlIC8+XG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD17ZmFsc2V9IHRhZz1cImJ1dHRvblwiIC8+XG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cInNvZnRcIiB0YWc9XCJidXR0b25cIiAvPlxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9XCJoYXJkXCIgdGFnPVwiYnV0dG9uXCIgLz5cbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPXtmYWxzZX0gdGFnPVwiZGl2XCIgLz5cbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPVwic29mdFwiIHRhZz1cImRpdlwiIC8+XG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cImhhcmRcIiB0YWc9XCJkaXZcIiAvPlxuICAgICAgICAgICAgPEJ1dHRvbiBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IGRpc2FibGVkPXtmYWxzZX0gdGFnQnV0dG9uPVwiYnV0dG9uXCIgcHJlc3NlZD17cHJlc3NlZH0gb25QcmVzcz17ZSA9PiBzZXRQcmVzc2VkKGVbRXZlbnREZXRhaWxdLnByZXNzZWQgPz8gZmFsc2UpfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJCdXR0b24oXCJidXR0b25cIiwgKCkgPT4gKHsgY2hpbGRyZW46IGBUb2dnbGUgYnV0dG9uICgke3ByZXNzZWQ/IFwicHJlc3NlZFwiIDogXCJ1bnByZXNzZWRcIn0pYH0pKX0gLz5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBEZW1vQnV0dG9uKHsgdGFnLCBkaXNhYmxlZH06IHsgdGFnOiBzdHJpbmcsIGRpc2FibGVkOiBib29sZWFuIHwgXCJzb2Z0XCIgfCBcImhhcmRcIiB9KSB7XG4gICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHsgYWxlcnQoXCJCdXR0b24gY2xpY2tlZFwiKSB9XG5cbiAgICByZXR1cm4gKCBcbiAgICAgICAgPEJ1dHRvbiBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IHRhZ0J1dHRvbj17dGFnIGFzIGFueX0gb25QcmVzcz17b25QcmVzc30gcmVuZGVyPXtkZWZhdWx0UmVuZGVyQnV0dG9uKHRhZywgKCkgPT4gKHsgY2xhc3M6IFwiYnRuXCIsIGNoaWxkcmVuOiBgJHt0YWd9ICR7ZGlzYWJsZWQ/IGAgZGlzYWJsZWQgKCR7ZGlzYWJsZWQgPT0gXCJzb2Z0XCI/IFwic29mdFwiIDogXCJoYXJkXCJ9KWAgOiBcIlwifWAgfSkpfSAgLz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBCdXR0b24sIENoZWNrYm94LCBkZWZhdWx0UmVuZGVyQnV0dG9uLCBkZWZhdWx0UmVuZGVyQ2hlY2tib3gsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xuICAgIHJldHVybiA8QnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxufSovXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2NoZWNrYm94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBDaGVja2JveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5Ub2dnbGVzIGJldHdlZW4gY2hlY2tlZCBhbmQgdW5jaGVja2VkIHdoZW4gcHJlc3NlZCAoY2xpY2tlZCwgRW50ZXIgcHJlc3NlZCwgU3BhY2UgcmVsZWFzZWQsIGV0Yy4pPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+Q2FuIGJlIDxjb2RlPm1peGVkPC9jb2RlPiBpbnN0ZWFkLCB0aG91Z2ggPGNvZGU+b25JbnB1dDwvY29kZT4gd2lsbCBvbmx5IGV2ZXIgYmUgY2FsbGVkIHdpdGggPGNvZGU+dHJ1ZTwvY29kZT4gb3IgPGNvZGU+ZmFsc2U8L2NvZGU+PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U3VwcG9ydHMgdXNpbmcgPGNvZGU+Jmx0O2lucHV0Jmd0OzwvY29kZT5zIGFuZCA8Y29kZT4mbHQ7bGFiZWwmZ3Q7PC9jb2RlPnMsIGFzIHdlbGwgYXMganVzdCBwbGFpbiBvbCcgPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+cyBvbiBlaXRoZXIvYm90aDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGVja2JveCBhbmQgbGFiZWwgY2FuIGJlIHNpYmxpbmcgZWxlbWVudHMsIGxpa2Ugbm9ybWFsLCBvciB0aGUgbGFiZWwgY2FuIHdyYXAgdGhlIGlucHV0IGZvciBhIGxhcmdlciBoaXQgYXJlYS4gSW4gYWxsIGNhc2VzLCB0aGUgYXBwcm9wcmlhdGUgcm9sZXMvZXZlbnQgaGFuZGxlcnMgd2lsbCBiZSBhcHBsaWVkIHRvIGVhY2ggZWxlbWVudC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHNlbGVjdGluZyB0aGUgdGV4dCBvZiBhIGNoZWNrYm94J3MgbGFiZWwsIHRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZSBjaGVja2JveCdzIHN0YXRlPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+RG91YmxlLWNsaWNraW5nIHRoZSBsYWJlbCBjaGVja3MgJmFtcDsgdW4tY2hlY2tzIHRoZSBjaGVja2JveCBpbnN0ZWFkIG9mIHNlbGVjdGluZyB0aGUgbGFiZWwncyB0ZXh0PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+Q2hlY2tib3ggZ3JvdXBzICh3aXRoIGEgdHJpLXN0YXRlIHBhcmVudCkgYXJlIGEgc2VwYXJhdGUgY29tcG9uZW50L2hvb2s8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBjaGVja2JveCBkb2VzIG5vdCBoYXZlIGEgdmlzaWJsZSBsYWJlbCAoYWNoaWV2YWJsZSBieSBieSBvdmVycmlkaW5nIHRoZSA8Y29kZT5yZW5kZXI8L2NvZGU+IHByb3AgYW5kIHNldHRpbmcgPGNvZGU+bGFiZWxQb3NpdGlvbjwvY29kZT4gdG8gYmUgXCJzZXBhcmF0ZVwiKSwgeW91IG11c3QgcGFzcyA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiBhcyBhIHByb3AgdG8gdGhlIGNoZWNrYm94IG1hbnVhbGx5LiBOb3QgcHJvdmlkaW5nIG9uZSB3aWxsIHByaW50IGFuIGVycm9yIHRvIHRoZSBjb25zb2xlLCBidXQgaXQgaXQgbm90IHJlcXVpcmVkIGJ5IHRoZSB0eXBlIHN5c3RlbS48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgPENoZWNrYm94IGNoZWNrZWQ9e3RydWV9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCI+TGFiZWwgdGV4dDwvQ2hlY2tib3g+YH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcblxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlIGFzIGJvb2xlYW4gfCBcIm1peGVkXCIpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPEJ1dHRvbiB0YWdCdXR0b249XCJidXR0b25cIiBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IG9uUHJlc3M9eygpID0+IHsgc2V0Q2hlY2tlZChcIm1peGVkXCIgYXMgYW55KTsgfX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyQnV0dG9uKFwiYnV0dG9uXCIsICgpID0+ICh7IGNoaWxkcmVuOiBcIkNoYW5nZSB0byBtaXhlZFwiIH0pKX0gLz5cbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gc2V0Q2hlY2tlZD17c2V0Q2hlY2tlZH0gbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJsYWJlbFwiIC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJsYWJlbFwiIC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImxhYmVsXCIgLz5cbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gc2V0Q2hlY2tlZD17c2V0Q2hlY2tlZH0gbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImRpdlwiIC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImRpdlwiIC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImRpdlwiIC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJoaWRkZW5cIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgLz5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBEZW1vQ2hlY2tib3goeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCBzZXRDaGVja2VkIH06IHsgZGlzYWJsZWQ6IGJvb2xlYW4sIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiB8IFwid3JhcHBpbmdcIiB8IFwiaGlkZGVuXCIsIHRhZ0lucHV0OiBzdHJpbmcsIHRhZ0xhYmVsOiBzdHJpbmcsIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCIsIHNldENoZWNrZWQ6IFN0YXRlVXBkYXRlcjxib29sZWFuIHwgXCJtaXhlZFwiPiB9KSB7XG4gICAgLy9jb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBzdHlsZT17eyBib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCIgfX0+XG4gICAgICAgICAgICA8Q2hlY2tib3hcbiAgICAgICAgICAgIGdldERvY3VtZW50PXtnZXREb2N1bWVudH1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2UgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX1cbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uPXtsYWJlbFBvc2l0aW9uID09IFwiaGlkZGVuXCIgPyBcInNlcGFyYXRlXCIgOiBsYWJlbFBvc2l0aW9ufVxuICAgICAgICAgICAgICAgIHRhZ0lucHV0PXt0YWdJbnB1dCBhcyBuZXZlcn1cbiAgICAgICAgICAgICAgICB0YWdMYWJlbD17dGFnTGFiZWwgYXMgbmV2ZXJ9XG4gICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyQ2hlY2tib3goe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0YWdJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIG1ha2VJbnB1dFByb3BzOiAoKSA9PiAoeyBcImFyaWEtbGFiZWxcIjogbGFiZWxQb3NpdGlvbiA9PSBcImhpZGRlblwiID8gYEhpZGRlbiBsYWJlbCAodGVjaG5pY2FsbHkgc2VwYXJhdGUpLCAke3RhZ0lucHV0fSBhbmQgJHt0YWdMYWJlbH0gJHtjaGVja2VkID8gXCJjaGVja2VkXCIgOiBcIm5vdCBjaGVja2VkXCJ9YCA6IHVuZGVmaW5lZCwgfSksXG4gICAgICAgICAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogYCR7bGFiZWxQb3NpdGlvbn0sICR7dGFnSW5wdXR9IGFuZCAke3RhZ0xhYmVsfSwgJHtjaGVja2VkID8gXCJjaGVja2VkXCIgOiBcIm5vdCBjaGVja2VkXCJ9YCB9KVxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtsYWJlbFBvc2l0aW9uID09IFwiaGlkZGVuXCIgJiYgPGRpdj4oVGhpcyBpcyBub3QgYSBsYWJlbCAtLSB0aGUgYWN0dWFsIGxhYmVsIGlzIHZpYSB0aGUgPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gcHJvcCk8L2Rpdj59XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cblxuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xufVxuIiwiXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwLCBDaGVja2JveEdyb3VwQ2hlY2tib3gsIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwLCBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cENoaWxkLCBFdmVudERldGFpbCB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIERlbW9DaGVja2JveCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBDaGVja2JveCAjJHtpbmRleH1gXG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94R3JvdXBDaGVja2JveCByZW5kZXI9e2RlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQoe1xuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLFxuICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcbiAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsXG4gICAgICAgICAgICBtYWtlSW5wdXRQcm9wczogKCkgPT4gKHt9KSxcbiAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogbGFiZWxUZXh0IH0pXG4gICAgICAgIH0pfVxuICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxuICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiXG4gICAgICAgICAgICB0ZXh0PXtsYWJlbFRleHR9XG4gICAgICAgICAgICB0YWdJbnB1dD1cImlucHV0XCJcbiAgICAgICAgICAgIHRhZ0xhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IC8+XG4gICAgKVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD5DaGVja2JveCBncm91cHMgYXJlIGFuIGFsdGVybmF0aXZlIHRvIG11bHRpLXNlbGVjdCBsaXN0cy4gVGhlcmUgaXMgbm8gcm9sZSBvZiA8Y29kZT5jaGVja2JveGdyb3VwPC9jb2RlPiwgYnV0IHRoaXMgYWltcyB0byBiZSBhbiBBUklBLWNvbXBsaWFudCBpbXBsZW1lbnRhdGlvbiBvZiBhIGNoZWNrYm94IGdyb3VwLjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+QWxsIG5vcm1hbCA8Y29kZT5DaGVja2JveDwvY29kZT4gZnVuY3Rpb25hbGl0eSBpcyBzdXBwb3J0ZWQgb24gZWFjaCBpbmRpdmlkdWFsIGNoZWNrYm94LjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggc3dpdGNoZXMgYmV0d2VlbiAzIHN0YXRlcywgcmVtZW1iZXJpbmcgdGhlIGxhc3Qgc3RhdGUgdGhhdCBjYXVzZWQgaXQgdG8gYmUgXCJtaXhlZFwiLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggcmVhY3RzIHRvIGVhY2ggY2hpbGQncyA8Y29kZT5jaGVja2VkPC9jb2RlPiBwcm9wIGFuZCB1cGRhdGVzIGl0cyBvd24gaW50ZXJuYWwgPGNvZGU+Y2hlY2tlZDwvY29kZT4gYXR0cmlidXRlIChiZSBhd2FyZSBvZiB0aGlzIGlmIHRoZXkncmUgYXN5bmNyb25vdXMsIGFzIHlvdSdsbCB3YW50IHRvIGVuc3VyZSB0aGV5IGFsbCByZXNvbHZlIG9uIHRoZSBzYW1lIHRpY2sgd2l0aCA8Y29kZT5Qcm9taXNlLmFsbDwvY29kZT4gdG8gbm90IGNsb2JiZXIgdGhlIHVzZXIncyBpbnB1dHMpLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXJlbnQgY2hlY2tib3ggcHJvdmlkZXMgc3VmZmljaWVudCBsYWJlbGxpbmcgZm9yIGFsbCB0aGUgY2hpbGRyZW4sIHdoaWNoIGhvdyB0aGUgZGVtbyBleGFtcGxlIGlkZW50aWZpZXMgdGhlc2UgZWxlbWVudHMuIElmIHlvdSBoYXZlIGEgc2VwYXJhdGUgbGFiZWwsIHlvdSB3aWxsIG5lZWQgdG8gd3JhcCB0aGUgY2hpbGRyZW4gaW4gYSA8Y29kZT5yb2xlPWdyb3VwPC9jb2RlPiB0aGF0IHJlZmVyZW5jZXMgdGhhdCBsYWJlbCBieSBvdmVycmlkaW5nIDxjb2RlPnJlbmRlcjwvY29kZT4uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U2VlIHRoZSBjYXZlYXQgYWJvdmUgZm9yIHdoZW4gZWFjaCBjaGlsZCdzIDxjb2RlPm9uSW5wdXQ8L2NvZGU+IHRha2VzIGEgdmFyaWFibGUgYW1vdW50IG9mIHRpbWUgdG8gYWN0dWFsbHkgdXBkYXRlIHRoZSA8Y29kZT5jaGVja2VkPC9jb2RlPiBwcm9wLCBhcyBpdCBjYW4gY2xvYmJlciB0aGUgdXNlcidzIGxhc3QgaW5wdXQgd2hlbiBjbGlja2luZyBvbiB0aGUgcGFyZW50PC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiBjaGVja2JveGVzPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPENoZWNrYm94R3JvdXAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBkaXNhYmxlZD17ZmFsc2V9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgcmVuZGVyPXtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlSW5wdXRQcm9wczogKCkgPT4gKHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJHcm91cCBjaGVja2JveCBwYXJlbnRcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8ZGl2PjxEZW1vQ2hlY2tib3ggaW5kZXg9e2l9IGtleT17aX0gLz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IExpc3Rib3hNdWx0aUl0ZW0gfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L2xpc3Rib3gtbXVsdGlcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94TXVsdGksIGRlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGksIGRlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGlJdGVtIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5cbmNvbnN0IERlbW9MaXN0SXRlbSA9IG1lbW8oZnVuY3Rpb24gRGVtb0xpc3RJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBsYWJlbFRleHQgPSBgTGlzdCBpdGVtICMke2luZGV4fSR7c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifWBcblxuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdGJveE11bHRpSXRlbVxuICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IFxuICAgICAgICAgICAgc2VsZWN0ZWQ9e3NlbGVjdGVkfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxuICAgICAgICAgICAgdGV4dD17bGFiZWxUZXh0fVxuICAgICAgICAgICAgb25TZWxlY3RlZENoYW5nZT17ZSA9PiB7IHNldFNlbGVjdGVkKGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkKSB9fVxuICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyTGlzdGJveE11bHRpSXRlbSh7IHRhZ0xpc3RJdGVtOiBcImxpXCIsIG1ha2VQcm9wc0xpc3RJdGVtOiAoKSA9PiAoeyBjaGlsZHJlbjogbGFiZWxUZXh0IH0pIH0pfVxuICAgICAgICAvPlxuICAgIClcbn0pXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggc3dpdGNoZXMgYmV0d2VlbiAzIHN0YXRlcywgcmVtZW1iZXJpbmcgdGhlIGxhc3Qgc3RhdGUgdGhhdCBjYXVzZWQgaXQgdG8gYmUgXCJtaXhlZFwiLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggcmVhY3RzIHRvIGVhY2ggY2hpbGQncyA8Y29kZT5jaGVja2VkPC9jb2RlPiBwcm9wIGFuZCB1cGRhdGVzIGl0cyBvd24gaW50ZXJuYWwgPGNvZGU+Y2hlY2tlZDwvY29kZT4gYXR0cmlidXRlIChiZSBhd2FyZSBvZiB0aGlzIGlmIHRoZXkncmUgYXN5bmNyb25vdXMsIGFzIHlvdSdsbCB3YW50IHRvIGVuc3VyZSB0aGV5IGFsbCByZXNvbHZlIG9uIHRoZSBzYW1lIHRpY2sgd2l0aCA8Y29kZT5Qcm9taXNlLmFsbDwvY29kZT4gdG8gbm90IGNsb2JiZXIgdGhlIHVzZXIncyBpbnB1dHMpLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Hcm91cGluZyBpcyBzdXBwb3J0ZWQ8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Tb3J0aW5nL3Jlb3JkZXJpbmcgaXMgc3VwcG9ydGVkLCB0aG91Z2ggbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGFzIGl0J3MgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggZ3JvdXBpbmcuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgcGFyZW50IGNoZWNrYm94IHByb3ZpZGVzIHN1ZmZpY2llbnQgbGFiZWxsaW5nIGZvciBhbGwgdGhlIGNoaWxkcmVuLCB3aGljaCBob3cgdGhlIGRlbW8gZXhhbXBsZSBpZGVudGlmaWVzIHRoZXNlIGVsZW1lbnRzLiBJZiB5b3UgaGF2ZSBhIHNlcGFyYXRlIGxhYmVsLCB5b3Ugd2lsbCBuZWVkIHRvIHdyYXAgdGhlIGNoaWxkcmVuIGluIGEgPGNvZGU+cm9sZT1ncm91cDwvY29kZT4gdGhhdCByZWZlcmVuY2VzIHRoYXQgbGFiZWwgYnkgb3ZlcnJpZGluZyA8Y29kZT5yZW5kZXI8L2NvZGU+LjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlNlZSB0aGUgY2F2ZWF0IGFib3ZlIGZvciB3aGVuIGVhY2ggY2hpbGQncyA8Y29kZT5vbklucHV0PC9jb2RlPiB0YWtlcyBhIHZhcmlhYmxlIGFtb3VudCBvZiB0aW1lIHRvIGFjdHVhbGx5IHVwZGF0ZSB0aGUgPGNvZGU+Y2hlY2tlZDwvY29kZT4gcHJvcCwgYXMgaXQgY2FuIGNsb2JiZXIgdGhlIHVzZXIncyBsYXN0IGlucHV0IHdoZW4gY2xpY2tpbmcgb24gdGhlIHBhcmVudDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8Qmx1cmIgLz5cbiAgICAgICAgICAgIDxDb2RlIC8+XG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgbGlzdCBpdGVtczwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxMaXN0Ym94TXVsdGkgdGFnTGFiZWw9XCJsYWJlbFwiIHRhZ0xpc3Q9XCJ1bFwiIHJlbmRlcj17ZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aSh7XG4gICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsIHRhZ0xpc3Q6IFwidWxcIiwgbWFrZVByb3BzTGFiZWw6ICgpID0+ICh7fSksIG1ha2VQcm9wc0xpc3Q6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZUl0ZW0sIExpc3Rib3hTaW5nbGVJdGVtIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9saXN0Ym94LXNpbmdsZVwiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIExpc3Rib3hTaW5nbGUsIGRlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50OyB9XG5cbmNvbnN0IERlbW9MaXN0SXRlbSA9IG1lbW8oZnVuY3Rpb24gRGVtb0xpc3RJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxMaXN0Ym94U2luZ2xlSXRlbTxIVE1MTElFbGVtZW50PiBpbmRleD17aW5kZXh9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gZGlzYWJsZWQ9e2ZhbHNlfSB0ZXh0PXtgTGlzdCBpdGVtICMke2luZGV4fWB9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGVJdGVtKHsgdGFnTGlzdEl0ZW06IFwibGlcIiwgbWFrZVByb3BzTGlzdEl0ZW06ICh7IHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZCB9IH0pID0+ICh7IGNoaWxkcmVuOiBgTGlzdCBpdGVtICMke2luZGV4fSR7c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifWAgfSkgfSl9IC8+XG4gICAgKVxufSlcblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvbGlzdGJveC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgTGlzdGJveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JbiB0ZXJtcyBvZiBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCB0YWJiaW5nIHRocm91Z2ggZWxlbWVudHMsIGEgTGlzdGJveCBpcyBjb25zaWRlcmVkIGEgPHN0cm9uZz5zaW5nbGU8L3N0cm9uZz4gdGFiIHN0b3A7IGluIG90aGVyIHdvcmRzLCBubyBtYXR0ZXIgaG93IG1hbnkgbGlzdCBpdGVtcyB0aGVyZSBhcmUgaW4gYSBMaXN0Ym94LCBpdCBvbmx5IHRha2VzIG9uZSBwcmVzcyBvZiB0aGUgVGFiIGJ1dHRvbiB0byBnbyB0aHJvdWdoIGl0LlxuICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+V2hlbiBhIExpc3Rib3ggaXMgdGFiYmVkIGludG8sIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIGl0ZW0gaXMgZ2l2ZW4gZm9jdXM8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlByZXNzaW5nIFRhYiBhZ2FpbiBuYXZpZ2F0ZXMgb3V0IG9mIHRoZSBsaXN0Ym94OyBubyBvdGhlciBsaXN0IGl0ZW1zIGFyZSB0YWJiYWJsZSBvdGhlciB0aGFuIHRoZSBvbmUgY3VycmVudGx5IGRlc2lnbmF0ZWQuPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyB0aGUgYXJyb3cga2V5cyBuYXZpZ2F0ZXMgdGhyb3VnaCB0aGUgTGlzdGJveCBvbmUgaXRlbSBhdCBhIHRpbWU8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlByZXNzaW5nIHRoZSBIb21lL0VuZCBrZXlzIG1vdmUgZm9jdXMgdG8gdGhlIGZpcnN0L2xhc3QgaXRlbXMgcmVzcGVjdGl2ZWx5PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5UeXBpbmcgYW55IHNlcXVlbmNlIG9mIHRleHQgc3RhcnRzIHR5cGVhaGVhZCB0aGF0IG5hdmlnYXRlcyB0byB0aGUgbmV4dCBpdGVtIHRoYXQgbWF0Y2hlcyB3aGF0J3MgYmVpbmcgdHlwZWQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkZvY3VzICZhbXA7IHNlbGVjdGlvbiBtYW5hZ2VtZW50IGlzIGFzIG9wdGltaXplZCBhcyBwb3NzaWJsZTsgb25seSB0d28gY2hpbGRyZW4gcmUtcmVuZGVyIGF0IGEgdGltZSB3aGVuIGZvY3VzIG9yIHNlbGVjdGlvbiBjaGFuZ2VzPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5UaGVzZSBhcHBseSBnZW5lcmFsbHkgdG8gYWxsIGNvbXBvc2l0ZSBjb21wb25lbnRzIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgY2hpbGRyZW4gKFRhYiBMaXN0cywgUmFkaW8gR3JvdXBzLCBNdWx0aS1TZWxlY3QgTGlzdGJveGVzIGV0Yy4pPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5SYXRoZXIgdGhhbiBlYWNoIGluZGl2aWR1YWwgbGlzdCBpdGVtIGtub3dpbmcgd2hldGhlciBpdCBpcyBzZWxlY3RlZCBvciBub3QgKGFzIHdpdGggbXVsdGktc2VsZWN0IGxpc3RzKSwgaGVyZSB0aGUgcGFyZW50IGtub3dzIHRoZSA8Y29kZT5zZWxlY3RlZEluZGV4PC9jb2RlPiBhbmQgc2ltcGx5IG5vdGlmaWVzIHRoZSAobWF4IHR3bykgcmVsZXZhbnQgY2hpbGRyZW4gYW55IHRpbWUgaXQgY2hhbmdlcy48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Hcm91cGluZyBpcyBzdXBwb3J0ZWQ8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Tb3J0aW5nL3Jlb3JkZXJpbmcgaXMgc3VwcG9ydGVkLCB0aG91Z2ggbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGFzIGl0J3MgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggZ3JvdXBpbmcuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkxpc3Rib3hlcyBkbyBub3Qgc3VwcG9ydCBpbnRlcmFjdGl2ZSBjb250ZW50IHdpdGhpbiB0aGVtIChlLmcuIGEgZHJvcGRvd24gbWVudSksIGFzIEFSSUEgc3BlY2lmaWVzIHRoYXQgdGhpcyBpcyBhIGRpZmZlcmVudCBwYXR0ZXJuLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bGwgfCBudW1iZXI+KG51bGwpO1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8Qmx1cmIgLz5cbiAgICAgICAgICAgIDxDb2RlIC8+XG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgbGlzdCBpdGVtczwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxMaXN0Ym94U2luZ2xlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIiwgdGFnTGlzdDogXCJvbFwiLCBtYWtlUHJvcHNMYWJlbDogKCkgPT4gKHt9KSwgbWFrZVByb3BzTGlzdDogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD57QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX08Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlPVwiYWN0aXZhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0PVwib2xcIlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD17ZSA9PiBzZXRTZWxlY3RlZEluZGV4KGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkSW5kZXgpfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJNZW51LCBkZWZhdWx0UmVuZGVyTWVudUl0ZW0sIE1lbnUsIE1lbnVJdGVtIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9tZW51XCI7XG5cbmZ1bmN0aW9uIERlbW9MaXN0SXRlbSh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TWVudUl0ZW08SFRNTExJRWxlbWVudD4gaW5kZXg9e2luZGV4fSB0ZXh0PXtgTGlzdCBpdGVtICMke2luZGV4fWB9IHJlbmRlcj17ZGVmYXVsdFJlbmRlck1lbnVJdGVtKHsgdGFnTWVudUl0ZW06IFwibGlcIiwgbWFrZVByb3BzTWVudUl0ZW06ICgpID0+ICh7IGNoaWxkcmVuOiBgTWVudSBpdGVtICMke2luZGV4fWAgfSkgfSl9IC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPldoZW4gb3BlbmVkLCB0aGUgbWVudSB3aWxsIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiBpdC4gV2hlbiBjbG9zZWQgKGJ5IHByZXNzaW5nIGVzY2FwZSwgcHJlc3NpbmcgdGhlIGJ1dHRvbiBhZ2Fpbiwgb3IgdGFiYmluZyBvdXQgb2YgdGhlIG1lbnUpLCB0aGUgYnV0dG9uIHRoYXQgb3BlbmVkIGl0IHdpbGwgaGF2ZSBmb2N1cyByZXN0b3JlZCB0byBpdC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHRoZSBtZW51IGlzIGNsb3NlZCBiZWNhdXNlIGFub3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSB3YXMgZm9jdXNlZCBpbnN0ZWFkLCBmb2N1cyB3aWxsIG5vdCBiZSBtb2RpZmllZC48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VE9ETzwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIG1lbnUgaXRlbXM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8TWVudTxIVE1MRGl2RWxlbWVudCwgSFRNTFVMaXN0RWxlbWVudCwgSFRNTERpdkVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50PlxuICAgICAgICAgICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XG4gICAgICAgICAgICAgICAgICAgIG9uT3Blbj17KCkgPT4gc2V0T3Blbih0cnVlKX1cbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0T3BlbihmYWxzZSl9XG4gICAgICAgICAgICAgICAgICAgIG9wZW49e29wZW59XG4gICAgICAgICAgICAgICAgICAgIG9wZW5EaXJlY3Rpb249XCJkb3duXCJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyTWVudSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdCdXR0b246IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdNZW51OiBcInVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdTZW50aW5lbDogXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1N1cmZhY2U6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0J1dHRvbjogKCkgPT4gKHsgY2hpbGRyZW46IFwiT3BlbiBtZW51XCIgKyAob3Blbj8gXCIgKG9wZW4pXCIgOiBcIiAoY2xvc2VkKVwiKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc01lbnU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPGRpdj48RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX08Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzU3VyZmFjZTogKCkgPT4gKHsgc3R5bGU6IHsgZGlzcGxheTogIW9wZW4/IFwibm9uZVwiIDogdW5kZWZpbmVkIH0gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNTZW50aW5lbDogKCkgPT4gKHt9KSxcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUmFkaW8sIFJhZGlvLCBSYWRpb0dyb3VwIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9yYWRpby1ncm91cFwiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIGRlZmF1bHRSZW5kZXJSYWRpb0dyb3VwIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5cbmNvbnN0IERlbW9SYWRpb0J1dHRvbiA9IG1lbW8oZnVuY3Rpb24gRGVtb1JhZGlvQnV0dG9uKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcblxuICAgIGNvbnN0IHZhbHVlID0gYFJhZGlvIGJ1dHRvbiAjJHtpbmRleH1gO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFJhZGlvPG51bWJlciwgSFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD5cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIGdldERvY3VtZW50PXtnZXREb2N1bWVudH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiXG4gICAgICAgICAgICB0ZXh0PXt2YWx1ZX1cbiAgICAgICAgICAgIHZhbHVlPXtpbmRleH1cbiAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxuICAgICAgICAgICAgdGFnTGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJSYWRpbyh7XG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLFxuICAgICAgICAgICAgICAgIHRhZ0lucHV0OiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICBtYWtlSW5wdXRQcm9wczogKCkgPT4gKHsgbmFtZTogXCJyYWRpby1kZW1vXCIgfSksXG4gICAgICAgICAgICAgICAgbWFrZUxhYmVsUHJvcHM6ICgpID0+ICh7IGNoaWxkcmVuOiB2YWx1ZSB9KVxuICAgICAgICAgICAgfSl9IC8+XG4gICAgKVxufSlcblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvcmFkaW9idXR0b24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIFJhZGlvIEJ1dHRvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGlucHV0ICZhbXA7IGxhYmVsIHN1cHBvcnQgdGhlIHNhbWUgdGV4dC1zZWxlY3Rpb24gYWZmb3JkYW5jZXMgYXMgQ2hlY2tib3hlcyAobGFiZWxzIGNhbiBiZSBzZWxlY3RlZCwgYnV0IGRvdWJsZS1jbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0aGUgdGV4dCBhbmQgc2VsZWN0aW5nIHRleHQgZG9lc24ndCBjb3VudCBhcyBhbiBpbnB1dCk8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5TZWxlY3Rpb24gc3RhdGUgaXMgaGFuZGxlZCBieSB0aGUgcGFyZW50OyBpbnN0ZWFkIG9mIHNwZWNpZnlpbmcgd2hldGhlciBhbnkgZ2l2ZW4gcmFkaW8gYnV0dG9uIGlzIGNoZWNrZWQgb3Igbm90LCB0aGUgcGFyZW50IG5vdGlmaWVzIGVhY2ggY2hpbGQgb2YgdGhlIG5lY2Vzc2FyeSBjaGFuZ2VzLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JZiB5b3VyIGNoZWNrYm94IGRvZXMgbm90IGhhdmUgYSB2aXNpYmxlIGxhYmVsIChhY2hpZXZhYmxlIGJ5IGJ5IG92ZXJyaWRpbmcgdGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBhbmQgc2V0dGluZyA8Y29kZT5sYWJlbFBvc2l0aW9uPC9jb2RlPiB0byBiZSBcInNlcGFyYXRlXCIpLCB5b3UgbXVzdCBwYXNzIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+IGFzIGEgcHJvcCB0byB0aGUgY2hlY2tib3ggbWFudWFsbHkuIE5vdCBwcm92aWRpbmcgb25lIHdpbGwgcHJpbnQgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGUsIGJ1dCBpdCBpdCBub3QgcmVxdWlyZWQgYnkgdGhlIHR5cGUgc3lzdGVtLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBhYm92ZSBhbHNvIGFwcGxpZXMgdG8gdGhlIHJhZGlvIGdyb3VwIGFzIGEgd2hvbGU7IEFSSUEgcmVxdWlyZXMgdGhhdCBhbGwgUmFkaW8gQnV0dG9ucyBiZSBjb250YWluZWQgd2l0aGluIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmljIHJvbGUgd2hpY2ggaXMgbGFiZWxsZWQgZWl0aGVyIGJ5IGFuIGVsZW1lbnQgKGhhbmRsZWQgZm9yIHlvdSkgb3IgPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gKHNwZWNpZmllZCBieSB5b3UgbWFudWFsbHkgb24gdGhlIGlucHV0KS48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsKTtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHJhZGlvIGJ1dHRvbnM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8UmFkaW9Hcm91cDxudW1iZXIsIEhUTUxEaXZFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50LCBIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PlxuICAgICAgICAgICAgICAgICAgICBuYW1lPVwicmFkaW8tZGVtb1wiXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZT17ZSA9PiBzZXRTZWxlY3RlZEluZGV4KGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkVmFsdWUgPz8gMCl9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU9e3NlbGVjdGVkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIHRhZ0dyb3VwTGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgIHRhZ0dyb3VwPVwiZGl2XCJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdHcm91cDogXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNHcm91cDogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1JhZGlvQnV0dG9uIGluZGV4PXtpfSBrZXk9e2l9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNMYWJlbDogKGluZm8pID0+ICh7IGNoaWxkcmVuOiBcIlJhZGlvIGdyb3VwIGV4YW1wbGUgXCIgKyBcIihcIiArIGluZm8ucmFkaW9Hcm91cC5zZWxlY3RlZEluZGV4Py50b1N0cmluZygpICsgXCIpXCIgfSlcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIExpc3Rib3hTaW5nbGUgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJTbGlkZXJUaHVtYiwgU2xpZGVyVGh1bWIsIFNsaWRlciB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvc2xpZGVyXCJcblxuZnVuY3Rpb24gRGVtb1NsaWRlclRodW1iKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlKDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNsaWRlclRodW1iPEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICB0YWc9XCJpbnB1dFwiXG4gICAgICAgICAgICBsYWJlbD17YFNsaWRlciB0aHVtYiAjJHtpbmRleH1gfVxuICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZT17ZSA9PiBzZXRWYWx1ZShlW0V2ZW50RGV0YWlsXS52YWx1ZSl9XG4gICAgICAgICAgICBtaW49ezB9XG4gICAgICAgICAgICBtYXg9ezEwfVxuICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyU2xpZGVyVGh1bWIoeyB0YWdUaHVtYjogXCJpbnB1dFwiLCBtYWtlUHJvcHNUaHVtYjogKCkgPT4gKHt9KSB9KX0gLz5cbiAgICApXG59XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50OyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvbGlzdGJveC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgTGlzdGJveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+V2hlbiBvcGVuZWQsIHRoZSBtZW51IHdpbGwgZm9jdXMgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aGluIGl0LiBXaGVuIGNsb3NlZCAoYnkgcHJlc3NpbmcgZXNjYXBlLCBwcmVzc2luZyB0aGUgYnV0dG9uIGFnYWluLCBvciB0YWJiaW5nIG91dCBvZiB0aGUgbWVudSksIHRoZSBidXR0b24gdGhhdCBvcGVuZWQgaXQgd2lsbCBoYXZlIGZvY3VzIHJlc3RvcmVkIHRvIGl0LjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPldoZW4gdGhlIG1lbnUgaXMgY2xvc2VkIGJlY2F1c2UgYW5vdGhlciBlbGVtZW50IG9uIHRoZSBwYWdlIHdhcyBmb2N1c2VkIGluc3RlYWQsIGZvY3VzIHdpbGwgbm90IGJlIG1vZGlmaWVkLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5UT0RPPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcbiAgICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8Qmx1cmIgLz5cbiAgICAgICAgICAgIDxDb2RlIC8+XG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2Ygc2xpZGVyIHRodW1iczwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxTbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICAgICAgICBtYXg9ezEwfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbj17PD57QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9TbGlkZXJUaHVtYiBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpKX1cbiAgICAgICAgICAgICAgICAgICAgPC8+fSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckRpYWxvZywgRGlhbG9nIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9kaWFsb2dcIjtcbmltcG9ydCB7IEJ1dHRvbiwgZGVmYXVsdFJlbmRlckJ1dHRvbiB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9kaWFsb2dtb2RhbC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgTW9kYWwgRGlhbG9nIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkRpYWxvZ3MgYmxvY2sgYWxsIG90aGVyIGVsZW1lbnRzIG9uIHRoZSBwYWdlIGZyb20gcmVjZWl2aW5nIGZvY3VzL2ludGVyYWN0aW9uIGFuZCBiZWluZyBwZXJjZWl2YWJsZSB0byBzY3JlZW4gcmVhZGVycy48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5EaWFsb2dzIGNhbiBiZSBkaXNtaXNzZWQgYnkgcHJlc3NpbmcgRXNjYXBlIG9yIGNsaWNraW5nIHRoZSBlbGVtZW50IGRlc2lnbmF0ZWQgYXMgdGhlIGJhY2tkcm9wLCBib3RoIG9mIHdoaWNoIGNhbiBiZSBjYW5jZWxsZWQvaWdub3JlZCBpZiB5b3UgbmVlZDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPldoZW4gb3BlbmVkLCB0aGUgZGlhbG9nIHdpbGwgZm9jdXMgaXRzIHRpdGxlIG9yIGJvZHkgY29udGVudCBhcyBhcHByb3ByaWF0ZSwgaG93ZXZlciByZWFkIGJlbG93IHVuZGVyIFRoaW5ncyBOb3QgSGFuZGxlZCBmb3IgY2F2ZWF0cy48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIGNsb3NlZCBmb3IgYW55IHJlYXNvbiwgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcmVzcG9uc2libGUgZm9yIG9wZW5pbmcgdGhlIGRpYWxvZyB3aWxsIGJlIGZvY3VzZWQuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkJ5IGRlZmF1bHQsIHdoZW4gb3BlbmVkLCBhIGRpYWxvZyB3aWxsIGZvY3VzIGl0cyBib2R5IGNvbnRlbnQgb3IgdGl0bGUgY29udGVudCBkZXBlbmRpbmcgb24gPGNvZGU+Ym9keUlzT25seVNlbWFudGljPC9jb2RlPiwgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlIGRpYWxvZydzIGJvZHkgY29udGFpbnMgbm8gaW50ZXJhY3RpdmUgZWxlbWVudHMuIFRoaXMgbWF5IG5vdCBiZSBzdWl0YWJsZSBmb3IgYWxsIHNpdHVhdGlvbnMuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgPGVtPmhpZ2h0bHk8L2VtPiByZWNvbW1lbmRlZCB0byBvdmVycmlkZSA8Y29kZT5mb2N1c1NlbGY8L2NvZGU+IGZvciBhbGwgZGlhbG9ncyB5b3UgY3JlYXRlLCBhbmQgaGF2ZSBpdCBmb2N1cyB3aGF0ZXZlciBlbGVtZW50IG1ha2VzIHRoZSBtb3N0IHNlbnNlIGZvciB5b3VyIHBhcnRpY3VsYXIgZGlhbG9nLlxuICAgICAgICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+RGlhbG9ncyB0aGF0IGFjdCBsaWtlIGEgZm9ybSBzaG91bGQgZm9jdXMgdGhlIGZpcnN0IGludGVyYWN0aXZlIGVsZW1lbnQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkRpYWxvZ3MgdGhhdCBwZXJmb3JtIGRlc3RydWN0aXZlIGFjdGlvbnMgc2hvdWxkIGZvY3VzIHRoZSBcIkNhbmNlbFwiIGJ1dHRvbjwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+SW4gc29tZSBjYXNlcywgaXQncyBiZXN0IHRvIGZvY3VzIHRoZSBmaXJzdCBwYXJhZ3JhcGggb2YgdGhlIGJvZHkuPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICAgSW4gYWxsIGNhc2VzLCBjb25zaWRlciB0aGF0IHRoZSBmaXJzdCBmb2N1c2VkIGVsZW1lbnQgd2lsbCBib3RoIGJlIGhvdyBrZXlib2FyZCB1c2VycyBpbnRlcmFjdCB3aXRoIHRoZSBkaWFsb2csIGJ1dCBhbHNvIHRoZSBmaXJzdCB0aGluZyBhIHNjcmVlbiByZWFkZXIgd2lsbCByZWFkIGFsb3VkLlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHIgPSB1c2VDYWxsYmFjaygoLi4uYXJnczogYW55W10pID0+IHsgY29uc29sZS5sb2coLi4uYXJncyk7IH0sIFtdKTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPEJ1dHRvbiB0YWdCdXR0b249XCJidXR0b25cIiBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IG9uUHJlc3M9eygpID0+IHNldE9wZW4odHJ1ZSl9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckJ1dHRvbihcImJ1dHRvblwiLCAoKSA9PiAoeyBjaGlsZHJlbjogXCJPcGVuIGRpYWxvZyBcIiArIChvcGVuID8gXCIob3BlbilcIiA6IFwiKGNsb3NlZClcIikgfSkpfSAvPlxuICAgICAgICAgICAgICAgIDxEaWFsb2dcbiAgICAgICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgICAgICAgICAgb3Blbj17b3Blbn1cbiAgICAgICAgICAgICAgICAgICAgYm9keUlzT25seVNlbWFudGljPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJEaWFsb2coe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsSWQ6IFwicG9ydGFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNCYWNrZHJvcDogKCkgPT4gKHsgXCJkYXRhLXR5cGVcIjogXCJiYWNrZHJvcFwiIH0gYXMge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzRm9jdXNDb250YWluZXI6ICgpID0+ICh7IFwiZGF0YS10eXBlXCI6IFwiZm9jdXNcIiB9IGFzIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0JvZHk6ICgpID0+ICh7IGNoaWxkcmVuOiBcIkRpYWxvZyBib2R5XCIgLCBcImRhdGEtdHlwZVwiOiBcImJvZHlcIn0gYXMge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzRGlhbG9nOiAoKSA9PiAoeyBzdHlsZTogeyBkaXNwbGF5OiAhb3BlbiA/IFwibm9uZVwiIDogdW5kZWZpbmVkIH0sIFwiZGF0YS10eXBlXCI6IFwiZGlhbG9nXCIgfSBhcyB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNUaXRsZTogKCkgPT4gKHsgY2hpbGRyZW46IFwiRGlhbG9nIHRpdGxlXCIsIFwiZGF0YS10eXBlXCI6IFwidGl0bGVcIiB9IGFzIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0JhY2tkcm9wOiBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQm9keTogXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0RpYWxvZzogXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1RpdGxlOiBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnRm9jdXNDb250YWluZXI6IFwiZGl2XCJcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59XG4iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclRhYiwgZGVmYXVsdFJlbmRlclRhYlBhbmVsLCBkZWZhdWx0UmVuZGVyVGFicywgVGFicyB9IGZyb20gXCIuLi8uLi9cIjtcbmltcG9ydCB7IFRhYiwgVGFiUGFuZWwgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L3RhYnNcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy90YWJwYW5lbC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgVGFiIGFuZCBUYWIgUGFuZWwgcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIHRhYnMgYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPlRPRE88L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHRhYnM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8VGFic1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlPVwiZm9jdXNcIlxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4KX1cblxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsczogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9UYWJQYW5lbCBpPXtpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xpc3Q6IFwidWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJUYWJzIGV4YW1wbGVcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0xpc3Q6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9UYWIgaT17aX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmNvbnN0IERlbW9UYWIgPSBtZW1vKGZ1bmN0aW9uIERlbW9UYWIoeyBpIH06IHsgaTogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBsYWJlbCA9IGBUYWIgIyR7aX1gO1xuICAgIHJldHVybiA8VGFiIGtleT17aX0gaW5kZXg9e2l9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFiKHsgdGFnVGFiOiBcImxpXCIsIG1ha2VQcm9wc1RhYjogKCkgPT4gKHsgY2hpbGRyZW46IGxhYmVsIH0pIH0pfSB0ZXh0PXtsYWJlbH0gLz5cbn0pXG5cbmNvbnN0IERlbW9UYWJQYW5lbCA9IG1lbW8oZnVuY3Rpb24gRGVtb1RhYlBhbmVsKHsgaSB9OiB7IGk6IG51bWJlciB9KSB7XG4gICAgY29uc3QgbGFiZWwgPSBgVGFiIHBhbmVsICMke2l9YDtcbiAgICByZXR1cm4gPFRhYlBhbmVsIGluZGV4PXtpfSBrZXk9e2l9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYlBhbmVsKHsgdGFnVGFiUGFuZWw6IFwiZGl2XCIsIG1ha2VQcm9wc1RhYlBhbmVsOiAoeyB0YWJQYW5lbDogeyB2aXNpYmxlIH0gfSkgPT4gKHsgaGlkZGVuOiAhdmlzaWJsZSwgY2hpbGRyZW46IGxhYmVsIH0pIH0pfSAvPlxufSlcblxuIiwiXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyVG9vbHRpcCwgVG9vbHRpcCB9IGZyb20gXCIuLi8uLi9cIjtcblxuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3Rvb2x0aXAvXCI+VG9vbHRpcHMgaGF2ZSB5ZXQgdG8gYmUgd2VsbCBkZWZpbmVkIGluIG1hbnkgYXJlYXM8L2E+LCBidXQgdGhpcyBpbXBsZW1lbnRhdGlvbiBhaW1zIHRvIHN1cHBvcnQgY29tbW9uIHVzZSBjYXNlczo8L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkhvdmVyaW5nIG9yIGZvY3VzaW5nIHRoZSB0cmlnZ2VyIGVsZW1lbnQgc2hvd3MgdGhlIHRvb2x0aXA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgdG9vbHRpcCBzdGF5cyBzaG93biB3aGVuIGl0IGl0c2VsZiBpcyBob3ZlcmVkL2ZvY3VzZWQgYXMgd2VsbCwgc28gdGhhdCB0aGUgdGV4dCBpbnNpZGUgY2FuIGJlIHNlbGVjdGVkPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+TW92aW5nIHRoZSBtb3VzZSBiZXR3ZWVuIHRoZSB0cmlnZ2VyIGFuZCB0aGUgdG9vbHRpcCBoYXMgc29tZSB0b2xlcmFuY2UgYXNzb2NpYXRlZCB3aXRoIGltbWVkaWF0ZWx5IGhpZGluZyB0aGUgdG9vbHRpcC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Ib3ZlcmluZywgZm9jdXNpbmcsIGFuZCByZS1ob3ZlcmluZyBjYW4gZWFjaCBoYXZlIGEgY3VzdG9tIGRlbGF5IGFzc29jaWF0ZWQgd2l0aCBpdDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5Zb3UgbXVzdCBlbnN1cmUgdGhhdCBlaXRoZXIgdGhlIHRvb2x0aXAgY29udGFpbnMgYSBmb2N1c2FibGUgZWxlbWVudCAoYSBidXR0b24sIGxpbmssIDxjb2RlPiZsdDtkaXYgdGFiSW5kZXg9XCItMVwiIC8mZ3Q7PC9jb2RlPiwgZXRjLik8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Mb25nIHByZXNzZXMgb24gbW9iaWxlIGRldmljZXMgYXJlIG5vdCB5ZXQgaGFuZGxlZCAoZS5nLiBhIGxvbmcgcHJlc3Mgb24gYSBidXR0b24gdHJpZ2dlcnMgYSB0b29sdGlwIGJ1dCBkb2VzIG5vdCBhY3RpdmF0ZSB0aGUgYnV0dG9uKTwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHRleHQgdHJpZ2dlcnMgYSB0b29sdGlwOiA8VG9vbHRpcCBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRvb2x0aXAoe1xuXG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbElkOiBcInBvcnRhbFwiLFxuXG4gICAgICAgICAgICAgICAgICAgIG1ha2VUb29sdGlwUHJvcHM6ICh7IGlzT3BlbiB9KSA9PiAoeyBjaGlsZHJlbjogXCJUaGlzIHRleHQgZGVzY3JpYmVzIHRoZSB0cmlnZ2VyaW5nIHRleHQgaW4gbW9yZSBkZXRhaWwuXCIsIHN0eWxlOiB7IG9wYWNpdHk6ICtpc09wZW4gfSB9KSxcbiAgICAgICAgICAgICAgICAgICAgbWFrZVRyaWdnZXJQcm9wczogKCkgPT4gKHsgY2hpbGRyZW46IFwiVG9vbHRpcC10cmlnZ2VyaW5nIHRleHQgdGhhdCBpcyBob3ZlcmFibGUgYW5kIGZvY3VzYWJsZTpcIiwgdGFiSW5kZXg6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgIHRhZ1Rvb2x0aXA6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgIHRhZ1RyaWdnZXI6IFwic3BhblwiXG4gICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5cbiIsIlxuaW1wb3J0IHsgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBUb2FzdCwgVG9hc3RzIH0gZnJvbSBcIi4uLy4uL1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2FsZXJ0L1wiPlRvYXN0cyAoYWthIHNuYWNrYmFycykgYXJlIGltcGxlbWVudGVkIHVzaW5nIHRoZSBBbGVydCBwYXR0ZXJuLjwvYT48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPlB1c2hpbmcgYSB0b2FzdHMgY2F1c2VzIGl0cyBjb250ZW50cyB0byBiZSBzaG93biB2aXNpYmx5IChhbmQgYXVkaWJseSB3aXRoIGEgc2NyZWVuIHJlYWRlcik8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Pbmx5IG5ldyB0b2FzdHMgYXJlIGFubm91bmNlZDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRvYXN0cyBhcmUgc2hvd24gYXMgc29vbiBhcyB0aGV5IGFyZSBwdXNoZWQsIGJ1dCB5b3UgY2FuIGNvbnRyb2wgdGhlIG1heGltdW0gbnVtYmVyIHNob3duIGF0IG9uY2Ugd2l0aDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRvYXN0cyBjYW4gYmUgZGlzbWlzc2VkIGluIGFueSBvcmRlcjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRvYXN0cyBjYW4gYmUgc2V0IHRvIGF1dG8tZGlzbWlzcy48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+QXV0by1kaXNtaXNzIGJlaGF2aW9yIGlzIHZlcnkgc2l0dWF0aW9uYWwuIEFuIGF1dG8tZGlzbWlzc2VkIHRvYXN0IHNob3VsZCBvbmx5IHJlZmVyIHRvIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIHZpZXdlZCBlbHNld2hlcmU7IFwiWCBmaWxlcyBkZWxldGVkXCIgY2FuIGJlIGRvdWJsZS1jaGVja2VkIGluIHRoZSBSZWN5Y2xlIEJpbiwgXCJYIGhhcyBsb2dnZWQgaW5cIiB3aGljaCB5b3UgY2FuIGFsb25nIHdpdGggZXZlcnlvbmUgZWxzZSBpbiBhIHRhYiBzb21ld2hlcmUsIGV0Yy4gVGhpcyBvYnZpb3VzbHkgY2Fubm90IGJlIGNoZWNrZWQgcHJvZ3JhbW1hdGljYWxseS48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UT0RPOiBGb2N1cyBtYW5hZ2VtZW50IHJlbGF0ZWQgdG8gdG9hc3RzIHRoYXQgaGF2ZSBpbnRlcmFjdGl2ZSBjb250ZW50PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VE9ETzogVG9hc3RzIGFyZSBzdGlsbCBhbm5vdW5jZWQgZXZlbiB3aGVuIHRoZSBjdXJyZW50IGJyb3dzZXIgdGFiIGlzIGhpZGRlbiBpbnN0ZWFkIG9mIHNhdmluZyB0aGVtIGZvciB3aGVuIHRoZSB1c2VyIHJldHVybnM8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UT0RPOiBUb2FzdHMgc3RpbGwgYXV0by1kaXNtaXNzIHdoZW4gdGhleSBoYXZlIGZvY3VzL2FyZSBiZWluZyBpbnRlcmFjdGVkIHdpdGg8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcblxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHVzZVJlZigwKTtcbiAgICBjb25zdCBbdG9hc3RzLCBzZXRUb2FzdHNdID0gdXNlU3RhdGU8Vk5vZGVbXT4oW10pO1xuXG4gICAgY29uc3QgcHVzaFRvYXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRJbmRleC5jdXJyZW50O1xuICAgICAgICBjdXJyZW50SW5kZXguY3VycmVudCArPSAxO1xuXG4gICAgICAgIHNldFRvYXN0cyh0ID0+IFsuLi50LCA8VG9hc3QgaW5kZXg9e2luZGV4fSBrZXk9e2luZGV4fSByZW5kZXI9eyh7IHRvYXN0OiB7IGRpc21pc3MsIHNob3dpbmcsIGRpc21pc3NlZCwgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMgfSB9KSA9PiAoXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXtzaG93aW5nID8ge30gOiB7IG9wYWNpdHk6IDAuNSB9fT5UaGlzIHRoZSB0b2FzdCB3aXRoIGFuIGluZGV4IG9mIHtpbmRleH0uICgje251bWJlck9mVG9hc3RzQWhlYWRPZlVzfSBpbiB0aGUgcXVldWUgdG8gYmUgc2hvd24pLiA8YnV0dG9uIGRpc2FibGVkPXtkaXNtaXNzZWR9IG9uQ2xpY2s9e2Rpc21pc3N9PkNsaWNrIHRvIGRpc21pc3M8L2J1dHRvbj48L2Rpdj5cbiAgICAgICAgKX0gdGltZW91dD17bnVsbH0gLz5dKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtwdXNoVG9hc3R9PlB1c2ggYSB0b2FzdDwvYnV0dG9uPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8VG9hc3RzPEhUTUxEaXZFbGVtZW50PiB2aXNpYmxlQ291bnQ9ezN9IHJlbmRlcj17KGluZm8sIHByb3BzKSA9PiB7IHJldHVybiA8ZGl2IHsuLi5wcm9wc30+e3RvYXN0c308L2Rpdj4gfX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cblxuIiwiXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBtZW1vLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgVGFibGUsIFRhYmxlQm9keSwgVGFibGVCb2R5UHJvcHMsIFRhYmxlQ2VsbCwgVGFibGVDZWxsUHJvcHMsIFRhYmxlRm9vdCwgVGFibGVGb290UHJvcHMsIFRhYmxlSGVhZCwgVGFibGVIZWFkUHJvcHMsIFRhYmxlUHJvcHMsIFRhYmxlUm93LCBUYWJsZVJvd1Byb3BzLCBkZWZhdWx0UmVuZGVyVGFibGUsIGRlZmF1bHRSZW5kZXJUYWJsZUJvZHksIGRlZmF1bHRSZW5kZXJUYWJsZUNlbGwsIGRlZmF1bHRSZW5kZXJUYWJsZUZvb3QsIGRlZmF1bHRSZW5kZXJUYWJsZUhlYWQsIGRlZmF1bHRSZW5kZXJUYWJsZVJvdyB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvdGFibGVcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlLCBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZSB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50OyB9XG5cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD5UaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGFuIGludGVyYWN0aXZlIGRhdGEgdGFibGUgdGhhdCBjb21wbGllcyB3aXRoIDxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3RhYmxlL1wiPnRoZSBBUklBIGd1aWRlbGluZXMgZm9yIFRhYmxlIHBhdHRlcm5zPC9hPi48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkluIHRlcm1zIG9mIGtleWJvYXJkIG5hdmlnYXRpb24gYW5kIHRhYmJpbmcgdGhyb3VnaCBlbGVtZW50cywgYSBUYWJsZSBpcyBjb25zaWRlcmVkIGEgPHN0cm9uZz5zaW5nbGU8L3N0cm9uZz4gdGFiIHN0b3A7IGluIG90aGVyIHdvcmRzLCBubyBtYXR0ZXIgaG93IG1hbnkgY2VsbHMgdGhlcmUgYXJlIGluIGEgdGFibGUgKGluY2x1ZGluZyBpZiB0aGUgY2VsbHMgY29udGFpbiBpbnRlcmFjdGl2ZSBlbGVtZW50cyksIGl0IG9ubHkgdGFrZXMgb25lIHByZXNzIG9mIHRoZSBUYWIgYnV0dG9uIHRvIGdvIHRocm91Z2ggaXQuXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyB0aGUgYXJyb3cga2V5cyBuYXZpZ2F0ZXMgdGhyb3VnaCB0aGUgY2VsbHMgb2YgdGhlIFRhYmxlLiBZb3UgY2FuIG92ZXJyaWRlIGVhY2ggY2VsbCdzIDxjb2RlPmZvY3VzU2VsZjwvY29kZT4gcHJvcCB0byBoYW5kbGUgY2hpbGQgZWxlbWVudHMuPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5Nb3N0IG90aGVyIHJ1bGVzIG9mIGxpc3QgbmF2aWdhdGlvbiBhcHBseSAoYXMgaW4gTGlzdGJveGVzKSwgYnV0IGluIHR3byBkaW1lbnNpb25zLjwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGJvZHkgcm93cyBhcmUgc29ydGFibGUgdmlhIGVhY2ggY2VsbCdzIDxjb2RlPnZhbHVlPC9jb2RlPiBwcm9wLiBBcyBhIHJlc3VsdCBvZiB0aGlzLCBlYWNoIHJvdyBtdXN0IGJlIGEgPGVtPmRpcmVjdDwvZW0+IGNoaWxkIG9mIHRoZSBib2R5LCBsaWtlIGFzIGEgbm9ybWFsIGFycmF5IG9mIGNoaWxkcmVuIHdpdGggbm8gaW50ZXJ2ZW5pbmcgSlNYLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JZiB5b3UgZG9uJ3QgbmVlZCBhbGwgdGhlIHNvcnRpbmcgYW5kIGZvY3VzIG1hbmFnZW1lbnQgYW5kIHN1Y2gsIHRoZXJlJ3Mgbm8gcmVhc29uIG5vdCB0byBqdXN0IHVzZSB0aGUgZ29vZCBvbGQgPGNvZGU+Jmx0O3RhYmxlJmd0OzwvY29kZT4gZWxlbWVudC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5JdCdzIHVwIHRvIHlvdSB0byBtYWtlIHN1cmUgdGhhdCBhbnkgaW50ZXJhY3RpdmUgZWxlbWVudHMgd2l0aGluIGEgdGFibGUgY2VsbCByZXNwb25kIHRvIGZvY3VzIG1hbmFnZW1lbnQgcHJvcGVybHkgd2l0aCB0aGUgYWZvcmVtZW50aW9uZWQgPGNvZGU+Zm9jdXNTZWxmPC9jb2RlPiBwcm9wIGFuZCBhIHByb3Blcmx5IHBsYWNlZCA8Y29kZT50YWJJbmRleD17XCJ7XCJ9aW5mby5yb3ZpbmdUYWJJbmRleC50YWJiYWJsZT8gMCA6IC0xe1wifVwifTwvY29kZT4gaW4gdGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcC48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5cbmZ1bmN0aW9uIERlbW9JbnB1dCh7IHRhYmJhYmxlIH06IHsgdGFiYmFibGU6IGJvb2xlYW4gfSkge1xuICAgIGNvbnN0IFt2LCBzZXRWXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHRhYkluZGV4PXt0YWJiYWJsZSA/IDAgOiAtMX0gb25JbnB1dD17dXNlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgICAgIHNldFYoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgW10pfSB2YWx1ZT17dn0gLz5cbiAgICApXG59XG5cbmZ1bmN0aW9uIERlbW9UYWJsZUNlbGwoeyBpbmRleCwgaGVhZGVyIH06IHsgaW5kZXg6IG51bWJlciwgaGVhZGVyPzogYm9vbGVhbiB9KSB7XG4gICAgY29uc3QgciA9IHVzZVJlZihNYXRoLnJhbmRvbSgpKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGBIZWFkZXIgIyR7aW5kZXh9YDtcbiAgICAgICAgcmV0dXJuIDxUYWJsZUNlbGwgaGVhZGVyVHlwZT1cImNvbHVtblwiIHRhZ1RhYmxlQ2VsbD1cInRoXCIgaW5kZXg9e2luZGV4fSBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IHRleHQ9e3RleHR9IHZhbHVlPXt0ZXh0fSByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJsZUNlbGwoeyB0YWdUYWJsZUNlbGw6IFwidGhcIiwgbWFrZVByb3BzVGFibGVDZWxsOiAoaW5mbykgPT4gKHsgY2hpbGRyZW46IDxidXR0b24gdGFiSW5kZXg9e2luZm8ucm92aW5nVGFiSW5kZXgudGFiYmFibGUgPyAwIDogLTF9IG9uQ2xpY2s9eygpID0+IGluZm8udGFibGVIZWFkZXJDZWxsLnNvcnQoKX0+e3RleHR9PC9idXR0b24+IH0pIH0pfSAvPlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGBDZWxsIGluIGNvbHVtbiAjJHtpbmRleH1gO1xuICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxUYWJsZUNlbGwgaGVhZGVyVHlwZT17bnVsbH0gdGFnVGFibGVDZWxsPVwidGRcIiBpbmRleD17aW5kZXh9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gdGV4dD17XCJcIn0gdmFsdWU9e1wiXCJ9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlQ2VsbCh7XG4gICAgICAgICAgICAgICAgICAgIHRhZ1RhYmxlQ2VsbDogXCJ0ZFwiLCBtYWtlUHJvcHNUYWJsZUNlbGw6IChpbmZvKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDxEZW1vSW5wdXQgdGFiYmFibGU9e2luZm8ucm92aW5nVGFiSW5kZXgudGFiYmFibGV9IC8+XG5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxUYWJsZUNlbGwgaGVhZGVyVHlwZT17bnVsbH0gdGFnVGFibGVDZWxsPVwidGRcIiBpbmRleD17aW5kZXh9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gdGV4dD17ci5jdXJyZW50LnRvU3RyaW5nKCl9IHZhbHVlPXtyLmN1cnJlbnQudG9TdHJpbmcoKX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVDZWxsKHsgdGFnVGFibGVDZWxsOiBcInRkXCIsIG1ha2VQcm9wc1RhYmxlQ2VsbDogKCkgPT4gKHsgY2hpbGRyZW46IHIuY3VycmVudC50b1N0cmluZygpIH0pIH0pfSAvPlxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHRhYmxlIHJvd3M8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8VGFibGUgbm9UeXBlYWhlYWQ9e3RydWV9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgdGFnVGFibGU6IFwidGFibGVcIiwgXG4gICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc1RhYmxlOiAoKSA9PiAoe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VGFibGVIZWFkIHRhZ1RhYmxlSGVhZD1cInRoZWFkXCIgcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVIZWFkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnVGFibGVIZWFkOiBcInRoZWFkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc1RhYmxlSGVhZDogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8VGFibGVSb3cgdGFnVGFibGVSb3c9XCJ0clwiIG5vVHlwZWFoZWFkPXt0cnVlfSBpbmRleD17MH0gdGV4dD17XCJcIn0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVSb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1RhYmxlUm93OiBcInRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzVGFibGVSb3c6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXswfSBpbmRleD17MH0gaGVhZGVyPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXsxfSBpbmRleD17MX0gaGVhZGVyPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXsyfSBpbmRleD17Mn0gaGVhZGVyPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRhYmxlQm9keSByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJsZUJvZHkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdUYWJsZUJvZHk6IFwidGJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzVGFibGVCb2R5OiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPFRhYmxlUm93IHRhZ1RhYmxlUm93PVwidHJcIiBub1R5cGVhaGVhZD17dHJ1ZX0ga2V5PXtpfSBpbmRleD17aSArIDF9IHRleHQ9e1wiXCJ9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlUm93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1RhYmxlUm93OiBcInRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNUYWJsZVJvdzogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXswfSBpbmRleD17MH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXsxfSBpbmRleD17MX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXsyfSBpbmRleD17Mn0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Lyo8VGFibGVGb290IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlRm9vdCh7IHRhZ1RhYmxlRm9vdDogXCJ0Zm9vdFwiLCBtYWtlUHJvcHNUYWJsZUZvb3Q6ICgpID0+ICh7IGNoaWxkcmVuOiBudWxsIH0pIH0pfSAvPiovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSl9IC8+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckdyaWRsaXN0LCBkZWZhdWx0UmVuZGVyR3JpZGxpc3RDaGlsZCwgZGVmYXVsdFJlbmRlckdyaWRsaXN0Um93LCBkZWZhdWx0UmVuZGVyR3JpZGxpc3RTZWN0aW9uLCBHcmlkbGlzdCwgR3JpZGxpc3RDaGlsZCwgR3JpZGxpc3RSb3csIEdyaWRsaXN0U2VjdGlvbiB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvZ3JpZGxpc3RcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJUYWJsZSwgZGVmYXVsdFJlbmRlclRhYmxlQm9keSwgZGVmYXVsdFJlbmRlclRhYmxlQ2VsbCwgZGVmYXVsdFJlbmRlclRhYmxlSGVhZCwgZGVmYXVsdFJlbmRlclRhYmxlUm93LCBUYWJsZSwgVGFibGVCb2R5LCBUYWJsZUNlbGwsIFRhYmxlSGVhZCwgVGFibGVSb3cgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L3RhYmxlXCI7XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50OyB9XG5cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD5CZWNhdXNlIExpc3Rib3hlcyBhcmUgbm90IGFsbG93ZWQgdG8gY29udGFpbiBpbnRlcmFjdGl2ZSBjb250ZW50LCBhIEdyaWRsaXN0IGlzIHNlbWFudGljYWxseSBhIGxpc3QgdGhhdCA8YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9ncmlkL1wiPmNvbXBsaWVzIHdpdGggdGhlIEFSSUEgcGF0dGVybiBmb3IgZ3JpZHM8L2E+LjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SW4gdGVybXMgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgdGFiYmluZyB0aHJvdWdoIGVsZW1lbnRzLCBhIEdyaWRsaXN0IGlzIGxpa2UgYSBMaXN0Ym94LCBidXQgaW4gdHdvIGRpbWVuc2lvbnMsIGxpa2UgYSBUYWJsZS48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgcm93cyBvZiBhIEdyaWRsaXN0IGFyZSBzb3J0YWJsZS4gSXQgaXMgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSwgaW5kZXBlbmRlbnRseSBzb3J0YWJsZSBzZWN0aW9ucyB3aXRoaW4gdGhlIHNhbWUgR3JpZGxpc3QuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkl0J3MgdXAgdG8geW91IHRvIG1ha2Ugc3VyZSB0aGF0IGFueSBpbnRlcmFjdGl2ZSBlbGVtZW50cyB3aXRoaW4gYSBHcmlkbGlzdCByZXNwb25kIHRvIGZvY3VzIG1hbmFnZW1lbnQgcHJvcGVybHkgd2l0aCA8Y29kZT5mb2N1c1NlbGY8L2NvZGU+IHByb3AgYW5kIGEgcHJvcGVybHkgcGxhY2VkIDxjb2RlPnRhYkluZGV4PXtcIntcIn1pbmZvLnJvdmluZ1RhYkluZGV4LnRhYmJhYmxlPyAwIDogLTF7XCJ9XCJ9PC9jb2RlPiBpbiB0aGUgPGNvZGU+cmVuZGVyPC9jb2RlPiBwcm9wLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkFueSBnaXZlbiByb3cgaW4gYSBHcmlkbGlzdCBjYW4gYmUgbWFya2VkIGFzIHNlbGVjdGVkLCBidXQgdGhpcyBpcyB1cCB0byB5b3UgdG8gaGFuZGxlIG1hbnVhbGx5IGF0IHRoZSBtb21lbnQ8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5cbmZ1bmN0aW9uIERlbW9HcmlkbGlzdENoaWxkMSh7IHJvdyB9OiB7IHJvdzogbnVtYmVyIH0pIHtcbiAgICBjb25zdCB0ZXh0ID0gXCJHcmlkbGlzdCBjaGlsZCBcIiArIHJvdztcbiAgICByZXR1cm4gPEdyaWRsaXN0Q2hpbGQgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBpbmRleD17MH0gbG9jYXRpb25JbmRleD17MH0gdGV4dD17dGV4dH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyR3JpZGxpc3RDaGlsZCh7IHRhZ0dyaWRsaXN0Q2hpbGQ6IFwiZGl2XCIsIG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQ6IChpbmZvKSA9PiAoeyBjaGlsZHJlbjogdGV4dCB9KSB9KX0gLz5cbn1cblxuZnVuY3Rpb24gRGVtb0dyaWRsaXN0Q2hpbGQyKCkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBbYiwgc2V0Ql0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIDxHcmlkbGlzdENoaWxkIGZvY3VzU2VsZj17KCkgPT4gcmVmLmN1cnJlbnQ/LmZvY3VzKCl9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gaW5kZXg9ezF9IGxvY2F0aW9uSW5kZXg9ezB9IHRleHQ9e2IudG9TdHJpbmcoKX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyR3JpZGxpc3RDaGlsZCh7IHRhZ0dyaWRsaXN0Q2hpbGQ6IFwiZGl2XCIsIG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQ6IChpbmZvKSA9PiAoeyBjaGlsZHJlbjogPGlucHV0IHJlZj17cmVmfSB0eXBlPVwiY2hlY2tib3hcIiB0YWJJbmRleD17aW5mby5yb3ZpbmdUYWJJbmRleC50YWJiYWJsZT8gMCA6IC0xfSBjaGVja2VkPXtifSBvbklucHV0PXtlID0+IHNldEIoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPiB9KSB9KX0gLz5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiB0YWJsZSByb3dzPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPEdyaWRsaXN0IGluaXRpYWxJbmRleD17MH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyR3JpZGxpc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0YWdHcmlkbGlzdDogXCJkaXZcIiwgbWFrZVByb3BzR3JpZGxpc3Q6IChpbmZvKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDxHcmlkbGlzdFNlY3Rpb24gaW5kZXg9ezB9IGNvbXBhcmVSb3dzPXsobGhzLCByaHMpID0+IGxocyAtIHJoc30gcmVuZGVyPXtkZWZhdWx0UmVuZGVyR3JpZGxpc3RTZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdHcmlkbGlzdFNlY3Rpb246IFwiZGl2XCIsIG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbjogKGluZm8pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBBcnJheS5mcm9tKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8R3JpZGxpc3RSb3cgaW5kZXg9e2l9IHRleHQ9XCJcIiByZW5kZXI9e2RlZmF1bHRSZW5kZXJHcmlkbGlzdFJvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0dyaWRsaXN0Um93OiBcImRpdlwiLCBtYWtlUHJvcHNHcmlkbGlzdFJvdzogKGluZm8pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogWzxEZW1vR3JpZGxpc3RDaGlsZDEgcm93PXtpfSAvPiwgPERlbW9HcmlkbGlzdENoaWxkMiAvPl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgcmVuZGVyLCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgSGVhZGluZyB9IGZyb20gXCIuLi9jb21wb25lbnQvaGVhZGluZ1wiO1xuaW1wb3J0ICogYXMgQWNjb3JkaW9uIGZyb20gXCIuL2RlbW9zL2FjY29yZGlvblwiXG5pbXBvcnQgKiBhcyBCdXR0b24gZnJvbSBcIi4vZGVtb3MvYnV0dG9uXCJcbmltcG9ydCAqIGFzIENoZWNrYm94IGZyb20gXCIuL2RlbW9zL2NoZWNrYm94XCJcbmltcG9ydCAqIGFzIENoZWNrYm94R3JvdXAgZnJvbSBcIi4vZGVtb3MvY2hlY2tib3gtZ3JvdXBcIlxuaW1wb3J0ICogYXMgTGlzdGJveE11bHRpIGZyb20gXCIuL2RlbW9zL2xpc3Rib3gtbXVsdGlcIlxuaW1wb3J0ICogYXMgTGlzdGJveFNpbmdsZSBmcm9tIFwiLi9kZW1vcy9saXN0Ym94LXNpbmdsZVwiXG5pbXBvcnQgKiBhcyBNZW51IGZyb20gXCIuL2RlbW9zL21lbnVcIlxuaW1wb3J0ICogYXMgUmFkaW8gZnJvbSBcIi4vZGVtb3MvcmFkaW9cIlxuaW1wb3J0ICogYXMgU2xpZGVyIGZyb20gXCIuL2RlbW9zL3NsaWRlclwiXG5pbXBvcnQgKiBhcyBEaWFsb2cgZnJvbSBcIi4vZGVtb3MvZGlhbG9nXCJcbmltcG9ydCAqIGFzIFRhYnMgZnJvbSBcIi4vZGVtb3MvdGFic1wiXG5pbXBvcnQgKiBhcyBUb29sdGlwIGZyb20gXCIuL2RlbW9zL3Rvb2x0aXBcIlxuaW1wb3J0ICogYXMgVG9hc3QgZnJvbSBcIi4vZGVtb3MvdG9hc3RcIlxuaW1wb3J0ICogYXMgVGFibGUgZnJvbSBcIi4vZGVtb3MvdGFibGVcIlxuaW1wb3J0ICogYXMgR3JpZGxpc3QgZnJvbSBcIi4vZGVtb3MvZ3JpZGxpc3RcIlxuXG4vL2ltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCI7XG4vL29wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBxdWV1ZU1pY3JvdGFzaztcblxuLy9jb25zdCBSYW5kb21Xb3JkcyA9IFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlwiLnNwbGl0KFwiIFwiKTtcblxuXG5jb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkRlbW9zXCI+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiRGlhbG9nXCI+PERpYWxvZy5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkdyaWRsaXN0XCI+PEdyaWRsaXN0LkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiVGFibGVcIj48VGFibGUuRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJUb2FzdFwiPjxUb2FzdC5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlRvb2x0aXBcIj48VG9vbHRpcC5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlRhYnNcIj48VGFicy5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlNsaWRlclwiPjxTbGlkZXIuRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJTaW5nbGUtc2VsZWN0IExpc3Rib3hcIj48TGlzdGJveFNpbmdsZS5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkFjY29yZGlvblwiPjxBY2NvcmRpb24uRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJCdXR0b25cIj48QnV0dG9uLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQ2hlY2tib3hcIj48Q2hlY2tib3guRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJDaGVja2JveCBHcm91cFwiPjxDaGVja2JveEdyb3VwLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiTXVsdGktc2VsZWN0IExpc3Rib3hcIj48TGlzdGJveE11bHRpLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiTWVudVwiPjxNZW51LkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiUmFkaW9cIj48UmFkaW8uRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIHsvKlxuICAgICAgIFxuICAgICAgICA8RGVtb1RhYmxlIC8+XG5cblxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxuICAgICAgICA8RGVtb1VzZURyb3BwYWJsZSAvPlxuICAgICAgICA8RGVtb1VzZURyYWdnYWJsZSAvPlxuICAgICAgICA8aW5wdXQgLz4qL31cbiAgICAgICAgPC9IZWFkaW5nPilcbn1cblxucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICByZW5kZXIoPENvbXBvbmVudCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpISk7XG59KVxuIl0sIm5hbWVzIjpbIkV2ZW50RGV0YWlsIiwiU3ltYm9sIiwiSGVhZGluZ0xldmVsQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJIZWFkaW5nIiwiY2hpbGRyZW4iLCJoZWFkaW5nIiwicHJvcHMiLCJoZWFkaW5nTGV2ZWxCZWZvcmVVcyIsInVzZUNvbnRleHQiLCJ0YWciLCJuZXdIZWFkaW5nTGV2ZWwiLCJ3YXJuT25PdmVyd3JpdGUiLCJfanN4IiwiX2pzeHMiLCJIZWFkaW5nUmVzZXQiLCJuZXdMZXZlbCIsInVzZUVuc3VyZVN0YWJpbGl0eSIsInBhcmVudEhvb2tOYW1lIiwidmFsdWVzIiwibGVuZ3RoIiwiZm9yRWFjaCIsInZhbHVlIiwiaW5kZXgiLCJoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSIsInVzZVJlZiIsInNob3duRXJyb3IiLCJjdXJyZW50IiwiY29uc29sZSIsImVycm9yIiwidXNlUGFzc2l2ZVN0YXRlIiwib25DaGFuZ2UiLCJnZXRJbml0aWFsVmFsdWUiLCJjdXN0b21EZWJvdW5jZVJlbmRlcmluZyIsInZhbHVlUmVmIiwiVW5zZXQiLCJ3YXJuaW5nUmVmIiwiY2xlYW51cENhbGxiYWNrUmVmIiwidW5kZWZpbmVkIiwib25TaG91bGRDbGVhblVwIiwidXNlQ2FsbGJhY2siLCJjbGVhbnVwQ2FsbGJhY2siLCJ0cnlFbnN1cmVWYWx1ZSIsImluaXRpYWxWYWx1ZSIsImV4IiwiZ2V0VmFsdWUiLCJ3YXJuIiwic2V0VmFsdWUiLCJhcmciLCJGdW5jdGlvbiIsInIiLCJwcmV2RGVwIiwibmV4dFZhbHVlIiwiZGVib3VuY2VSZW5kZXJpbmciLCJuZXh0RGVwIiwiYWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwiTWFwIiwibGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIndpbmRvd0ZvY3VzZWRVcGRhdGVycyIsImZvckVhY2hVcGRhdGVyIiwid2luZG93IiwibWFwIiwiZ2V0IiwidXBkYXRlcnMiLCJ1cGRhdGVyIiwibGFzdFNlbnQiLCJzZW5kIiwiZm9jdXNvdXQiLCJlIiwidGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwicmVsYXRlZFRhcmdldCIsIndpbmRvd0JsdXIiLCJXaW5kb3ciLCJjdXJyZW50VGFyZ2V0Iiwid2luZG93c0ZvY3VzZWRVcGRhdGVycyIsInNldCIsIlRhYmxlIiwiYmFzZTY0IiwicmFuZG9tNkJpdHMiLCJnZW5lcmF0ZVJhbmRvbUlkIiwicHJlZml4IiwicmFuZG9tNjRCaXRzIiwibiIsImpvaW4iLCJwcmV2aW91c0lucHV0cyIsInRvUnVuIiwiY29tbWl0TmFtZSIsIm9yaWdpbmFsQ29tbWl0Iiwib3B0aW9ucyIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsImNsZWFyIiwiYXJncyIsImVmZmVjdCIsImlucHV0cyIsInVzZVN0YWJsZUdldHRlciIsInJlZiIsInVzZUJlZm9yZUxheW91dEVmZmVjdCIsIkVycm9yIiwiZm4iLCJjdXJyZW50Q2FsbGJhY2tHZXR0ZXIiLCJpc09iamVjdCIsInR5cGUiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiT2JqZWN0IiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsIm9iamVjdFByb3RvIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwiY2FsbCIsInVubWFza2VkIiwicmVzdWx0Iiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0TGlrZSIsInVzZVN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic3RhdGUiLCJzZXRTdGF0ZVAiLCJ1c2VTdGF0ZVAiLCJzZXRTdGF0ZSIsImNhbGxiYWNrIiwicHJldlZhbHVlIiwidXNlTWFuYWdlZENoaWxkcmVuIiwicGFyZW50UGFyYW1ldGVycyIsIm1hbmFnZWRDaGlsZHJlbiIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsImdldEhpZ2hlc3RJbmRleCIsIm1hbmFnZWRDaGlsZHJlbkFycmF5IiwiaGlnaGVzdEluZGV4IiwiYXJyIiwicmVjIiwibG93ZXN0SW5kZXgiLCJmIiwiY2hpbGQiLCJmaWVsZCIsImhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCIsIlNldCIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMiLCJzaXplIiwiYWRkIiwibW91bnRlZCIsIm1vdW50cyIsInVubW91bnRzIiwiTWF0aCIsIm1heCIsInNoYXZlIiwic3BsaWNlIiwidXNlTWFuYWdlZENoaWxkIiwibWFuYWdlZENoaWxkIiwiaW5mbyIsInVzZUxheW91dEVmZmVjdCIsImZsYWdzIiwic3ViSW5mbyIsImVudHJpZXMiLCJmbGF0IiwicmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwidCIsIkFycmF5IiwiaXNBcnJheSIsImNsc3giLCJhcmd1bWVudHMiLCJnZXREb2N1bWVudCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImdsb2JhbFRoaXMiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsImxocyIsInJocyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInVzZU1lcmdlZENsYXNzZXMiLCJjbGFzcyIsImxoc0NsYXNzIiwiY2xhc3NOYW1lIiwibGhzQ2xhc3NOYW1lIiwicmhzQ2xhc3MiLCJyaHNDbGFzc05hbWUiLCJsaHNDbGFzc2VzIiwic3BsaXQiLCJyaHNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsImZyb20iLCJwcm9jZXNzUmVmIiwiaW5zdGFuY2UiLCJhc3NlcnQiLCJjb21iaW5lZCIsIl9jb3VudCIsIl9saHMiLCJfcmhzIiwic3R5bGVTdHJpbmdUb09iamVjdCIsInN0eWxlIiwiZnJvbUVudHJpZXMiLCJzdGF0ZW1lbnQiLCJ1c2VNZXJnZWRTdHlsZXMiLCJsb2ciLCJ1c2VNZXJnZWRQcm9wcyIsImxoc0FsbCIsInJoc0FsbCIsIl9saHNDaGlsZHJlbiIsIl9saHNDbGFzc05hbWUiLCJfbGhzU3R5bGUiLCJfbGhzUmVmIiwibGhzTWlzYyIsIl9yaHNDaGlsZHJlbiIsIl9yaHNDbGFzcyIsIl9yaHNDbGFzc05hbWUiLCJfcmhzU3R5bGUiLCJfcmhzUmVmIiwicmhzTWlzYyIsInJldCIsInVzZU1lcmdlZFJlZnMiLCJyaHNFbnRyaWVzIiwicmhzS2V5VSIsInJoc1ZhbHVlIiwicmhzS2V5IiwibGhzVmFsdWUiLCJtZXJnZWQiLCJtZXJnZUZ1bmN0aW9ucyIsInVzZVJlZkVsZW1lbnQiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwiaGFuZGxlciIsImNsZWFudXAiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVTZWxlY3RvciIsIm1hdGNoZXMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwiZ2V0Q2FuZGlkYXRlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiaW5jbHVkZUNvbnRhaW5lciIsImNhbmRpZGF0ZXMiLCJ1bnNoaWZ0IiwiZWwiLCJnZXRSb290Tm9kZSIsImlzSW5wdXQiLCJub2RlIiwiaXNIaWRkZW5JbnB1dCIsInJhZGlvU2V0IiwiZXNjYXBlIiwidGFnTmFtZSIsInNsaWNlIiwiYXBwbHkiLCJzb21lIiwid2lkdGgiLCJpc0hpZGRlbiIsIm5vZGVVbmRlckRldGFpbHMiLCJob3N0Iiwibm9kZVJvb3RIb3N0IiwiY29udGFpbnMiLCJhdHRhY2hlZCIsIm9yaWdpbmFsTm9kZSIsImlzWmVyb0FyZWEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoZWlnaHQiLCJfcmVmIiwiZ2V0U2hhZG93Um9vdCIsImdldENvbXB1dGVkU3R5bGUiLCJ2aXNpYmlsaXR5IiwiaXNEaXJlY3RTdW1tYXJ5IiwiZGlzcGxheUNoZWNrIiwiaXNOb2RlQXR0YWNoZWQiLCJwYXJlbnRFbGVtZW50Iiwicm9vdE5vZGUiLCJzaGFkb3dSb290IiwiYXNzaWduZWRTbG90IiwiZ2V0Q2xpZW50UmVjdHMiLCJwYXJlbnROb2RlIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImlzRGlzYWJsZWRGcm9tRmllbGRzZXQiLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUiLCJkaXNhYmxlZCIsImkiLCJpdGVtIiwidGFiSW5kZXgiLCJpc1Njb3BlIiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJjYW5kaWRhdGVUYWJpbmRleCIsInJlZ3VsYXJUYWJiYWJsZXMiLCJkb2N1bWVudE9yZGVyIiwiZmFjdG9yeSIsInRoaXMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJUeXBlRXJyb3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIl9vbk11dGF0aW9uIiwiYmluZCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImRlc3RydWN0b3IiLCJkaXNjb25uZWN0IiwicmVtb3ZlQXR0cmlidXRlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiX2Fkb3B0SW5lcnRSb290IiwiX21hbmFnZU5vZGUiLCJyZWdpc3RlciIsImRlcmVnaXN0ZXIiLCJfdW5tYW5hZ2VTdWJ0cmVlIiwiX3RoaXMzIiwiaW5lcnRTdWJyb290IiwiZ2V0SW5lcnRSb290Iiwic2V0SW5lcnQiLCJtYW5hZ2VkTm9kZXMiLCJzYXZlZEluZXJ0Tm9kZSIsInJlY29yZHMiLCJyZWNvcmQiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwiYXR0cmlidXRlTmFtZSIsIm1hbmFnZWROb2RlIiwiYXJpYUhpZGRlbiIsIkluZXJ0Tm9kZSIsImluZXJ0Um9vdCIsIl9ub2RlIiwiX292ZXJyb2RlRm9jdXNNZXRob2QiLCJfaW5lcnRSb290cyIsIl9zYXZlZFRhYkluZGV4IiwiX2Rlc3Ryb3llZCIsImVuc3VyZVVudGFiYmFibGUiLCJfdGhyb3dJZkRlc3Ryb3llZCIsImRlc3Ryb3llZCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJJbmVydE1hbmFnZXIiLCJfZG9jdW1lbnQiLCJfd2F0Y2hGb3JJbmVydCIsImFkZEluZXJ0U3R5bGUiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Eb2N1bWVudExvYWRlZCIsImluZXJ0IiwiaGFzIiwicGFyZW50IiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5lcnRFbGVtZW50IiwiX3RoaXMiLCJzaGFkb3dSb290QW5jZXN0b3IiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJIVE1MRWxlbWVudCIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9pbmVydFNpYmxpbmdzIiwiX2dldFBhcmVudHMiLCJfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiIsIl9oYW5kbGVNdXRhdGlvbnMiLCJudWxsYWJsZSIsInRvcCIsImVsZW1zIiwicHVzaCIsImluZGV4T2YiLCJfdG9wQ2hhbmdlZCIsInBvcCIsInJlbW92ZSIsIl9hIiwiX2IiLCJfYyIsIm5ld1RvcCIsInRvS2VlcEluZXJ0Iiwib2xkUGFyZW50cyIsIl9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzIiwibmV3UGFyZW50cyIsInRvU2tpcCIsImoiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwib2xkSW5lcnQiLCJuZXdJbmVydCIsInNpYmxpbmdzVG9SZXN0b3JlIiwiZGVsZXRlIiwiX3BhcmVudE1PIiwiZWxlbWVudHMiLCJtbyIsInNpYmxpbmdzIiwic2libGluZyIsImluZXJ0ZWRTaWJsaW5ncyIsIl9pc0luZXJ0YWJsZSIsInBhcmVudFRvT2JzZXJ2ZSIsIm1heWJlU2hhZHlSb290IiwiX19zaGFkeSIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInVzZUJsb2NraW5nRWxlbWVudCIsImVuYWJsZWQiLCJnZXRUYXJnZXQiLCJzdGFibGVHZXRUYXJnZXQiLCJ1c2VTdGFibGVDYWxsYmFjayIsImJsb2NraW5nRWxlbWVudHMiLCJ1c2VGb2N1c1RyYXAiLCJ0cmFwQWN0aXZlIiwiaGFuZGxlQWN0aXZlQ2hhbmdlIiwicmFmSGFuZGxlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicXVldWVNaWNyb3Rhc2siLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImdldFRvcEVsZW1lbnQiLCJlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8iLCJnZXRMYXN0QWN0aXZlRWxlbWVudCIsImdldEVsZW1lbnQiLCJ1c2VGb3JjZVVwZGF0ZSIsInVzZUhhc0ZvY3VzIiwib25Gb2N1c2VkQ2hhbmdlZCIsIm9uRm9jdXNlZElubmVyQ2hhbmdlZCIsIm9uTGFzdEZvY3VzZWRDaGFuZ2VkIiwib25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCIsIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UiLCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UiLCJvbldpbmRvd0ZvY3VzZWRDaGFuZ2UiLCJnZXRXaW5kb3ciLCJnZXRGb2N1c2VkIiwicmV0dXJuRmFsc2UiLCJzZXRGb2N1c2VkSW5uZXIiLCJzZXRMYXN0Rm9jdXNlZCIsInNldExhc3RGb2N1c2VkSW5uZXIiLCJ1c2VSZWZFbGVtZW50UHJvcHMiLCJnZXRBY3RpdmVFbGVtZW50IiwiZ2V0V2luZG93Rm9jdXNlZCIsInVzZUFjdGl2ZUVsZW1lbnQiLCJwcmV2QWN0aXZlRWxlbWVudCIsInNlbGZFbGVtZW50IiwiZm9jdXNlZCIsImZvY3VzZWRJbm5lciIsInNldEZvY3VzZWQiLCJsYXN0QWN0aXZlRWxlbWVudCIsInByZXZMYXN0QWN0aXZlRWxlbWVudCIsInVzZUhhc0ZvY3VzUHJvcHMiLCJnZXRMYXN0Rm9jdXNlZCIsImdldExhc3RGb2N1c2VkSW5uZXIiLCJ1c2VQcmVzcyIsImV4Y2x1ZGUiLCJoYXNGb2N1cyIsIm9uQ2xpY2tTeW5jIiwiYWN0aXZlIiwic2V0QWN0aXZlIiwiZ2V0QWN0aXZlIiwiZm9yY2VVcGRhdGUiLCJwIiwidGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJwc2V1ZG9BY3RpdmUiLCJ1c2VHbG9iYWxIYW5kbGVyIiwiXyIsInByZXYiLCJub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoIiwiRGF0ZSIsIm9uQWN0aXZlU3RhcnQiLCJhIiwib25BY3RpdmVTdG9wIiwidGltZURpZmZlcmVuY2UiLCJjdXJyZW50VGltZSIsImNoYXJhY3RlcnNTZWxlY3RlZCIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlUHJlc3MiLCJwdWxzZSIsImV4Y2x1ZGVzIiwiZGV0YWlsIiwiYnV0dG9uIiwib25Nb3VzZVVwIiwib25Nb3VzZUxlYXZlIiwib25DbGljayIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsInVzZVByZXNzUHJvcHMiLCJvbktleURvd24iLCJjdXJzb3IiLCJ1c2VUaW1lb3V0IiwidGltZW91dCIsInRyaWdnZXJJbmRleCIsInN0YWJsZUNhbGxiYWNrIiwic3RhcnRUaW1lUmVmIiwiZ2V0VGltZW91dCIsInRpbWVvdXRJc051bGwiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uIiwibGluZWFyTmF2aWdhdGlvbiIsIm5hdmlnYXRlVG9GaXJzdCIsIm50ZiIsIm5hdmlnYXRlVG9MYXN0IiwibnRsIiwibmF2aWdhdGVUb05leHQiLCJudG4iLCJuYXZpZ2F0ZVRvUHJldiIsIm50cCIsIm5hdmlnYXRpb25EaXJlY3Rpb24iLCJuZCIsImRpc2FibGVBcnJvd0tleXMiLCJkYWsiLCJkaXNhYmxlSG9tZUVuZEtleXMiLCJkaGVrIiwiZ2V0RGlzYWJsZUFycm93S2V5cyIsInVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyIsIm1ldGFLZXkiLCJnZXROYXZpZ2F0aW9uRGlyZWN0aW9uIiwiZ2V0RGlzYWJsZUhvbWVFbmRLZXlzIiwiZGlyZWN0aW9uQWxsb3dlZCIsImFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbiIsImFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uIiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbiIsInR5cGVhaGVhZE5hdmlnYXRpb24iLCJjb2xsYXRvciIsImdldEluZGV4IiwidHlwZWFoZWFkVGltZW91dCIsInNldEluZGV4Iiwibm9UeXBlYWhlYWQiLCJjdXJyZW50VHlwZWFoZWFkIiwiZ2V0Q3VycmVudFR5cGVhaGVhZCIsInNldEN1cnJlbnRUeXBlYWhlYWQiLCJzZXRJbnZhbGlkVHlwZWFoZWFkIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldEltZUFjdGl2ZSIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJzYWZlTGhzIiwiY29tcGFyZSIsIm5vcm1hbGl6ZSIsInNhZmVSaHMiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUNvbXBhcmUiLCJpbnNlcnRpbmdDb21wYXJhdG9yIiwidGV4dCIsImNvbXBhcmF0b3JTaGFyZWQiLCJzdWJzdHJpbmciLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJfZSIsImltZUFjdGl2ZSIsImN0cmxLZXkiLCJyZXZlcnNlIiwidXNlUm92aW5nVGFiSW5kZXgiLCJpbml0aWFsSW5kZXgiLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2UiLCJvblRhYmJhYmxlUmVuZGVyIiwic2V0VGFiYmFibGVJbmRleDIiLCJzZXRUYWJiYWJsZUluZGV4IiwiZnJvbVVzZXJJbnRlcmFjdGlvbiIsInByZXZJbmRleCIsIm5leHRJbmRleCIsImNoYW5nZUluZGV4IiwibmV4dENoaWxkIiwicGFyZW50UmV0dXJuVHlwZSIsImdldEF0IiwiZm9jdXNTZWxmIiwiY29weUFycmF5Iiwic291cmNlIiwiYXJyYXkiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwiYmFzZVJhbmRvbSIsImxvd2VyIiwidXBwZXIiLCJzaHVmZmxlU2VsZiIsImxhc3RJbmRleCIsInJhbmQiLCJhcnJheVNodWZmbGUiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiYmFzZVZhbHVlcyIsIm9iamVjdCIsImJhc2VUaW1lcyIsImFyZ3NUYWciLCJiYXNlSXNBcmd1bWVudHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJpc0xlbmd0aCIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsImZ1bmMiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIlN0cmluZyIsImlzUHJvdG90eXBlIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwibmF0aXZlS2V5cyIsImtleXMiLCJiYXNlS2V5cyIsImFzeW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiaXNBcnJheUxpa2UiLCJiYXNlU2h1ZmZsZSIsImNvbGxlY3Rpb24iLCJzaHVmZmxlIiwic2V0Rm9yY2VVcGRhdGUiLCJyZXR1cm5OdWxsIiwicmVhcnJhbmdlIiwic29ydGVkUm93cyIsImluZGV4QXNTb3J0ZWQiLCJpbmRleEFzVW5zb3J0ZWQiLCJtYW5nbGVNYXAiLCJkZW1hbmdsZU1hcCIsInVzZVJlYXJyYW5nZWFibGVQcm9wcyIsIl9wcmV2IiwibWFuZ2xlZEluZGV4IiwiaW5kZXhNYW5nbGVyIiwiZGVtYW5nbGVkSW5kZXgiLCJzb3J0IiwiaCIsInJlYXJyYW5nZWFibGVDaGlsZHJlbiIsImluZGV4RGVtYW5nbGVyIiwidXNlU29ydGFibGVDaGlsZHJlbiIsInNvcnRhYmxlQ2hpbGRyZW4iLCJ1c2VyQ29tcGFyZSIsImRlZmF1bHRDb21wYXJlIiwidXNlU29ydGFibGVQcm9wcyIsInJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUiLCJ1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbiIsIm1jIiwicm92aW5nVGFiSW5kZXgiLCJsaXN0TmF2aWdhdGlvbiIsImlkZW50aXR5IiwibSIsInUiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkIiwiZ2V0VGFiYmFibGVJbmRleCIsIm5hdmlnYXRlVG9JbmRleCIsInRyeU5hdmlnYXRlVG9JbmRleCIsImRlZmF1bHQiLCJzZWFyY2hEaXJlY3Rpb24iLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQiLCJjIiwidXNlTGlzdE5hdmlnYXRpb25Qcm9wcyIsInVzZUVmZmVjdCIsInVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyIsInRhYmJhYmxlIiwiZ2V0VGFiYmFibGUiLCJoaWRkZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwidXNlR3JpZE5hdmlnYXRpb24iLCJydGkiLCJscyIsImxuIiwidG4iLCJncmlkTmF2aWdhdGlvbiIsInJvd0luZGV4RGVtYW5nbGVyIiwicm93SW5kZXhNYW5nbGVyIiwic2V0Q3VycmVudENvbHVtbiIsImdldEN1cnJlbnRDb2x1bW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93IiwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCIsInBhcmVudExzUmV0dXJuVHlwZSIsInVzZUdyaWROYXZpZ2F0aW9uUm93IiwiYXNDaGlsZFJvd09mU2VjdGlvbiIsImFzQ2hpbGQiLCJhc1BhcmVudFJvd09mQ2VsbHMiLCJhc1BhcmVudCIsInVzZVJhbmRvbUlkIiwicmFuZG9tSWQiLCJiYWNrdXBSYW5kb21JZCIsImdldEJhY2t1cFJhbmRvbUlkIiwidXNlZElkIiwic2V0VXNlZElkIiwiZ2V0VXNlZElkIiwibWlzbWF0Y2hFcnJvclJlZiIsInVzZUJ1dHRvbiIsInRhZ0J1dHRvbiIsIm9uUHJlc3MiLCJwcmVzc2VkIiwidXNlQWNjb3JkaW9uIiwiYWNjb3JkaW9uIiwiX2N1cnJlbnRGb2N1c2VkSW5kZXgiLCJzZXRDdXJyZW50Rm9jdXNlZEluZGV4IiwiZ2V0Q3VycmVudEZvY3VzZWRJbmRleCIsIm1jUmV0dXJuVHlwZSIsIm9jbWMyIiwiY2hhbmdlVGFiYmVkSW5kZXgiLCJsaW5lYXJSZXR1cm5UeXBlIiwiY2hhbmdlRXhwYW5kZWRJbmRleCIsImdldEN1cnJlbnRJbmRleCIsIl9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCIsInVzZUNoaWxkcmVuRmxhZyIsIl9nZXRUYWJiZWRJbmRleCIsInJlZXZhbHVhdGVDbG9zZXN0Rml0Iiwib25JbmRleENoYW5nZSIsImRlYnVnTG9nIiwib3BlbkZyb21QYXJlbnQiLCJzZXRPcGVuRnJvbVBhcmVudCIsImdldE9wZW5Gcm9tUGFyZW50IiwidXNlQm9keUFzU291cmNlSWQiLCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlSGVhZGVyQXNSZWZlcmVuY2VySWQiLCJib2R5SWQiLCJnZXRCb2R5SWQiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQiLCJ1c2VIZWFkZXJBc1NvdXJjZUlkIiwidXNlQm9keUFzUmVmZXJlbmNlcklkIiwiaGVhZGVySWQiLCJnZXRIZWFkZXJJZCIsInVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIiwidXNlQm9keUFzU291cmNlSWRQcm9wcyIsInVzZUJvZHlBc1JlZmVyZW5jZXJJZFByb3BzIiwidXNlSGVhZGVyQXNTb3VyY2VJZFByb3BzIiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyIsIm9wZW4iLCJvcGVuRnJvbVVzZXIiLCJnZXRIZWFkZXJFbGVtZW50IiwidXNlSGVhZGVyUmVmRWxlbWVudFByb3BzIiwiZ2V0Qm9keUVsZW1lbnQiLCJ1c2VCb2R5UmVmRWxlbWVudFByb3BzIiwib3BlblJlZiIsImJvZHlFbGVtZW50IiwiaXNWYWxpZCIsInJldHVyblRydWUiLCJ0YWJiZWRSZWYiLCJ1c2VMYWJlbCIsImxhYmVsIiwicHJlZml4SW5wdXQiLCJwcmVmaXhMYWJlbCIsInRhZ0lucHV0IiwidGFnTGFiZWwiLCJ1c2VMYWJlbEFzU291cmNlSWQiLCJ1c2VMYWJlbEFzUmVmZXJlbmNlcklkIiwibGFiZWxJZCIsImdldExhYmVsSWQiLCJ1c2VJbnB1dEFzU291cmNlSWQiLCJ1c2VJbnB1dEFzUmVmZXJlbmNlcklkIiwiaW5wdXRJZCIsImdldElucHV0SWQiLCJ1c2VMYWJlbEFzU291cmNlSWRQcm9wcyIsInVzZUlucHV0QXNTb3VyY2VJZFByb3BzIiwidXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzIiwidXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzIiwiaXNTeW50aGV0aWNMYWJlbCIsInVzZUxhYmVsTGFiZWwiLCJ1c2VMYWJlbExhYmVsUHJvcHMiLCJwcm9wc1dpdGhvdXRGb3IiLCJwcm9wc1dpdGhGb3IiLCJ1c2VMYWJlbElucHV0IiwicHJvcHNXaXRoQXJpYUxhYmVsbGVkQnkiLCJwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSIsImhhbmRsZXNJbnB1dCIsImxhYmVsUG9zaXRpb24iLCJ3aGljaCIsInVzZUNoZWNrYm94TGlrZSIsImNoZWNrYm94TGlrZSIsImNoZWNrZWQiLCJyb2xlIiwib25DaGVja2VkQ2hhbmdlIiwiaGFzRm9jdXNJbnB1dCIsImhhc0ZvY3VzTGFiZWwiLCJzdGFibGVPbklucHV0IiwidXNlSUxJbnB1dCIsInVzZUlMTGFiZWwiLCJnZXRMYWJlbEVsZW1lbnQiLCJ1c2VMYWJlbFJlZkVsZW1lbnRQcm9wcyIsImxpc3RSZXR1cm5UeXBlIiwiYWxsSWRzIiwic2V0Q29udHJvbHMiLCJ1cGRhdGVJbmRleCIsInNldElkVXBkYXRlSW5kZXgiLCJjaGVja2VkQ291bnQiLCJzZXRDaGVja2VkQ291bnQiLCJnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUiLCJwZXJjZW50YWdlIiwic2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkIiwic2V0UGFyZW50Q2hlY2tib3hDaGVja2VkIiwidXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0IiwiY2hlY2tib3giLCJfdm9pZDIiLCJfdm9pZDMiLCJzZXRDaGVja2VkIiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQiLCJ1c2VDaGVja2JveExhYmVsRWxlbWVudCIsInVzZUNoZWNrYm94Iiwib25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyIiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyIsInVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyIsImFyaWFDb250cm9scyIsIm9uSW5wdXQiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyIsInVzZVNvZnREaXNtaXNzIiwib25DbG9zZSIsImdldEVsZW1lbnRzIiwic3RhYmxlT25DbG9zZSIsInN0YWJsZUdldEVsZW1lbnRzIiwiZ2V0T3BlbiIsIm9uQmFja2Ryb3BDbGljayIsImZvdW5kSW5zaWRlQ2xpY2siLCJuZXdFbGVtZW50IiwidmFsaWRGb2N1c2FibGVFbGVtZW50cyIsImZvY3VzYWJsZSIsIm1vdXNlRG93biIsImtleURvd24iLCJjYXB0dXJlIiwidG91Y2hTdGFydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VTb2Z0RGlzbWlzc1Byb3BzIiwidXNlTW9kYWwiLCJtb2RhbCIsImJvZHlJc09ubHlTZW1hbnRpYyIsImRlc2NyaXB0aXZlIiwic29mdERpc21pc3MiLCJnZXRUaXRsZUVsZW1lbnQiLCJwcmV2ZW50U2Nyb2xsIiwidGl0bGVFbGVtZW50IiwidXNlTW9kYWxJZEFzU291cmNlIiwidXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnQiLCJ1c2VCb2R5SWRBc1NvdXJjZSIsInVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlTW9kYWxSZWZFbGVtZW50IiwiZ2V0TW9kYWxFbGVtZW50IiwidXNlTW9kYWxCYWNrZHJvcCIsInVzZU1vZGFsQmFja2Ryb3BQcm9wcyIsIm9uUG9pbnRlclVwIiwidXNlRHJhd2VyIiwidXNlTGlzdGJveFNpbmdsZSIsInRhZ0xpc3QiLCJvblNlbGVjdCIsIl9sYnMiLCJzaW5nbGVTZWxlY3Rpb24iLCJzZWxlY3RlZEluZGV4Iiwic3MiLCJjaGlsZHJlbkhhdmVGb2N1cyIsImNoZiIsImxhYmVsUmV0dXJuVHlwZSIsIm9uU2VsZWN0ZWRJbmRleENoYW5nZSIsImV2ZW50IiwibmV3SW5kZXgiLCJzdGFibGVPblNlbGVjdCIsImVuaGFuY2VFdmVudCIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiIsInVzZUxhYmVsSW5wdXRQcm9wcyIsInVzZUxpc3Rib3hTaW5nbGVJdGVtIiwibGlzdGJveFNpbmdsZUl0ZW0iLCJydGlfcmV0Iiwic3NfcmV0IiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzIiwidXNlTGlzdGJveE11bHRpIiwibGlzdGJveE11bHRpIiwib3BlbmVyIiwidXNlck9uQ2xvc2UiLCJyZWFzb24iLCJzZW5kRm9jdXNUb01lbnUiLCJnZXRJc09wZW4iLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsImdldFN1cmZhY2VGdWxseVZpc2libGUiLCJzZXRTdXJmYWNlRnVsbHlWaXNpYmxlIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyeSIsImludGVyc2VjdGlvblJhdGlvIiwidGhyZXNob2xkIiwic2V0T3BlbmVyRWxlbWVudCIsImdldE9wZW5lckVsZW1lbnQiLCJnZXRCdXR0b25FbGVtZW50IiwidXNlQnV0dG9uUmVmRWxlbWVudFByb3BzIiwiZ2V0TWVudUVsZW1lbnQiLCJ1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcyIsInNvZnREaXNtaXNzUmV0dXJuIiwidXNlTWVudVN1cmZhY2VQcm9wcyIsInVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMiLCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsIiwidXNlU2VudGluZWxQcm9wcyIsInJlc3QiLCJ1c2VGb2N1c1NlbnRpbmVsIiwiZm9jdXNTZW50aW5lbCIsInVzZU1lbnVTZW50aW5lbFByb3BzIiwibWVudVN1cmZhY2UiLCJ1c2VUYWJzIiwidGFiUGFuZWxzIiwib2NtYyIsInRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiIsImJhc2VJZCIsIm1hbmFnZWRDaGlsZHJlblJldCIsImNoYW5nZVZpc2libGVQYW5lbCIsImdldFZpc2libGVJbmRleCIsImNsb3Nlc3RGaXQiLCJ1c2VUYWJMaXN0TGFiZWwiLCJ1c2VUYWJMaXN0TGFiZWxQcm9wcyIsInVzZVRhYkxpc3QiLCJ0YWJzIiwidGFiTGlzdE1hbmFnZWRDaGlsZHJlbiIsInN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZSIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMiLCJsaXN0TmF2UmV0MSIsInVzZVRvb2x0aXAiLCJtb3VzZW92ZXJEZWxheSIsIm1vdXNlb3V0VG9sZXJhbmNlRGVsYXkiLCJmb2N1c0RlbGF5IiwiZGVmYXVsdFByZXZlbnRlZCIsInNldE9wZW4iLCJzZXRIb3ZlclN0YXRlIiwic2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJpc0Zpbml0ZSIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlIiwic2V0VG9vbHRpcEZvY3VzZWQiLCJvbkhvdmVyQ2hhbmdlIiwiaG92ZXJpbmciLCJob3ZlclN0YXRlIiwic2V0VG9vbHRpcEhvdmVyIiwidHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJob3ZlckRlbGF5Q29ycmVjdGVkIiwidXNlVG9vbHRpcFRyaWdnZXIiLCJzZXRUcmlnZ2VySG92ZXIiLCJvblRvdWNoRW5kIiwicmFkaW9Hcm91cCIsIm9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSIsInNlbGVjdGVkVmFsdWUiLCJ0YWdHcm91cCIsInRhZ0dyb3VwTGFiZWwiLCJzZWxlY3Rpb25Nb2RlIiwiX2dldFJhZGlvR3JvdXBQYXJlbnRFbGVtZW50Iiwic2V0U2VsZWN0ZWRJbmRleCIsInVzZUdyb3VwTGFiZWxJbnB1dCIsInVzZUdyb3VwTGFiZWxMYWJlbCIsInVzZUdyb3VwTGFiZWxJbnB1dFByb3BzIiwidXNlR3JvdXBMYWJlbExhYmVsUHJvcHMiLCJsaXN0TmF2UmV0IiwidXNlUmFkaW9Hcm91cExhYmVsUHJvcHMiLCJieU5hbWUiLCJ1c2VSYWRpbyIsInVzZVRvYXN0cyIsIm9jbXUiLCJ0b2FzdHMiLCJ2aXNpYmxlQ291bnQiLCJjdXJyZW50SW5kZXhRdWV1ZSIsInBvbGl0ZW5lc3MiLCJzZXRQb2xpdGVuZXNzIiwiZ2V0TWF4VmlzaWJsZUNvdW50IiwiaGlnaGVzdFByaW9yaXR5VG9hc3QiLCJ0b2FzdFF1ZXVlIiwic2hvdyIsIm9uQW55VG9hc3RNb3VudGVkIiwidG9hc3RJbmRleCIsInNldE51bWJlckFoZWFkT2ZNZSIsIl9pbmRleCIsInJlbW92YWxJbmRleCIsInNob3dIaWdoZXN0UHJpb3JpdHlUb2FzdCIsIl9tb3VzZU92ZXIyIiwic2V0TW91c2VPdmVyIiwiX2dldE1vdXNlT3ZlciIsIm1vdXNlT3ZlciIsInRvYXN0IiwibnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMiLCJzZXROdW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyIsIkluZmluaXR5IiwiZGlzbWlzc2VkMiIsInNldERpc21pc3NlZDIiLCJnZXREaXNtaXNzZWQyIiwic2hvd2luZzIiLCJzZXRTaG93aW5nMiIsImdldFNob3dpbmcyIiwiZGlzbWlzcyIsIm9uQW55VG9hc3REaXNtaXNzZWQiLCJzZXRDdXJyZW50U29ydENvbHVtbiIsImJvZHlTb3J0IiwiZ3JpZE5hdlJldDEiLCJtYW5nbGVycyIsInJvd3MiLCJ0YWJsZVJvdyIsImxvY2F0aW9uIiwidGFnVGFibGVSb3ciLCJnZXRDZWxscyIsImNlbGxzIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsIiwidXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyIsImdyaWROYXZSZXQyIiwiYXNQYXJlbnRPZkNlbGxzIiwidXNlVGFibGVDZWxsIiwidGFibGVDZWxsIiwidGFnVGFibGVDZWxsIiwiaGVhZGVyVHlwZSIsInNldE15U29ydERpcmVjdGlvbiIsInVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzIiwiZ3JpZE5hdlJldDMiLCJzb3J0SW5mbyIsImdldEN1cnJlbnRTb3J0Q29sdW1uIiwiZGlyZWN0aW9uIiwiY2VsbEluZGV4IiwiY2VsbCIsInVzZVRhYmxlQ2VsbFByb3BzIiwic2NvcGUiLCJteVNvcnREaXJlY3Rpb24iLCJ1c2VHcmlkbGlzdCIsInVzZUdyaWROYXZpZ2F0aW9uUHJvcHMiLCJ1c2VHcmlkbGlzdFJvdyIsImdyaWRsaXN0Um93IiwibG9jYXRpb25JbmRleCIsInVzZUdyaWRsaXN0Q2hpbGQiLCJBY2NvcmRpb24iLCJtZW1vIiwiZXhwYW5kZWRJbmRleCIsInJlbmRlciIsInVzZUFjY29yZGlvblNlY3Rpb24iLCJkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlIiwibWFrZUlucHV0UHJvcHMiLCJtYWtlTGFiZWxQcm9wcyIsIm1vZGlmeUlucHV0UHJvcHMiLCJtb2RpZnlMYWJlbFByb3BzIiwiaW5wdXRQcm9wc0Jhc2UiLCJsYWJlbFByb3BzQmFzZSIsImlucHV0UHJvcHMiLCJsYWJlbFByb3BzIiwiaW5wdXQiLCJkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cENoaWxkIiwiZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXAiLCJVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0IiwiQ2hlY2tib3hHcm91cCIsInBhcmVudERpc2FibGVkIiwiZGVmYXVsdFJlbmRlclBvcnRhbCIsInBvcnRhbElkIiwicG9ydGFsUmVmIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVQb3J0YWwiLCJkZWZhdWx0UmVuZGVyTW9kYWwiLCJ0YWdGb2N1c0NvbnRhaW5lciIsInRhZ0JhY2tkcm9wIiwidGFnQm9keSIsInRhZ0RpYWxvZyIsInRhZ1RpdGxlIiwibWFrZVByb3BzRm9jdXNDb250YWluZXIiLCJtYWtlUHJvcHNCYWNrZHJvcCIsIm1ha2VQcm9wc0JvZHkiLCJtYWtlUHJvcHNEaWFsb2ciLCJtYWtlUHJvcHNUaXRsZSIsImRpYWxvZ0luZm8iLCJtb2RpZnlGb2N1c0NvbnRhaW5lclByb3BzIiwibW9kaWZ5RGlhbG9nUHJvcHMiLCJtb2RpZnlUaXRsZVByb3BzIiwibW9kaWZ5Qm9keVByb3BzIiwibW9kaWZ5QmFja2Ryb3BQcm9wcyIsInRpdGxlQ2hpbGRyZW4iLCJ0aXRsZVByb3BzIiwiYm9keUNoaWxkcmVuIiwiYm9keVByb3BzIiwiZGlhbG9nQ2hpbGRyZW4iLCJkaWFsb2dQcm9wcyIsImJhY2tkcm9wQ2hpbGRyZW4iLCJiYWNrZHJvcFByb3BzIiwiZm9jdXNDb250YWluZXJDaGlsZHJlbiIsImZvY3VzQ29udGFpbmVyUHJvcHMiLCJ0aXRsZSIsImRpYWxvZyIsImJhY2tkcm9wIiwiTGlzdGJveFNpbmdsZUNvbnRleHQiLCJvbkFsbExvc3RGb2N1cyIsIm9uQW55R2FpbmVkRm9jdXMiLCJNZW51IiwiZGVmYXVsdFJlbmRlclJhZGlvR3JvdXAiLCJtYWtlUHJvcHNHcm91cCIsIm1ha2VQcm9wc0xhYmVsIiwibW9kaWZ5R3JvdXBQcm9wcyIsIlNsaWRlclRodW1iQ29udGV4dCIsIlNsaWRlciIsIm1pbiIsInVzZVNsaWRlclRodW1iIiwiX3NsaWRlckluZm8iLCJ1c2VTbGlkZXIiLCJzbGlkZXIiLCJMb2NhdGlvbkNvbnRleHQiLCJUYWJsZVNlY3Rpb25Db250ZXh0IiwiVGFibGVCb2R5Q29udGV4dCIsIlRhYmxlUm93Q29udGV4dCIsIlRhYmxlQ2VsbENvbnRleHQiLCJkZWZhdWx0UmVuZGVyVGFibGUiLCJ0YWdUYWJsZSIsIm1ha2VQcm9wc1RhYmxlIiwibW9kaWZ5UHJvcHNUYWJsZSIsImRlZmF1bHRSZW5kZXJUYWJsZUJvZHkiLCJ0YWdUYWJsZUJvZHkiLCJtYWtlUHJvcHNUYWJsZUJvZHkiLCJtb2RpZnlQcm9wc1RhYmxlQm9keSIsImRlZmF1bHRSZW5kZXJUYWJsZUhlYWQiLCJ0YWdUYWJsZUhlYWQiLCJtYWtlUHJvcHNUYWJsZUhlYWQiLCJtb2RpZnlQcm9wc1RhYmxlSGVhZCIsImRlZmF1bHRSZW5kZXJUYWJsZVJvdyIsIm1ha2VQcm9wc1RhYmxlUm93IiwibW9kaWZ5UHJvcHNUYWJsZVJvdyIsIm1ha2VQcm9wc1RhYmxlQ2VsbCIsIm1vZGlmeVByb3BzVGFibGVDZWxsIiwiVGFiQ29udGV4dCIsIlRhYlBhbmVsQ29udGV4dCIsIlRhYnMiLCJkZWZhdWx0UmVuZGVyVG9vbHRpcCIsInRhZ1Rvb2x0aXAiLCJtYWtlVG9vbHRpcFByb3BzIiwibWFrZVRyaWdnZXJQcm9wcyIsIm1vZGlmeVByb3BzVG9vbHRpcCIsIm1vZGlmeVByb3BzVHJpZ2dlciIsIkxvY2F0aW9uSW5kZXhDb250ZXh0IiwiR3JpZGxpc3RTZWN0aW9uQ29udGV4dCIsIkdyaWRsaXN0Um93Q29udGV4dCIsIkdyaWRsaXN0Q2hpbGRDb250ZXh0IiwiZGVmYXVsdFJlbmRlckdyaWRsaXN0IiwidGFnR3JpZGxpc3QiLCJtYWtlUHJvcHNHcmlkbGlzdCIsIm1vZGlmeVByb3BzR3JpZGxpc3QiLCJkZWZhdWx0UmVuZGVyR3JpZGxpc3RTZWN0aW9uIiwidGFnR3JpZGxpc3RTZWN0aW9uIiwibWFrZVByb3BzR3JpZGxpc3RTZWN0aW9uIiwibW9kaWZ5UHJvcHNHcmlkbGlzdFNlY3Rpb24iLCJCbHVyYiIsIl9GcmFnbWVudCIsIkNvZGUiLCJEZW1vIiwiRGVtb0NoZWNrYm94IiwiRGVtb0xpc3RJdGVtIiwiRGlhbG9nLkRlbW8iLCJHcmlkbGlzdC5EZW1vIiwiVGFibGUuRGVtbyIsIlRvYXN0LkRlbW8iLCJUb29sdGlwLkRlbW8iLCJUYWJzLkRlbW8iLCJTbGlkZXIuRGVtbyIsIkxpc3Rib3hTaW5nbGUuRGVtbyIsIkFjY29yZGlvbi5EZW1vIiwiQnV0dG9uLkRlbW8iLCJDaGVja2JveC5EZW1vIiwiQ2hlY2tib3hHcm91cC5EZW1vIiwiTGlzdGJveE11bHRpLkRlbW8iLCJNZW51LkRlbW8iLCJSYWRpby5EZW1vIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUErRUMsTUFBQUEsV0FBQSxHQUFBQyxNQUFBLENBQUEsY0FBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUMxRUQsTUFBTUMsbUJBQW1CLEdBQUdDLEdBQWEsQ0FBQyxDQUFELENBQXpDLENBQUE7SUFHSSwyQkFBNkJDLFFBQWdDLElBQUEsRUFBQTtNQUFBLElBQUQ7UUFBQ0MsUUFBRDtRQUFDQyxPQUFEO1FBQUMsR0FBQUMsS0FBQUE7T0FBQSxHQUFBLElBQUEsQ0FBQTtJQUM3RCxFQUFBLE1BQU1DLG9CQUFzQyxHQUFBQyxDQUFBLENBQUFQLG1C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QUEwc0MsR0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQ0kzc0MsR0FBQyxDQUFBMHNDLE9BQUssS0FBRyxFQUNUMXNDLEdBQUEsQ0FBQzRzQyxNQUFJLEVBQUEsRUFBQSxDQUFHLEVBQ1I1c0MsR0FBQyxDQUFBLFVBQVUsRUFBQyxFQUFBLFFBQVEsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFDLFFBQVEsRUFBQSxDQUFHLEVBQzVDQSxHQUFBLENBQUMsVUFBVSxFQUFDLEVBQUEsUUFBUSxFQUFDLE1BQU0sRUFBQyxHQUFHLEVBQUMsUUFBUSxFQUFBLENBQUcsRUFDM0NBLEdBQUMsQ0FBQSxVQUFVLEVBQUMsRUFBQSxRQUFRLEVBQUMsTUFBTSxFQUFDLEdBQUcsRUFBQyxRQUFRLEVBQUEsQ0FBRyxFQUMzQ0EsR0FBQSxDQUFDLFVBQVUsRUFBQyxFQUFBLFFBQVEsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFDLEtBQUssRUFBQSxDQUFHLEVBQ3pDQSxHQUFBLENBQUMsVUFBVSxFQUFBLEVBQUMsUUFBUSxFQUFDLE1BQU0sRUFBQyxHQUFHLEVBQUMsS0FBSyxFQUFBLENBQUcsRUFDeENBLEdBQUEsQ0FBQyxVQUFVLEVBQUMsRUFBQSxRQUFRLEVBQUMsTUFBTSxFQUFDLEdBQUcsRUFBQyxLQUFLLEdBQUcsRUFDeENBLEdBQUEsQ0FBQyxNQUFNLEVBQUEsRUFBQyxXQUFXLEVBQUVxSyxhQUFXLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sSUFBSSxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsQ0FBQSxlQUFBLEVBQWtCLE9BQU8sR0FBRSxTQUFTLEdBQUcsV0FBVyxDQUFBLENBQUEsQ0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFJLENBQUEsQ0FBQSxFQUFBLENB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RSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFDLE9BQU8sRUFBQyxRQUFRLEVBQUMsT0FBTyxFQUFHLENBQUEsRUFDdEk5c0MsSUFBQzhzQyxjQUFZLEVBQUEsRUFBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFDLFVBQVUsRUFBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBQyxPQUFPLEVBQUMsUUFBUSxFQUFDLE9BQU8sRUFBRyxDQUFBLEVBQ3RJOXNDLEdBQUMsQ0FBQThzQyxjQUFZLElBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUMsS0FBSyxFQUFDLFFBQVEsRUFBQyxPQUFPLEdBQUcsRUFDcEk5c0MsR0FBQSxDQUFDOHNDLGNBQVksRUFBQSxFQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFDLEtBQUssRUFBQyxRQUFRLEVBQUMsT0FBTyxFQUFBLENBQUcsRUFDcEk5c0MsR0FBQyxDQUFBOHNDLGNBQVksRUFBQyxFQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFDLE9BQU8sRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFHLENBQUEsRUFDcEk5c0MsR0FBQyxDQUFBOHNDLGNBQVksRUFBQyxFQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFDLE9BQU8sRUFBQyxRQUFRLEVBQUMsS0FB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aHRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsVUFBVSxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDaXRDLElBQWEsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ3ZEanRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsT0FBTyxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDa3RDLE1BQVUsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ2pEbHRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsT0FBTyxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDbXRDLE1BQVUsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ2pEbnRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsU0FBUyxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDb3RDLE1BQVksRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ3JEcHRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsTUFBTSxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDcXRDLE1BQVMsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQy9DcnRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsUUFBUSxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDc3RDLE1BQVcsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ25EdHRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsdUJBQXVCLEVBQUMsUUFBQSxFQUFBQSxHQUFBLENBQUN1dEMsTUFBa0IsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ3pFdnRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsV0FBVyxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDd3RDLE1BQWMsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ3pEeHRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsUUFBUSxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDeXRDLE1BQVcsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ25EenRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsVUFBVSxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDMHRDLE1BQWEsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ3ZEMXRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsUUFBQSxFQUFBQSxHQUFBLENBQUMydEMsTUFBa0IsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ2xFM3RDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsc0JBQXNCLEVBQUMsUUFBQSxFQUFBQSxHQUFBLENBQUM0dEMsTUFBaUIsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQ3ZFNXRDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsTUFBTSxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDNnRDLE1BQVMsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLEVBQy9DN3RDLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxPQUFPLEVBQUMsT0FBTyxFQUFDLFFBQUEsRUFBQUEsR0FBQSxDQUFDOHRDLE1BQVUsRUFBRyxFQUFBLENBQUEsRUFBQSxDQUFVLENBVTNDLEVBQUEsQ0FBQSxFQUFDO0lBQ25CLENBQUMsQ0FBQTtJQUVELHFCQUFxQixDQUFDLE1BQUs7SUFDdkIsSUFBQWxJLEdBQU0sQ0FBQzVsQyxHQUFBLENBQUMsU0FBUyxFQUFBLEVBQUEsQ0FBRyxFQUFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUM7Ozs7OzsifQ==
